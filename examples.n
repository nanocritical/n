import c99 as c

import io math glib.test

Bool __is64bit

if U64 == c.long
  os.out.say '64 bit machine'
  say '64 bit machine'
  __is64bit = true
else
  __is64bit = false


fun foo a : c.long = x, y : U32
  if __is64bit
    x = U32.truncate a >> 32
  else
    x = 0

  y = U32.slice a & 0xffffffff
  return x y


fun bar a b : I32 = x :string
  prefix := if a == 0 { "test" } else { "ahaha!" }
  postfix := if b == 1 -- Do not allow both { and newline?
      "retest"
    else
      "no more test"
  return prefix + postfix


fun help = Void
  say \
'''My help message.
Over many lines:
  -a	  Try that!
  -b	  Or this one.
  --help  This message.
'''

-- type[] is different from C's type[]. type[] is a strongly-typed array, with a size field.
-- *type is an address, and is like C's type[] (except wrt sizeof() behavior)

-- We probably should allow variable name shadowing. It's really a source of
-- problems in C or C++ because of macro expansion and method arguments/class
-- fields clashes. We won't allow these.

fun main args : string[] = os.Err
  a, b := false, false
  for s y in args
    if s == '--help'
      help
      return 0
    if s == '-a'
      aa, err := Bool.parse y
      if err
	return 1

      a = aa
    elif s == '-b'
      bb, except err := Bool.parse y


interface Singer
  method work arg :string


struct Fields =
  x y : I32
  -- The only __ctor__ does not take any arguments. Static methods are used in other cases.
  -- __ctor__ is meant to be used only rarely.
  --
  -- Because there is a second return value, you are not allowed to
  -- create a Fields without an explicit binding of the second return
  -- value.
  method __ctor__ = .: Fields _: os.Err
    -- . is created because it's a return value...
    -- So __ctor__ is not really built-in... Just guarantees that first return value
    -- has the right type?
    .__memclear
    if biglock.locked
      return . os.Err.INVAL
    return . os.Err.OK

  -- Maybe we shouldn't allow the above, and all __ctor__ should have a single argument,
  -- single return value.
  -- Static functions would be used for everything else.

  method __dtor .: Fields = Void
  ? .x == 0 and .y == 0
    return

  -- This is reserved and is the struct of this object. Not defined for
  -- standalone functions.

  -- You cannot define
  -- fun __copy other : !This = Void
  --
  -- Sorry, we don't allow copy with side effects. A copy should always be a
  -- copy. We try to enforce that as much as possible from the language's point
  -- of view.
  --
  method __copy__ other : .This = Void
    _!memcopy other
    _!x = other.x + 1


struct Baryton<Y : any> : Singer =
  import Lock
  from Fields import
  from module import -- Why not?
  from othermod import foo -- Would be static function

  _hidden : I32

  fun mk = Baryton<Y>
    return .ctor

  method setall x y : I32 = Void
  method setx x : I32 = Void
    -- Only allow explicit capture, by copy, always.
    printer :=
      fun(.) val : I32 = Void
	os.say val + .y
    globalprinter = printer

    globalprinter x
    .x = x
    ._hidden += 1

    ref := &.
    printerbyref :=
      fun[ref] val : I32 = Void
        os.say val + .y

    -- Unsafe, captured a reference to .
    globalprinter = printer

  /method getx = I32
    /_hidden = 1
    return .x

  method work arg :string
  method<T> morework args : T[]


fun<T : any> constref b :  /Baryton<T> = /I32
  return /b/x


fun<T : any> mutableref b :  !Baryton<T> = !I32
  return !b!x

fun<T : any> getfield b:  !T = I32
  return b.x

-- Or could be written (should, really)
fun<T : any> getfield b:  .T = I32
  return b.x


-- When I'm using a reference, do I want to know that I'm dereferencing? Not
-- when I'm using a value, but yes when I'm setting it.
fun useref x : !I32 = I32
  return x.

fun setref x : !I32 = I32
  x! = 3

fun ref x : !I32 = !I32
  return x

fun constref x : !I32 = .I32
  -- Implicit convertion from mutable to const
  return x

struct Object =
  x y I32
  method copyx other : .Object = Void
    !x = other.x
  method copyxto other : !Object = Void
    other!x = .x


-- If we really are keeping C semantics, and we want to make it easy to call
-- external functions, we need to be careful about what restrictions we allow.
-- Or any external call would require unsing "unsafe" everywhere to break out
-- of local restrictions.

-- We want to say all of these things about references.
--
--   Mutable | Const
--	mutable |
--	! | .
--     
--   Can take copy of ref | Cannot take copy of ref
--      shareable, mayshare |
--	shared |
--      unique |
--   Nullable | Non-nullable
--	nullable |
-- 
-- Should we just never allow ref taking? For instance, would have to use
-- a smart pointer.
fun takeref obj :sp<Object> = ret : Fields
  ret.o = obj
  return ret


-- I have the feeling we should assume "unique" always, and allow explicit
-- marking such as shared<> and shareable<>. shared<> is a managed
-- smart-pointer, shareable<> is a reference that is copyable (and escapable),
-- but the user is in charge of doing it right. It's ok to take a local copy of
-- the reference. What is not OK is to let them escape function scopes (i.e.
-- via return values or state).

-- Could also be written as in:
-- The idea being that shared is a 'function', that binds stronger than ':'. Is
-- that what a template is in general?

fun takeref obj : shared .Object = ret : Fields
  ret.o = obj
  return ret


struct Template Y : any =
  x : Y
  y : shared .Y


struct shared Y : any =
  _px : .Y
  _count : I32


struct Iterable X : any = (Iterable X)


struct Morecomplex X Y : any = (Iterable X) () Hasy (Keyed Y)
  _len : U32
  _y : Y

  method getbykey y : Y = X
  method __get x : U32 = X
  method __iter = (Iterator X)

struct Morecomplexiter X Y : any = (Iterator X)
  _c : wide .(Morecomplex X Y)
  _pos : U32
  
  method __hasnext = Bool
    return _pos < _c.len - 1
  method __next = .X
    p := _pos
    _pos += 1
    return c.[p]


struct Dataimpl =
struct Data =
  _ : Dataimpl

-- Could we allow this, without the use of a reference? Just means there is an
-- allocator that we link to, but that we cannot see? There isn't really a
-- requirement that we should always see the sizes statically/by header
-- inclusion. Why is that a generic requirement?


fun<X> pair2array p : X,X = X[]
  return p.asarray -- Not runtime free.

fun<Y : Iterable X> wants2elements v : Y = U32
  n : U32 := 0
  for x in v:
    n += x + (foo x)
  return n + v[1]


-- . read-only ref
-- ! read-write ref
-- ? nullable marker

-- To go from nullable to regular ref, you need an explicit check. Simple analysis only?
-- And "malloc" returns non-nullable refs.

fun barfoo x : .Type = int32

fun foobar x : ?.Type = int32
  if x == null
    return 0
  else
    return barfoo x


unique struct Alwaysoneref =
  x y : I32


struct Values : I32
| FIRST = 2
| SECOND
| THIRD
| FOURTH

fun valuescount = U32
  return Values.__count

fun valuesstring v : Values = string
  return Values.__strings[v]


-- Copyable because there are no references.
struct Copyable =
  x y : I32

struct Noncopyable =
  x y :  I32
  obj :  !Object

struct Madecopyable =
  x y : I32
  obj : !Object
  method __copyctor other : .Madecopyable = .: .Madecopyable
  ? other.obj != null
    .__memcopy(other)
    .obj
    

-- The only references that can be passed are "safe":  i.e. cannot be
-- remembered, i.e. escaped. Otherwise references must be 



-- Really, what I want to be explicit, is when I'm giving a reference the
-- callee may remember. I don't care if I pass by reference but that he cannot
-- remember it. Unless it's another thread, it's really not something I would
-- worry about.
fun foo = Void
  x := 0U32
  y : U32 := 0
  maytakeref !x
  cannottakeref x

fun maytakeref x : !U32 = Void
  globalxref = x
fun cannottakeref x : .U32 = Void
  os.say .x


fun Baryton<Y>/setall x y = Void
  /x = x
  /y = y


fun lock<T> lk : T = Void
! not (caller.has lk)
  lk.dolock
! caller.has lk


-- ! are property we declare (and that a we could try to prove)
-- ? are property to check at runtime (or earlier, and may optimized away if proven so)
--
-- Is there really a distinction? I think there is, but it's a question of
-- optimization in a way. ? means we want it checked: statically or at runtime.
-- ! are affirmations: it would be great to check them, but it might be
-- impossible or expensive to do so.
--
-- We can reuse ?/! properties to infer things on callers.
--
-- ?/! are side-effect free. We enforce it at compile-time. We prevent code
-- with side-effect from running -- in that context. It's like calling a pure
-- function (in fact that's how it is implemented).
--
-- So ? can always be removed at runtime.
--
-- Additionally, we want to make ! propositions a logic language. We're making
-- statements about what the function does. That could be an additional distinction:
-- ? asks, ! affirm.
--
-- But we want to allow stating something about the context, i.e. the caller.
--   _.caller.has lock
-- 

-- A different approach, is to have ! code by compile-time code that manipulates
-- a state that analyzes instantation. For instance, whenever
--   fun root = Void
--     with globallock:
--       foobar
--   
--   fun foobar = Void
--   ! _.caller.haslock globallock
--
-- is called/instantiated, i.e. at compile time, we run that piece of code and check
-- that indeed it is true.
--   Proof by execution?
--
-- This is to relate to the smart-circuit / circuit generation idea.
--
--
fun onecaller = Void
! _.exclusive_unlocked
--
-- Can only be called by one caller at a time, to be enforced at compilation time (i.e.
-- only accept the strictest cases). Analyze the call graph, i.e. with an understanding
-- of where parallel threads of executions are, and ensure that this is correct.

-- ! and ~ manipulate the static state graph, and can do as much work as they
-- want to label it (only allowed to label their own "level"). Then there is a
-- normalized pass on the gprah catching a category of conflicts in the labelling
-- of nodes. We would likely also allow custom analysis passes.


fun Baryton.work arg :string = Void
! _.has lock
! caller.has .lock and \
    not caller.caller.has .lock
! prop23 arg
? arg.length >= 2
? .lock
  c := arg[0]
  d := arg[1]
  .x = c.code
  .y = y.code
? .x != 0 and .y != 0


interface Tintf
  x y : I32


fun<T : Tintf> Baryton.morework args : T[]
  for a in args
    ? a.__Type == T
    .x *= a.__Type.convert a
    .y += a.__Type.convert a


-- In file examples.nh:

import c99 as c


module Some:
  foo aa : c.long = U32 -- Error, does not have the same name
  bar a b : I32 = U32


-- SLICES
-- How are they compatible with no memory management?
-- A slice is an array whose memory belong to an other array.
fun sliceex1 x : U32[] = U32[]
  return x[1:]


struct Slice T : any = (Iterable T)
  p : .T
  len : Size
  orig : shared T[]

fun(T : any) takeslice a:T[] off:Size len:Size = r : (Slice T)
? off + len < a.len
  r.p = a.p
  r.off = off
  r.len = len
  return r

-- Here, memory sharing is implicit.
struct Slice T : any = (Iterable T)
  p : .T
  len : Size

fun(T : any) takeslice a:T[] off:Size len:Size = r : (Slice T)
? off + len < a.len
  r.p = a.p + off
  r.len = len
  return r


fun<T> takeslice a:T[] (off len):Size = r:(Slice T)


-- Loose or unique "by default" when escaping?
fun cannotfree x :loose !U32 = U32
  y :.U32 = x
  return y.[0]

fun canfree x :unique !U32 = U32
  y :.U32 = x
  -- There are no more references to x
  return y.[0]

fun escape_example = loose !U32
  r :(loose !U32) := malloc U32.size
  !r = 0
  return r

fun escape_error = !U32
  r := malloc U32.size
  !r = 0
  return r -- Error. Cannot escape scoped reference.

fun escape_shared = shared !U32
  r : shared _ := malloc U32.size  -- We don't want to repeat U32, classic case.
  !r = 0
  return r

fun multiple_implicit = Void
  a : _, b : shared _ := foobar 1 2
  a, b : shared _ := foobar 1 2  -- Equivalent.

fun free_early = Void
  r := malloc U32.size
  !r = 0
  r.free -- ? really?

fun catch_escaped = Void
  p :loose !U32 := escape_example
  q :unique !U32 := escape_example

-- Responsibility is transferred to the function, and it's completely fine to
-- return it as scoped.
fun takesuniq x :unique !U32 = !U32



-- Can we aVoid explicit derefencing entirely?
-- The pointer manipulations would be indirect?
-- No, but we don't support pointer arithmetic: everything happens via a slice.

fun U16be x:.U8 sz:!Size = U16
  BUGON sz < 2
  slice := Slice.mkraw x 0 2
  return (U16.zext slice[0]) << 1 | slice[1]

fun U16be x:.U8 sz:!Size = U16
  BUGON sz < 2
  slice := Slice.mkraw x 0 2
  return (U16.zext slice[0]) << 1 | slice[1]

fun U32le x:.8 sz:!Size = U16
  BUGON sz < 4
  slice := Slice.mkraw x 0 4
  U0 := U32.zext slice[0]
  U1 := U32.zext slice[1]
  U2 := U32.zext slice[2]
  U3 := U32.zext slice[3]
  return (U0 << 24) | (U1 << 16) | (U2 << 8) | U3

fun foo x:?!U32 y:U32 = Void
  if x != null
    !U32 = y

fun nth x:?!U32 idx:Size = U32
  if x == null
    return 0
  else
    return (Slice.mkraw x 0 Size.MAX)[idx]


-- Is [] a slice or an array? Should we really have standalone arrays? What for?
-- Shared slice?
-- Slice of shared memory?
fun<T> mkarray len:Size = []T
  raw := malloc<T>(len)
  slice := Slice.mk(raw, 0, len)
  return slice

fun<T> advance a:[]T = []T
  BUGON a.pos == a.len
  a.pos += 1
  return a

fun<T> advance_inplace a:[]T = Void
  BUGON a.pos == a.len
  a!pos += 1
  return a


-- []T, []!T, ![]T, .[]T, [].T
-- Can we accomodate all 3 cases?

struct Slice T : any =
  raw : !T
  pos len : Size

struct Slice T : any =
  raw : shared !T
  pos len : Size

struct Slice T : any =
  raw : .T
  pos len : Size

-- A simple solution is to pass T straight in, without any pointer marking.
struct Slice T : lang.Ref = 
  raw : T
  pos len : Size

-- But then []U32 means nothing. Only [].U32 and []!U32 make sense. In a sense,
-- it's not crazy: [].U32 *is* a range of (valid) U32 addresses.
-- [](shared .)U32, shared [].U32
--
-- I think I like this approach, even though it's regrettable to loose the []U32 syntax.


-- Why have raw and pos fields? Not just raw?
struct Slice T :lang.Ref =
  raw :T
  pos :Size

-- The advantage is with shared slices, where the sharing of the base pointers
-- is explicit, and we keep a reference to the base of the data.


struct Bitdb =
  parts []bitdb.Part

  method load pn:io.Path = err:Err
    return err
  method get p:!bitdb.Part name:.string = err:Err
    return err
  method get_byidcode p:!bitdb.Part idcode:U64 = err:Err
    return err
  method get_frombit_anyspeed p:!bitdb.Part name:.string = err:Err
    return err
  method getall_fordevice r:[]bitdb.Part device:.string = Void
    return


-- The reason we need macros in addition to templates is to mess with control
-- structures. Return more than one level, for instance. Or create our own for
-- loop.
-- Could we just support it in the language.
fun makro x:U32 = Err
  if x == 3
    fun.__caller__.return Err.INVAL

fun makro2 x:U32 = Void
  if x == 3
    fun.__caller__.break


struct Block Args :[]any = (Function Args [])
  

fun myfor x:U32 b:Block = Void


-- Introspection

struct Type =
  __codeloc__ :Codelocation
  __size__ :Size
  method<T :any> zext other :.T = This

struct Function =
  __codeloc__ :Codelocation
  __code__ :.U8
  __size__ :Size
  __args__ :[]Type
  __retargs__ :[]Type

struct Myfun = Function
  method __ctor__ = This
    __code__ = "\x23\x1\x0\x23"
    __size__ = 4
    __args__ = [U32]
    __retargs__ = [U32]

fun mkmyfun = Myfun
  f := Myfun.__ctor__ -- ??
  g : Myfun := _ -- ??
  return f

fun usefun x:U32 = U32
  return (mkmyfun) x


fun prevtolast x:[].U32 = U32
  match x
  | [] -> return 0
  | x::[] -> return 0
  | x::y::[] -> return x
  | _::tl -> return (prevtolast tl)

fun prevtolast x:[].U32 = U32
  match x
  | [] { return 0 }
  | x::[] { return 0 }
  | x::y::[] { return x }
  | _::tl { return (prevtolast tl) }



-- Sum types?
-- They really are great to enforce choice: i.e. parts of a structure are only
-- valid in one case.

struct Morecomplex =
  field :U32
  other :string

struct Oneof =
  | Try U32
  | Or U8
  | Maybe Morecomplex

fun getval x:Oneof = U32
  match x
  | Try v
    return U32.zext v
  | Or v
    return U32.zext v
  | Maybe mc
    return mc.field

fun onelineif = Void
  -- We could do the following, but that doesn't scale to multiple lines.
  -- So why would we?
  -- if x -> say 'Yeah!'
  if x { say 'Yeah!' }
  if (math.PI >> 2341) == 1 { say 'really?' }

fun inlineif = Void
  y := if b { if not b { 1 } else { 4 } } else 3


-- The last statement of a block can be bound?
-- Implies we must enforce struct constistency for all the "results" of a
-- block. Most expressions return Void in N. So that doesn't work:
fun blockresult = U32
  y :U32 := 0
  x = while true
    if y == 100
      13
    else
      y += 1
  return x



-- Conversions
struct Integer =
  fun<T :Integer> zext x:T = This  -- Zero extension
  fun<T :Integer> trunc x:T = This  -- Truncation
  fun<T :Signed Integer> reinterp x:T = This  -- Bitwise reintepret

struct U32 = Integer Unsigned
  fun zext x:U8 = This
  fun zext x:U16 = This
  fun trunc x:U64 = This
  fun reinterp x:I32 = This
  fun reinterp x:i64 = This


-- Escape analysis
-- It can become arbitrarilly difficult to follow the escape of a particular scoped pointer.
-- So we have to be conservative.
fun deep x:.U32 = vector<.U32>
  r : vector<.U32> = { x }
  return r
  ~ fun.mayescape x

fun top = .U32
  x : .U32 = null
  x = malloc<U32> 1
  return deep x
  ~ fun.mayescape x

-- Aside: should we have (fun.escapes x) and (fun.mayescape x)?

-- Here, do we know that deep escaped x?
-- Well, analysis on deep tells us that. And recursively so.
-- So we know that x has been escaped and may be included in the result of deep.
-- But we're not sure, so we can neither (i) free x, (ii) nor free x and rely
-- on the scope above to free it, as we're not sure it is, in fact, in deep's
-- result.

-- Difference between capture and escape? If we disallow global variables,
-- there is no such thing as capture. Or should we allow them but explicitly
-- tag functions that mess with them?

-- If we have a mayescape, then this cannot be a scoped pointer. It can be a
-- unique pointer (managed), or shared (managed), or loose (unmanaged).

-- All of these are valid:
fun deep x:unique .U32 = vector<unique .U32>
fun deep x:unique .U32 = vector<shared .U32>
fun deep x:shared .U32 = vector<shared .U32>
fun deep x:loose .U32 = vector<loose .U32>


-- Must unique be managed? Can static analysis handle them? I.e. decide which
-- code paths will need to free it or not? I don't think so, but static analysis
-- can tell us if a unique pointer can in fact be a scoped pointer, and therefore
-- let us optimize away the management. This is also true for shared pointers.

-- So should pointers be, say, shared by default relying on optimizations to
-- remove most of the overhead? I don't think so: we want to encourage sane and simple
-- memory allocation and passing strategy (top-down; no escape of reference). This will
-- have higher performance.

-- Memory pools and scoped pointers
-- Memory pools must be compatible with scoped pointers, because that's really
-- the point.  The question is, how do we aVoid freeing the pointers when a
-- pool was used? Is the idea that scoped pointers are always allocated from a
-- pool and are always freed in the same scope they were allocated? Escape
-- analysis would let us free scoped pointers earlier, when we know they're not
-- used further. But then we would to inline everythin or differentiate
-- according to the calling context, etc. Not very useful.
-- 
-- So the idea is: a scoped pointer is always allocated from an implicit pool,
-- so yeah, they're compatible.
--
-- Of course, the other, likely more frequent case of scoped is when the pointer
-- comes from a stack allocated variable.

fun bigscope = U32
  lg := scopedalloc<Largeobject> 1
  ? lg.__type__ == !Largeobject
  init lg
  return lg.someval

-- That means that to escape a scoped pointer, we have to copy it. But that's a
-- bit painful mostly because copy may not be well-defined. Could we somehow
-- aVoid that? Like hold the pool for longer? I.e. unique would contain a reference
-- to the pool and that is what is freed?
type<T :Freeable> unique =
  p :!T
  f :!Freeable  -- f may be different from p

fun foo p:unique !U32 = Void
  !p = 42

fun bar = U32
  x :U32 := 0
  foo .x  -- .x is scoped
  return x

-- The point of scoped: make sure that we don't do anything "illegal" with that
-- pointer, meaning, make sure we don't escape it.

-- Shared is a managed pointer that can escape. Assuming scoped is consistent,
-- the challenge is to convert from scoped to shared. If scoped don't always
-- come from a pool (e.g. because we know it may escape, therefore allocate it
-- by itself), then we should be able to wrap it in a shared pointer without
-- having to do anything.

fun foo p:.U32 = U32
  return p.

fun callfoo p:shared .U32 = U32
  return foo p  -- That's legal.

fun choose x :U32 \
	   a b c :.U32 = .U32
  match x
  | 0 { return a }
  | 1 { return b }
  | _ { return c }
  ~ fun.mayescape a b c

-- So callchoose "works", but it's hard to see how it would be legal.
fun callchoose a b c :shared .U32 = U32
  return (choose 123 a b c).  -- How is that legal?


-- Shared unwrapping and threading
--
-- So, the idea is that a shared pointer can be unwrapped whenwe know:
-- - the pointer will not escape the scope,
-- - there is a single thread of execution.
-- Functions that affect threading needs to be marked as such. But then
-- threads can only accept shared pointers. Even though scoped pointer
-- could be just fine. For that, we need to track thread contexts.

struct Thread =
  method join = Err
  ~ fun.thread.end

fun startthread p:!U32 = Thread
  ~ fun.thread.start

fun main = int
  x := scopedalloc<U32> 128
  t := startthread x
  -- ...
  t.join
  -- Therefore this is safe
  return 0

fun altmain = int
  x := scopedmalloc<U32> 128
  t := Thread.mk
  t.start x
  -- ...
  return 0
  -- t is destroyed before x is, so safe again.

-- In other words, we want to track if thread contexts "escape" as well.
-- Thread contexts are not passed explictly to a function (WHY NOT?), but
-- we could still track them it via annotations.
-- 
-- This is akin to escaping a pointer not by return but by capture by an object.

fun bgwork list :[].U32 = Void
  t := Mythread.mkref
  ? t.__type__ == !Mythread
  t.start U32
  ~ t := fun.thread.start
  ~ t.captures list
  ~ fun.escapes t

fun maystartathread x :U32 = U32
  y := U32.mk 0
  z := x + y + 3
  if z == 3
    list := {x y z}
    ? list.__type__ == [].U32
    bgwork list

-- Maybe then thread objects should be explicit! Then we would not need a
-- special mechanism for it. The reference tracking would be entirely
-- explicit.


-- I'm not entirely sure what unique is.
--
-- The point of unique, I think, is to have a "looser" pointer that can be
-- converted to a scoped pointer or shared pointer safely. A loose pointer
-- can only be converted by fiat. Unique in C++ is a cheaper shared pointer.
-- We would like to aVoid management in N. And unique can fail at runtime in
-- C++, (right?), we certainly don't want that.

-- I'm not sure we need unique in N.
-- Well, let's look at the case where shared kind of breaks down. A large global
-- dynamic collection of long-lived pointers, that are unique, shared among threads,
-- but that will not disappear before the collection object itself.
--
-- Why don't we use scoped then? These objects live in the scope of the collection.
--
-- Let's assume that we can't use scoped because the objects come from a different
-- source and escaped back up. Anyway, once stored in the collection, then they could
-- become scoped pointer (to the scope of the collection). But in the chain leading
-- there, they need to be either unique or shared. And in that chain, shared would
-- really not be that expensive...
--
-- Still, let's say we cannot do shared in that chain either.
--
-- Doing unique means that we need move semantics, right?
fun amove x:!U32 = r:!U32
  r <- x
  return r

fun amove x:!unique U32 = r:!unique U32
  r <- x
  return r

-- Do we really want that?


-- Escape, capture and scope of methods
--
struct Object =
  p :!U32
  method __ctor__ = Object
    this.__memclear__

  method capture x:!U32 = Void
    this.p = x
  -- ~ fun.captures x
  -- This is really captured by the Object instance.
    ~ this.captures x

fun context = U32
  o :Object = {}
  v :U32 = 124
  o!capture !v
  return o.capture.

-- More generally, escape is not always via return values.
fun argcapture o:!Object x:!U32 = Void
  o!p = x
  ~ o.captures x

-- .nh Header generation: so we should generate text headers, or generate binary
-- "headers" that would be faster to read and parse? You could display them
-- in text form, but why generate them?


-- Initializers
--
fun alist = [].U32
  return {(U32 0) (U32 1) (U32 2)} -- struct constraining is a bitch

-- Just as numerical literals can be constrained to any numerical types,
-- compound of literals can be constrained to any numerical compound types.
-- I mean, it can be attempted...
fun alist2 = [].U32
  return {0 1 2}

struct U32 = Primitive Integer Unsigned
  __size__ :const bootstrap.Size = 4

  method __ctor_literal_integer__ x:.lang.literal.Integer = Err
    if x.negative
      return Err.INVAL
    if x.bitwidth > 32
      return Err.INVAL
    x.copybytes_hostorder(!this)
    

fun alist2 a b c :U32 = [].U32
  return {a b c}

struct A =
  a b c :U32

fun astruct x y z :U32 = A
  return {a=x b=z c=y}

struct Tree T : any =
  | NODE -> ?.Tree
  | LEAF -> T

  method getfirstleaf = T
  method size = Size
  method leafcount = Size


-- We want to be able to choose the struct of the tag (in particular for enums).
-- As well as the numerical value.
struct Tree T :any =
  | NODE = 1 :U32 -> ?.Tree, ?.Tree
  | LEAF T = NODE+1 -> T

(fun T) treesum t:(Tree T) = U32
  n :U32 := 0
  if t.__tag__ == Tree.NODE
    left, right := t.__as__.NODE
    if left != null
      n += treesum .left
    if right != null
      n += treesum .right
  elif t.__tag__ == Tree.LEAF
    return t.__as__.LEAF
  else
    UNREACHED

(fun T) treesum t:(Tree T) = U32
  match t
  | NODE left, right ->
    l := if left != null { treesum left } else { 0 }
    r := if right != null { treesum right } else { 0 }
    return l + r
  | LEAF val ->
    return val


-- Should or should we not initialize everything to 0?
-- The default constructor is always this.__memclear__

fun declnotdef = U32
  x :U32
  return x  -- Error! Not initialized.


-- Typedef
struct Othername = Name


-- Scope allocated containers
fun top = Void
  v :(Vector U32)
  for i in range 10
    append(!v, i)

fun append v:!(Vector U32) x:U32 = Void
  v!push x

-- There are 2 ways to handle the memory allocated inside the container:
-- either use malloc, and have it own it and destroy it on exit, or use
-- the scope allocator in which v leaves. That really works for append only,
-- as we wouldn't be able to free the memory. So Vector should work as in
-- the STL, but ScopedVector could re-use the ScopeAllocator that
-- allocated it. We would have to ensure that ScopedVector is always a scoped
-- pointer. Is it really all worth it?
--
-- I.e. Should scope allocation be so deeply part of the language to be
-- exposed in such a way? Well, yeah, ideally. That would make it possible to
-- have a lot of things behave in a transparent manner.
--
struct ScopedVector T = (Iterable T) (Vector T).__intf__
  (fun T) _alloc sz:Size = []!T
    alloc := ScopeAllocator.for(this)
    return (alloc T) sz

-- A struct doesn't inherit, but it can do 2 things: implement an interface,
-- import a type.

struct A =
  x y :U32
  method total = U32
    return x + y

struct B = A.__intf__
  from A import *

struct C = A.__funintf__
  from A import *

struct D = A.__funintf__.dyn  -- dynamic interface?
  method total = U32
    return 0


-- Note on slices, array and function call operators
-- []!U32, [].I32, v.[1], v[123], (foo 1 3), (foo. 1 4) are all valid expressions.
-- We need to choose for slice access:
--  v := [].I32 = {1 2 4}
--  say v.[0]  -- This should mean v->operator[](0), really.
--  say v[0].  -- I think this second makes more sense! *(v[0])


-- Should _x be protected and __x be private?
-- Particularly handy for modules: Sub-modules would implicitly get access to
-- _items, but not to __items. But it does make implementations much heavier,
-- with things like this.__x = this.__y + this.__z or (this.__update 13) all
-- over the place.
--
-- In that spirit, the current module has protected access to types defined
-- therein.
struct A =
  _x :U32
  __y :U32
  method update = Void
    this!_x += 1
    this!__y += this._x

fun getprotected a:.A = U32
  return a._x

-- Instead of this, we could use a sigil, like in Ruby.
-- Too bad they have to be uppercase. That's the single biggest hurdle
-- to me adopting that solution.
-- What about the lack of symmetry with module members access? There is
-- shadowing and you don't need explicit scope. Maybe because in practice
-- you very rarely have problems with that?

-- Default constructor from literal
--   t :T := { this!_x = 123 }
--   t :T := { !_x = 123 }
--   t :T := { _x = 123 }
-- (Which one? The last one makes more sense wrt. dict/map use)
-- is allowed by default. It can be prevented with:
struct T =
  __ctor_literal__ = __memclear__


-- Tuples and multiple return values are different. But the same syntax
-- can be used for deconstruction. We just need a syntax for tail.
fun destruct = Void
  a, b = return_couple
  c, d = return_2_values
  -- x, y = return_length_2_slice
  -- Illegal! Because could fail at runtime: use exhaustive pattern
  -- matching.
  match return_length_2_slice
  | e, f -> say e; say f
  | _ -> UNREACHED
  match return_vector
  | e, f :: tail -> say e; say f
  | _ -> fallthrough


-- Pattern matching multiple case
fun multiplematch x:U32 = Void
  match x
  | 1 | 2 -> say 'small'
  | 3 | 4 | 5 \
      | 6 | 7 -> say 'medium'
  | _ -> say 'large'


fun usemap v:[].U32 = U32
  map v (lambda x:U32 = U32
	   return x + 1)
  tot :U32 := 0
  for x in v
    tot += x
  return tot

-- We really need multiple arguments, as demonstrated by this example:
-- 
-- def pimport(m):
--   return _ptree(m,
--       Repeat0(Oneof(
--         Seq('import', Repeat(pident)),
--         Seq('from', pident, 'import', '*'),
--         Seq('from', pident, 'import', pidents))))

-- Type declaration: order of declaration
struct T =
  -- Fields come first, either in record, taggedunion or enum fashion.
  -- (only one mode is allowed).
  -- Followed by method definitions.

-- Should we differentiate between method and fun? Method would implicitly take
-- the struct or the module (!) as first/this argument. That would be the only way
-- to access global variables defined at the module scope. It would then make
-- more sense to import a module in the scope of a type.
-- DEAL.

-- Then, typedef cannot be
struct B = A  -- that would be an isa statement.
-- Typedef must be
struct B =
  from A import *
struct B = { from A import * }

-- Replace constrained declaration syntax?
fun foo = Void
  x :U32 := 0
  x := 0 :U32
-- Do not replace, allow both, as (0 :U32) is useful in expressions as well.
-- It's not a cast, it's a constraint. I.e. if the expression has a type, check
-- it's the one constrained with, if it's a type-free literal, try to convert
-- it.


-- Scope allocation
struct A =
  p :!U32

fun foo a:!A = Void
  local := a!__scope__!alloc U32  -- That's a template instantiation and call.
  a!p = local

fun top = Void
  x := {} :A
  foo !x


-- Allow taking references of temporaries.
-- 
-- We ABSOLUTELY need vararg. And we want to pass complex objects,
-- at least by ref, with a simple syntax:
--   varargfun a fun .(Complex.mk)
--
-- Take a reference of the temporary, needs to live longer than
-- the passing of the arguments (or the address would become stale).
-- So we would expand:
--   foobar .(Object.mk)
-- into:
--   tmp := Object.mk
--   foobar .tmp
--
-- Of course, passing such temporaries by copy is acceptable as
-- well.


-- Pretty printing of everything.
from io.stdout import *
fun pprintex = Void
  say var.__prettystr__
  psay var
  print v.__prettystr__
  pprint v


-- Only one default __ctor__? This rule is not set in stone.
-- The notation (A x y) is definitely very useful, and quite familiar.
-- The uppercase makes it clear it's a type.
-- Having to always write (A.mk x y) is a pain, probably.
-- And having to define it too.
-- The ability to return errors when it cannot be constructed means
-- we don't have the ctor/init() dilemna.
struct A =
   fun __ctor__ x y :u32 = This, Err
     if x == y
	return Err.INVAL
     else
	return { 0 0 }  -- That's calling __ctorliteral__

-- In any case, we need a way to separate allocation from initialization.
-- It doesn't really make sense to conflate the two.
-- The only reason they usually are, is that an unitializaed object
-- should not be used (except maybe it passing around as a ready-to-be-used
-- memory location). And C++ has no generic way to track that you will
-- initialize it before use. How do we do it?


-- Named/optional arguments?
-- Support with the Python syntax and semantics?
-- Default value by copy from static instance (we don't have the opt=[]
-- problem). Can use keyword passing on any function if wanted.
-- In order arguments come first. Followed by optional.
-- Implemented using va_start et al. But made struct safe, and
-- variable argument list is prefixed by the number of arguments
-- actually passed.
fun vararg *args:U32 = Void

-- This doesn't allow us to implement printf. Shite.
-- We need variable template arguments as well.
(fun T:Showable ...) printf fmt:String *args:T = I32


-- Should we allow introducing free-form blocks?
-- Behave like C {} but can have a return value.
-- We would also like to pass them in.
fun foobar = Void
  x := 0 :U32
  b := block
    x += 1
    x
  myif true b
-- I like this. It's a very clear way to illustrate how b is computed.
-- No need to see if b could depend on other things.

(fun B:(Block T)) myif x:Bool b:.B = T
  if x
    b.

-- A block is a special lambda that captures all the variables from outer
-- scopes via implicit references. Updates can be delayed to the end of
-- the block.


-- Should we have escape analysis decide where are pointers allocated?
-- Escape analysis would let us convert scoped into unique.
-- If a pointer may escape, we allocate it on its own. And it become
-- a unique or shared pointer? Would this be transparent?
-- The fundamental problem shows when we have circular ownership chains.


-- Haskell's $ operator
fun haskelldollar = I32
  foo $ bar 3
  b := block $ foo x
  f := future $ slowtask y
  if f.wait $ return -1


-- Default copy operator
-- A shared pointer can be copied trivially.
-- A unique pointer cannot be copied, but can be moved, to another unique
-- pointer, a shared pointer, or a scoped pointer.
-- Copying a scoped pointer could mean widening its scope. A scoped pointer
-- with a widened scope would behave exactly the same for the code in the
-- original scope. We could accept a widening of the scope, but in general
-- we don't. Just to make it obvious when it happens (as it as performance
-- implications: we want to lifetime of a scoped pointer to be statically
-- obvious). So to copy a scoped pointer into a wider scope, you really need to
-- copy the data and then use that unique pointer to assign it to a scoped
-- pointer with with a wider scope.
-- Copying a scoped pointer to another in the same scope (or a narrower scope)
-- is just fine, and in fact the expected thing to do.

struct T =
  -- Returns a copy of the object, must be a "safe" copy, i.e. deep-copy.
  method __deepcopy__ = unique !T

-- Deep copy of shared is copy. Deep copy of unique is copy. Deep copy of scoped
-- is recursive deep-copy. Well-defined, but there is the problem of
-- the risk of infinite recursion.
--
-- Should the user have to undefine __deepcopy__ when not valid? Really?
-- Probably the other way around: the user can request the default deepcopy.

struct T =
  __deepcopy__ == This.__defaultdeepcopy -- This one was private.
  -- Could do full-code analysis to figure out if it's dangerous to use
  -- __deepcopy__. What would be nice is to let __deepcopy__ be used by
  -- default, unless the analysis says it could be dangerous and then
  -- ask the user to define it if they know what they're doing. With a
  -- default available because we should make them do it.

-- Should special names respect the naming convention? __deepcopy__ is meant
-- to be publicly exposed. So, why not call it deepcopy__.


-- Paralell for: pfor, future
-- What can we do to enforce correctness? I.e. avoid unsafe sharing
-- between threads, etc. Limit exposure? For instance, the body of
-- a parallel for can only see variables in the scope read-only?
fun foo = U32
  x := 0 :U32
  f := future
    a := 0 :U32
    for v in range 0 10
      a *= 31
    with thisthread.parent!lock
      x += a
    a - x
  g := morework
  return f.get + g

fun foo = U32
  x := 0 :U32
  f := block
    promise := (Promise U32)
    aux := plambda ->
      a := 0 :U32
      for v in range 0 10
        a *= 31
      with thisthread.parent!lock
        x += a
      promise!put (a - x)
    async aux
    return Future promise
  g := morework
  return f.get + g

-- Lock labelling needs to differentiate between recursive and non-recurise locks.
-- The typical example, is the Linux kernel practice of having foo() that takes the
-- locks and calls __foo(). Other internal code may want to call __foo() directly if
-- they also happen to own the appropriate locks. This is good for performance
-- and correctness.
-- Are there cases where not grabbing a lock recursively (instead trying not to,
-- because we statically know we don't need to) would be a problem?

struct Promise T =
  _val :T
  _ready :Bool
  _lock :Mutex -- Let Mutex be modified, internal mutables.

  method! put x:T =
    ~ thisfun.takes .this._lock
    with this._lock
      this!_val = x

struct Future T =
  p :(Promise T)

  method get = T
    return p._get

  method tryget = T, Bool
    with p._lock
      return p._val, p._ready


-- Where standard classes are defined.
-- Define them in the n module. Import it by default (?).
-- Allow disabling when needed. Or not import by default?
unimport n
from n import *


-- Type field access control
-- Should we have readonly and writeonly? Or just readonly? Default is readwrite?
-- The idea is: if you expose it, you probably want to let them access it.
-- Does it really make sense?
-- Never apply to current module? I.e. if current module has visibility, then it has
-- full access.
struct T =
  x :readonly U32

-- Generates .nh
struct T =
  method x = U32

-- Should we allow the definition of setters?
struct T =
  x :U32


-- Are function return types n-uplet? And there is a comma. Is there?
-- There is. All the arguments against using a n-uplet are only valid
-- when there is GC: should the multiple return values be boxed or not? ...
-- But in our case, we may as well use n-uplet.
-- 
-- For function arguments, we do not use n-uplets because they don't
-- make sense: (i) from an ABI perspective; (ii) because if
-- fun foo (a :U32, b :U32) = U32 ie. arguments are a couple, we wouldn't
-- call foo (returncouple 13) anyway as that would be confusing as hell.
--
-- For function arguments, however, we may reintroduce the comma, which
-- would be nice as we wouldn't have to parenthesize generic types.
-- Although the parenthesizing make them stand out. But then we don't
-- force it in variable declarations in general. So that's kinda weak.
fun foo a:U32, b:U64, c:String = I32, Err

-- Then should be drop the ':' if we have the comma? Go-like?
fun foo v:Vector T, w:Vector T, b:U64 = Void
fun foo v w Vector T, b U64 = Void
fun foo v, w Vector T, b U64 = Void
fun foo v Vector T, w Vector T, b U64 = Void

-- Then always allow extra comma at the end of a list.

-- I don't think I want to go there. Keep the comma for actual n-uplet.
-- That's how they're introduced, make the grammar very unambiguous about
-- that point.


-- Overwriting a unique pointer frees it.


-- Linking: naming symbols.
-- An import doesn't change the naming for a symbol, it only creates an alias.
-- An alias that is not exported to the object file. It's only internal.
-- The only emitted symbol is the full path to the definition.



-- Constructors
-- Literal or default constructors, Type{} are module-private by default. Can be
-- exported with:
-- struct Type =
--   let Ctor = ctor
--   let Ctorliteral = ctorliteral
--
-- Note, Dtor always visible, right?
--
-- The rational is that default operations may not make a lot of sense, and
-- we shouldn't export it in general. Copy constructors are different, we
-- only define them when they are to make sense in the general sense.
--
-- In general, a constructor must be defined, with a name:
-- struct Vector T =
--   fun Mk len:Size ?init:?.T = This
--     return This{ ... }
--
--   fun Dtor = Void
--     free this!data
--
--   fun Ctor = This
--     return This{}

-- This is consistent with sum types Sum.NAME: NAME is a fun in Sum
-- that returns a Sum.
--
-- struct Sum =
--   | FIRST
--   | SECOND -> U32, I32
--
-- Is somewhat equivalent to:
--
-- struct Sum =
--   union __union =
--     | SECOND -> U32, I32
--
--   Which :U32
--   __unsafe_as__ :__union
--
--   fun FIRST = This
--     return Sum{Which=0}
--   fun SECOND x:(U32, I32) = This
--     let r = Sum{Which=1}
--       r.__unsafe_as!SECOND = x

-- Default constructor is defineda as this.__memclear__. Or call the non-default
-- constructors of fields.

-- Copy constructors are defined by default when they are safe. I.e. not when we
-- have loose pointers. Only scoped, unique or shared. Shallow copy.
-- Deep copy is a different can of worms. We could have deep copy automatically
-- defined whenever the definition does not allow any risk of inifinite loop
-- (only contains references on different types of data, or no references at all).


-- Unary calls

fun foo = .U32

fun bar = Void
  let x = foo.
  -- Must be valid, as we want the same syntax as:
  let xx = valueptr.

  let y = (foo).
  -- Indentical but unnecessary.

  let refreturntmp = &foo -- call then reference.
  let funref = &~foo -- ?? Need special syntax.
  let a = (funref.) -- Call: parenthesis needed in that case?
  -- Funref not supported yet.


-- Virtual destructors?
-- If using dynintf, what smart things could we do with destructors? For scoped,
-- the allocation spot knows about the actual type. So the object itself doesn't
-- need to contain a reference to the dtor.  When using unique: the unique
-- container could know about the destructor. That could be one of the things
-- you return with a unique pointer. Same idea with shared.

struct unique T:AnyRef =
  dtor :.Dtor
  p :T

-- So the overhead from unique would be there only some of the time.

-- Should we use a similar idea with dynintf? Like in go? I.e. the dynintf is
-- actually a wrapper around the bare object, which can only be used directly.
-- The idea is to make the C++ optimization explicit: when the full struct is
-- known statically, and by value, we can call the actual methods directly.
-- In all the other cases, we have to call the virtual methods.
--
-- In N, we could get the optimization all the time, wherever the direct type
-- is used (reference or not). When wanting to use an interface, we have to
-- reference the object via its interface. I.e. if B isa A, B implements
-- DynIntf.

fun usesdyn x:SomeDynIntf = U32
  return x.barfoo 12 -- barfoo is called dynamically, even by copy.

fun usesdyn2 x:B.Dynintf__ = U32
  return x.barfoo 12 -- barfoo is called dynamically.

fun usesdyn2 x:.B = U32
  return x.barfoo 12 -- barfoo is called statically.

-- In other words, calling dynamically is a feature of the struct system,
-- but doesn't depend on how the object is passed (value or ref)...

-- An dynintf object needs to be created from the concrete object.
-- Is this implicit? Or is this explicit? I think I want it to be explicit.
intf B =
intf C =
dynintf D =
  method Get = U32
struct A = B C D

fun foo d:D = U32
  return d.Get

fun bar a:A = U32
  return foo a
fun bar a:A = U32
  return foo (a.As D)
fun bar a:A = U32
  return foo ((dynintf D) a)

-- We may want explicit to make sure the memory relationship is clear.
-- A dynintf object may contain, in addition to the virtual table,
-- a copy of the original object, or a reference to it.

fun bar a:A = U32
  return foo $ D a

fun bar a:A = U32
  return foo $ D &a -- Error if D contains a method!
fun bar a:A = U32
  return foo $ D &!a

-- The above is a special built-in constructor? Not very analog to regular types.

-- OR, dynintf objects always wrap around a reference, and are generally themselves
-- passed around by copy. They are primitive objects because they contain a special
-- "polymorph" and opaque reference toward an object of unknown type.

fun bar a:A = U32
  return foo (D &a) -- Error if D contains a method!
fun bar a:A = U32
  return foo (D &!a)
  return foo (D{ vptr=a.Type__.Isa.D.Virtualtable p=&!a })


-- Should it be possible to call methods directly on objects? Like in python?
-- As regular functions? 'Class.method otherobj'


-- Construction syntax:
-- Automatically defined and exported.
-- Equivalent to module private forms, which are modprivate because they could break
-- the semantics of the object if used wildly on their own (Type{} and Type.alloc).
--
--   Type.New args  ===  Type.alloc.Ctor args
--   Type.Mk args  ===  Type{}.Ctor args
--

-- Ctor has always only one form. May take arguments. If there are several ways
-- to build an object, then you must use a static fun, with a protected ctor.


-- Generic types: free struct variables
(type T) ContainerIterator C:(Container T) = (Iterator C.T)

-- Are equivalent:
struct Vector T =
struct Vector T:Any =
(type T) Vector S:T =
(type T:Any) Vector S:T =

-- If a struct argument is on the left of ':', then it doesn't get to be in the
-- generic argument list (type A B ...), as it is "bound" (kind of) by whatever is
-- on the right.

-- Are equivalent
(type T C:(Container T)) Foo A:(Container C) = (ContainerSquared T)
(type T C:(Container T)) Foo A:(Container C) = (ContainerSquared C.T)
(type T) Foo A:(Container (Container T)) = (ContainerSquared T)


-- Semantic labelling

intf Container T =
  method Len = Size
  method Capacity = Size
  method! Clear = Void
    #~ self.Structchange
  method! Reserve len:Size = Void
    #~ self.Structchange
  method All = (ElementIterator T)
    #! retval.Prevents self.Structchange

  #~ prop Nonempty
  #~ prop Structchange

-- What about aliasing?
(fun C:(Container U32)) foo a:!C b:!(Vector U32) = U32
  for x in a.All
    for y in Range 0 x
      b.[y] = x

fun main = U32
  let x:U32
      a = (Vector U32).Mk.Init 0 100
    let b = &!a
    if noalias &!a b
      x = foo &!a b
    else
      abort 'Unexpected aliasing'
  return x

-- In general, we cannot ensure there is no aliasing statically. So we would have to
-- check for aliasing all the time. But we could say: function calls always
-- assume no-aliasing, like in C99 (strict). I.e. __restrict__ is assumed, always.
-- N's strict struct systen makes this a lot more predictable. Also, the only case of
-- aliasing, unless unsafe_ operations are used, is reference equaility. This helps.

-- As in the case of foo above, the check is done on the concrete form of generics.

-- In many practical cases, it's easy to check that two variables are not aliased,
-- if only because of the surrounding functional context. So we require a proof all
-- the time, proof that generally come easily. When it doesn't, we ask the user to
-- check.

-- A major source of aliasing being introduced is with return values of functions.
-- If we assume that function calls do not alias their arguments of same type, this
-- is fine, until we call a function that may modify (a) its argument, (b) return
-- one of its reference arguments and the result is assigned to another reference.

fun select a:!T b:!T which:Bool = !T

fun foo a:!T b:!T = Void
  -- a and b are not aliased.
  let c = select a b random.randbool
  -- c is an alias of either a or b.

-- Do we need to consider that return values are also part of the function arguments
-- wrt aliasing? I.e. rewrite 'fun select a:!T b:!T which:bool = !T' into
-- 'fun select retval:!!T a:!T b:!T which:bool = Void'. Not helping.

-- So we cannot have rules that make it easy to prove, transitively, that there is
-- no aliasing?

-- Wait: we do not support computations on addresses themselves, so aliasing can
-- only happen when returning a reference unaltered.

struct stores_refs =
  table :[]!T
  method! add p:!T =
    self.table!Push p
  nethod getrand = !T
    return table.[random.randu32 &self.table.Len]


-- Do we really need to always blow function calls open to make sure that semantics
-- are respected at all call sites? Or can we preserve the function boundary
-- abstraction?


-- As semantics information gets automatically checked, when 'type A = I', we
-- can just "inherit" the semantic constraints from I, without asking for them
-- to be repeated in A.
-- We should require that in A, the semantics cannot be different that in I.
-- You cannot add more restrictions for instance. 'A isa I' is a strong
-- statement. It means: everything I has, A has too, in the exact same way.


-- Invalidating iterators.
-- 1. It's possible to write a Vector class that doesn't invalidate its iterators.
-- 2. There are fundamental differences between making changes on a list and
-- making structural changes on a vector.
-- Therefore:
-- We shouldn't pretend they can all behave in exactly the same way, albeit at
-- a performance cost. The intf hierarchy should reflect these differences.
-- The GCD should be kept small, so that we don't make Vector unecessarily complex.
-- You cannot remove an element in the middle of a Vector -- you just can't,
-- sorry. It really makes no sense to make it work.


-- Constness
struct Slice T =
  data :!U8

fun uses_ptr p:!U8 = Void

fun main = Void
  -- Which call is valid?
  uses_ptr self.data
  uses_ptr self!data
  -- I'd like it to be the second one, but I'm not sure how to make sense of it.

-- Any mutable reference in a structure is seen as read-only unless mutating
-- deref is used.
-- But:

  self.sub!Alter
  self!sub!Alter


struct T =
  slice :[]U8

  fun alloc ?allocator:Allocator = unique !this
    -- How do we pass it in recursively?

  method! Ctor ?heap_allocator:Allocator = this
    -- In that scenario every single Ctor that must support this feature would
    -- need to have this optional argument. A pain.

  -- Use context and __thread__ local variables?
  -- Platforms that do not support TLS cannot use custom allocators or
  -- multithreading. Big deal?
  let f:!(Slice U8)
    with nlang.alloc.Custom myalloc
      f = f.Type__.New
      f!Init 100 &0


-- Weird: if x:!U8: x.Type__ is U8. Do we need (typeof x) that would be !U8?
-- Do we want the ability to represent that? Probably. Being able to get the
-- actual struct whether there is a reference or not would be a good thing.


-- ObjC has this surprisingly nice feature that nil references to not lead to a
-- crash: nil deref simply behave like noop operations. This is convenient,
-- from a certain point of view. Of course, in certain situations that's a
-- nightmare.


-- Use proxy objects, kinda like in new Javascript.
-- Instead of well-known methods, with reserved names, use a separate object.
(type T C) ArrayProxy C:(RandomContainer T) =
  fun Get obj:.C idx:Size = T
  fun Set obj:!C idx:Size x:T = Void

(type T) Vector T = (nlang.containers.RandomContainer T)

(type T) nlang.containers.ArrayProxy C:(Vector T) =
  fun Get obj:.C idx:Size = T
  fun Set obj:!C idx:Size x:T = Void

-- In code, the expression v.[0] will use (ArrayProxy v.Type__).Get v 0

-- Variant:
(type T) nlang.containers.ArrayProxy C:(Vector T) =
  obj :!C

  method Ctor obj:!C = Void
    self!obj = obj
  method Get idx:Size = T
  method! Set idx:Size x:T = Void

-- v.[0] will use ((ArrayProxy v.Type__) v).Get 0
-- Not sure what the point would be. We would risk adding state. Not the point.


-- We have so far accepted:
struct Vector T = (RandomContainer T)
-- where T is a free variable. That leads to problems when considering a syntax
-- for explicit specializations. Maybe we should require this instead:
(type T) Vector T = (RandomContainer T)

(type T=U32) Vector U32 = (RandomContainer U32)
-- ??? Shit. We have to write everything by hand. And handle compatiblity rules.
-- Should we really allow specializations? Hmm. Or are they against the principles
-- we want? I.e. predictability. Cases like vector<bool> are not actually interesting.
-- We might as well have BitVector if that's the question.
-- But for proxies?

(type T C) VectorArrayProxy C:(Vector T) = (ArrayProxy C)
  fun Get obj:.C idx:Size = T
  fun Set obj:!C idx:Size x:T = Void

-- The compiler looks for a struct that isa (ArrayProxy (Vector U32))? What if there
-- are several?
