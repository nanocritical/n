from nlang import *
type u = `trivial_ctor
  tag_type = nlang.builtins.u32
  final = t03.constraints.u
  this = t03.constraints.u
  | A = 0
  | B = 0 + 1
    x:i32
  | C = 0 + 1 + 1
    x:u32

fun aux e:u = _nretval:i32 
  match block 
  e;;
  | B
    -- phi 1

    noop
    noop
    return e.B.x
  | _
    _Ngensym2 = 1
    return _Ngensym2
  -- phi 2


fun set1 e:@!u = _nretval:void 
  match block 
  _Ngensym3 = .e
  _Ngensym3;;
  | B
    -- phi 1

    noop
    noop
    _Ngensym6 = 1
    e!B.x = _Ngensym6
  | _
    noop
  -- phi 2


export fun main = _nretval:i32 
  block
    noop
    g = { }
  match block 
  g;;
  | B
    _Ngensym7 = 1
    return _Ngensym7
  | C
    _Ngensym8 = 1
    return _Ngensym8
  | _
    noop
  noop
  f = { }
  noop
  noop
  _Ngensym1b = null
  _Ngensym1c = @f.B.x
  _Ngensym21 = _Ngensym1c
  say sep=_Ngensym1b _Ngensym21
  _Ngensymb = @!f
  set1 _Ngensymb
  noop
  noop
  _Ngensym1d = null
  _Ngensym1e = @f.B.x
  _Ngensym22 = _Ngensym1e
  say sep=_Ngensym1d _Ngensym22
  noop
  _Ngensyme = 1
  e = { x=_Ngensyme }
  match block 
  e;;
  | B
    -- phi 1

    noop
    noop
    _Ngensym11 = 0
    _Ngensym12 = e.B.x == _Ngensym11
    noop
    assert _Ngensym12
  -- phi 2

  _Ngensym14 = aux e
  return _Ngensym14
