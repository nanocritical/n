from nlang.prelude import *
from nlang.containers import *

intf slice_allocator =
  (method! t) slice_alloc s:@![]t len:size = void
  (method! t) slice_free s:@![]t = void
  (method! t) slice_resize s:@![]t len:size = void
  (method! t) slice_copy dst:@![]t src:@[]t = void


(fun r:(nlang.meta.any_ref u8)) _unsafe_slice_addr data:r elsize:size n:size = r

type slice t:plain_old_data = (random_container t)
  _rawdata:?@!u8
  _len:size

  method# random_container.clear = void
    self#_len = 0
    self#_rawdata = null

  method# init_rawdata data:@!u8 len:size = void
    self#_rawdata = data
    self#_len = len

  method unsafe_rawdata = ?@u8
    return self._rawdata

  method! unsafe_mutable_rawdata = ?@!u8
    return self!_rawdata

  method random_container.len = size
    return self._len

  method data = ?@t
    return (nlang.unsafe.cast ?@t ?@u8) self._rawdata

  method! mutable_data = ?@!t
    return (nlang.unsafe.cast ?@!t ?@!u8) self!_rawdata

  method random_container.check_locus n:size = bool
    #~ eval self.check_locus self.valid_locus n
    return n < self._len


  method random_container.all = index_range
    let r:index_range
      r#init 0 self.len
    return r

  method random_container.first = size
    return 0

  method random_container.last = size
    return self.len - 1

  method random_container.at n:size = @t
    let psrc = _unsafe_slice_addr (nlang.unsafe.nonnull_cast self.unsafe_rawdata) (sizeof t) n
    return (nlang.unsafe.cast @t @u8) psrc

  method! random_container.hg_at n:size = @#t
    let psrc = _unsafe_slice_addr (nlang.unsafe.nonnull_cast self.unsafe_rawdata) (sizeof t) n
    return (nlang.unsafe.cast @#t @u8) psrc

  method random_container.operator_get__ n:size = t
    #! self.valid_locus n
    #? self.check_locus n
    let r:t
      let pdst = (nlang.unsafe.cast @!u8 @!t) @!r
      let psrc = _unsafe_slice_addr (nlang.unsafe.nonnull_cast self.unsafe_rawdata) (sizeof t) n
      nlang.unsafe.memcpy pdst psrc (sizeof t) 1
    return r

  method! random_container.operator_set__ n:size x:t = void
    #! self.valid_locus n
    #? self.check_locus n
    let pdst = _unsafe_slice_addr (nlang.unsafe.nonnull_cast self.unsafe_mutable_rawdata) (sizeof t) n
    let psrc = (nlang.unsafe.cast @u8 @t) @x
    nlang.unsafe.memcpy pdst psrc (sizeof t) 1


type sized_slice t:plain_old_data LEN:size = (random_container t)
  -- The data is allocated by the compiler (e.g. in generated C code) and
  -- it must be first in the type's memory layout so that its address
  -- coincides with self.

  method unsafe_rawdata = @u8
    return (nlang.unsafe.cast @u8 @this) self

  method! unsafe_mutable_rawdata = @!u8
    return (nlang.unsafe.cast @!u8 @!this) self

  method random_container.len = size
    return LEN

  method data = @t
    return (nlang.unsafe.cast @t @u8) self.unsafe_rawdata

  method! mutable_data = @!t
    return (nlang.unsafe.cast @!t @!u8) self.unsafe_mutable_rawdata

  method random_container.all = index_range
    let r:index_range
      r#init 0 self.len
    return r

  method random_container.first = size
    return 0

  method random_container.last = size
    return self.len - 1

  method random_container.at n:size = @t
    let psrc = _unsafe_slice_addr self.unsafe_rawdata (sizeof t) n
    return (nlang.unsafe.cast @t @u8) psrc

  method! random_container.hg_at n:size = @#t
    let psrc = _unsafe_slice_addr self.unsafe_rawdata (sizeof t) n
    return (nlang.unsafe.cast @#t @u8) psrc

  method random_container.operator_get__ n:size = t
    #! self.valid_locus n
    #? self.check_locus n
    let r:t
      let pdst = (nlang.unsafe.cast @!u8 @!t) @!r
      let psrc = _unsafe_slice_addr self.unsafe_rawdata (sizeof t) n
      nlang.unsafe.memcpy pdst psrc (sizeof t) 1
    return r

  method! random_container.operator_set__ n:size x:t = void
    #! self.valid_locus n
    #? self.check_locus n
    let pdst = _unsafe_slice_addr self.unsafe_mutable_rawdata (sizeof t) n
    let psrc = (nlang.unsafe.cast @u8 @t) @x
    nlang.unsafe.memcpy pdst psrc (sizeof t) 1

  method random_container.check_locus n:size = bool
    #~ eval self.check_locus self.valid_locus n
    return n < self.len
