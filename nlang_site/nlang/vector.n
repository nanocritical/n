import nlang.meta
import nlang.literal
import nlang.unsafe
from nlang.prelude import *
from nlang.numbers import *
from nlang import *
from nlang.containers import *
from nlang.slice import *
import nlang.accordion

type vector t = (random_container t)
  _p:nlang.accordion.accordion t
  _len:size

  method! _ctor = void
    return

  method! init len:size ?with:?@t = void
    self!resize len with

  method! copy_slice s:@[]t = void
    self!reserve s.len
    for n:size in s.all_index
      self._p![n] = s.[n]

  method len = size
    return self._p._len

  method capacity = size
    return self._p.capacity

  method! push x:t = void
    let old_size = self._p.len
    let new_size = self._p.len + 1
    self._p!resize new_size
    self._p![old_size] = x

  method! pop = t
    #? self._p.len > 0
    let tmp = self._p.[self._p.len - 1]
    self._p!resize (self._p.len - 1)
    return tmp

  method first = t
    #? self._p.len > 0
    return self._p.[0]

  method last = t
    #? self._p.len > 0
    return self._p.[self._p.len - 1]

  method! clear = void
    self!_p.clear

  method! resize new_size:size = void
    self._p!resize new_size

  method! resize_with new_size:size x:t = void
    let old_size = self._p.len
    self!resize new_size
    for n:size in self._p.all_index
      self._p![n] = x

  method! reserve len:size = void
    if len > self._p.len
      self._p.resize len

  method check_index x:size = bool
    return x <= self._p.len

  method operator_get__ n:size = t
    return self._p.[n]

  method! operator_set__ n:size x:t = void
    self._p![n] = x

  method all_index = index_range
    return self._p.all_index

  method range_index beg:size end:size ?by:?@size = index_range
    return range beg end by

  method all = (element_range this)
    return (element_range this).mk self
