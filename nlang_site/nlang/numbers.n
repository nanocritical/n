import nlang.meta
import nlang.literal
import nlang.unsafe
import nlang.show

-- nlang.predicates contains more limited interfaces that capture weaker
-- orderings. If you're going to define comparison operators, they should
-- define a complete order. We don't want complex behaviors to hide behind
-- benign-looking operator syntax.

intf comparable =
  method operator_eq__ other:@this = bool
  method operator_ne__ other:@this = bool

intf ordered = comparable
  method operator_lt__ other:@this = bool
  method operator_gt__ other:@this = bool
  method operator_le__ other:@this = bool
  method operator_ge__ other:@this = bool

intf hashable =
  method! operator_hash__ = nlang.numbers.size

intf natural_arithmetic = ordered
  method operator_plus__ other:@this = this
  method operator_minus__ other:@this = this
  method operator_times__ other:@this = this
  method operator_divide__ other:@this = this
  method operator_modulo__ other:@this = this
  method operator_neg__ = this

intf bitwise_signed = hashable
  let this_unsigned:nlang.meta.alias
  method reinterpret_unsigned = this.this_unsigned

intf bitwise_unsigned = hashable
  let this_signed:nlang.meta.alias
  method reinterpret_signed = this.this_signed


type __native_arith =
  method operator_plus__ other:@this = this
  method operator_minus__ other:@this = this
  method operator_times__ other:@this = this
  method operator_divide__ other:@this = this
  method operator_modulo__ other:@this = this
  method operator_neg__ = this

type __native_bitwise = ordered
  method operator_rshift__ shift:size = this
  method operator_lshift__ shift:size = this
  method operator_bwand__ other:@this = this
  method operator_bwor__ other:@this = this
  method operator_bwxor__ other:@this = this
  method operator_bwnot__ = this

type __native_order = ordered
  method operator_eq__ other:@this = bool
  method operator_ne__ other:@this = bool
  method operator_lt__ other:@this = bool
  method operator_gt__ other:@this = bool
  method operator_le__ other:@this = bool
  method operator_ge__ other:@this = bool


type void =

type u8 = natural_arithmetic bitwise_unsigned nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let this_signed:nlang.meta.alias = i8
  method reinterpret_signed = this.this_signed
  method to_u16 = u16
  method to_u32 = u32
  method to_u64 = u64
  method operator_hash__ = size

type u16 = natural_arithmetic bitwise_unsigned nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let this_signed:nlang.meta.alias = i16
  method trim_u8 = u8
  method reinterpret_signed = i16
  method to_u32 = u32
  method to_u64 = u64
  method operator_hash__ = size

type u32 = natural_arithmetic bitwise_unsigned nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let this_signed:nlang.meta.alias = i32
  method trim_u8 = u8
  method trim_u16 = u16
  method reinterpret_signed = i32
  method to_u64 = u64
  method operator_hash__ = size

type u64 = natural_arithmetic bitwise_unsigned nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let this_signed:nlang.meta.alias = i64
  method trim_u8 = u8
  method trim_u16 = u16
  method trim_u32 = u32
  method trim_size = size
  method reinterpret_signed = i64
  method operator_hash__ = size

type size = natural_arithmetic bitwise_unsigned nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let this_signed:nlang.meta.alias = ssize
  method trim_u8 = u8
  method trim_u16 = u16
  method trim_u32 = u32
  method trim_u64 = u64
  method reinterpret_signed = ssize
  method operator_hash__ = size

type i8 = natural_arithmetic bitwise_signed nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let MIN:this
  let this_unsigned:nlang.meta.alias = u8
  method reinterpret_unsigned = u8
  method to_i16 = i16
  method to_i32 = i32
  method to_i64 = i64
  method operator_hash__ = size

type i16 = natural_arithmetic bitwise_signed nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let MIN:this
  let this_unsigned:nlang.meta.alias = u16
  method trim_i8 = i8
  method reinterpret_unsigned = u16
  method to_i32 = i32
  method to_i64 = i64
  method operator_hash__ = size

type i32 = natural_arithmetic bitwise_signed nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let MIN:this
  let this_unsigned:nlang.meta.alias = u32
  method trim_i8 = i8
  method trim_i16 = i16
  method reinterpret_unsigned = u32
  method to_i64 = i64
  method operator_hash__ = size

type i64 = natural_arithmetic bitwise_signed nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let MIN:this
  let this_unsigned:nlang.meta.alias = u64
  method trim_i8 = i8
  method trim_i16 = i16
  method trim_i32 = i32
  method trim_ssize = ssize
  method reinterpret_unsigned = u64
  method operator_hash__ = size

type ssize = natural_arithmetic bitwise_signed nlang.show.show_numeric
  inherit __native_arith
  inherit __native_bitwise
  inherit __native_order
  let MAX:this
  let MIN:this
  method trim_i8 = i8
  method trim_i16 = i16
  method trim_i32 = i32
  method trim_i64 = i64
  method reinterpret_unsigned = size
  method operator_hash__ = size

type bool = ordered nlang.show.show
  inherit __native_order


(fun t:ordered) max a:t b:t = t
  if a >= b
    return a
  else
    return b

(fun t:ordered) min a:t b:t = t
  if a <= b
    return a
  else
    return b

-- FIXME Specialize.
(fun t:ordered) compare a:t b:t = i32
  if a == b
    return 0
  elif a > b
    return 1
  else
    return -1
