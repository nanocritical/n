from nlang.prelude import *
import c99

intf locus = comparable copyable_but_owned
intf fwd_locus = locus partially_ordered
intf bidir_locus = fwd_locus ordered

let _locus:typealias = locus

type index_range = trivial_copy
  _begin _end:size

  method! init beg:size end:size = void
    self!_begin = beg
    self!_end = end

  method begin = size
    return self._begin

  method end = size
    return self._end

  method len = size
    return self.end - self.begin

  method sub beg:size end:size = this
    let r:this
      if beg < self._begin or end > self._end
        c99.abort
      r!init beg end
    return r

  method with_offset offset:size = this
    let r:this
      r!init self.begin+offset self.end+offset
    return r

  method iter = index_iterator
    let r:index_iterator
      r!init self.
    return r

intf iterable t =
  let locus:typealias
  let iterator:typealias

  method at p:this.locus = @t
  method! hg_at p:this.locus = @#t
  method iter = this.iterator

intf container t = (iterable t)
  let locus:typealias
  let iterator:typealias

  method len = size
  method# clear = void
  method# remove p:this.locus = void

intf consumer t:copyable =
  method# push x:t = void

intf producer t:copyable =
  method empty = bool
  method# pop = t

intf consumer_producer t:copyable = (consumer t) (producer t)

intf fwd_container t = (container t)
  method first = this.locus

intf bidir_container t = (fwd_container t)
  method last = this.locus

intf assoc_container k:copyable t = (container t)
  method locus_of key:k = this.locus
  method get key:k = ?@t
  method! hg_get key:k = ?@#t

  method all_keys = (iterator this.locus)
  method get_key p:this.locus = ?@t

intf map_key = copyable ordered
intf map_container k:map_key t = (assoc_container k t) (fwd_container t)

intf hashmap_key = copyable hashable
intf hashmap_container k:hashmap_key t = (assoc_container t)

intf random_container t = (bidir_container t) (map_container size t)
  let locus:typealias = size
  method all = index_range
  method valid_index p:size = bool
  method check_index p:size = void
  method valid_range r:@index_range = bool
  method check_range r:@index_range = void
  method operator_get__ p:size = t
  method operator_set__ p:size x:t = void

intf iterator locus:_locus =
  method get = locus
  method has_next = bool
  method! next = bool

intf fwd_iterator locus:fwd_locus = (iterator locus)
intf bidir_iterator locus:bidir_locus = (fwd_iterator locus)
  method has_prev = bool
  method! prev = bool

type index_iterator = (bidir_iterator size)
  _pos:size
  _r:index_range

  method# init r:index_range = void
    self#_r = r

  method bidir_iterator.get = size
    return self._pos

  method bidir_iterator.has_next = bool
    return self._pos < self._r.end

  method! bidir_iterator.next = bool
    if not self.has_next
      return false
    else
      self._pos += 1
      return true

  method bidir_iterator.has_prev = bool
    return self._pos > 0

  method! bidir_iterator.prev = bool
    if not self.has_prev
      return false
    else
      self._pos -= 1
      return true

  method len = size
    return self._r.len

  method! incr n:size = bool
    if self._pos + n >= self._r.end
      return false
    else
      self._pos += n
      return true

  method! decr n:size = bool
    if n > self._pos or self._pos - n < self._r.begin
      return false
    else
      self._pos -= n
      return true

  method! reset = void
    self!_pos = self._r.begin

(type loc1:locus loc2:locus) pair_iterator it1:(iterator loc1) it2:(iterator loc2) =
  _a:@#it1
  _b:@#it2

  method# init a:@#it1 b:@#it2 = void
    self#_a = a
    self#_b = b

  method get = (loc1, loc2)
    return self._a.get, self._b.get

  method has_next = bool
    return self._a.has_next and self._b.has_next

  method! next = bool
    return self._a!next and self._b!next

type index_pair_iterator it1:index_iterator it2:index_iterator =
  _a:@!index_iterator
  _b:@!index_iterator

  method! init a:@!index_iterator b:@!index_iterator = void
    self!_a = a
    self!_b = b

  method get = (loc1, loc2)
    return self._a.get, self._b.get

  method has_next = bool
    return self._a.has_next and self._b.has_next

  method! next = bool
    return self._a!next and self._b!next

  method! reset = void
    self._a!reset
    self._b!reset

fun range beg:size end:size = index_range
  let r:index_range
    r!init beg end
  return r

(fun loc1:locus loc2:locus it1:(iterator loc1) it2:(iterator loc2)) zip a:@#it1 b:@#it2 = (pair_iterator it1 it2)
  let r:(pair_iterator it1 it2)
    r#init a b
  return r

-- The following are used by foreach et al.

(type t:copyable) value_iterator_adapter c:(container t) = (iterator t)
  _c:@c
  _it:c.iterator

  method# init v:@c = void
    self!_c = v
    self!_it = v.iter

  method get = t
    return (self._c.at self._it.get).

  method has_next = bool
    return self._it.has_next

  method! next = bool
    return self._it!next

(type t:copyable) ref_iterator_adapter c:(container t) = (iterator @t)
  _c:@c
  _it:c.iterator

  method# init v:@c = void
    self!_c = v
    self!_it = v.iter

  method get = @t
    return self._c.at self._it.get

  method has_next = bool
    return self._it.has_next

  method! next = bool
    return self._it!next

(type t:copyable) hg_iterator_adapter c:(container t) = (iterator @#t)
  _c:@!c
  _it:c.iterator

  method# init v:@!c = void
    self!_c = v
    self!_it = v.iter

  method get = @#t
    return self._c.hg_at self._it.get

  method has_next = bool
    return self._it.has_next

  method! next = bool
    return self._it!next
