from nlang.prelude import *
from nlang.containers import *

type property t =

fun range beg:size end:size ?incr:?@size = index_range
  return index_range{{ _pos=beg _end=end _incr=(optional incr 1) }}

(fun t1 t2) zip a:(element_iterator t1) b:(element_iterator t2) = (element_pair_iterator t1 t2)

type index_pair_range = index_pair_iterator
  _a _b :index_range

  method index_pair = size, size
    return self._a.index, self._b.index

  method! next = bool
    return self._a!next and self._b!next

(fun t1 t2) zip_index a:(forward_container t1) b:(forward_container t2) = index_pair_range
  return index_pair_range{{ _a=a.all _b=b.all }}

(type t) element_range c:(random_container t) = (element_iterator t)
  _v :@c
  _range :index_range

  method! _ctor ?v:?@c = void
    if v != null
      let nv = nlang.unsafe.nonnull_cast v
      self!_v = nv
      self!_range = nv.all_index

  method! next = bool
    return self._range!next

  method get = t
    return self._v.[self._range.index]

  method sub beg:size end:size ?by:?@size = this
    return this{{ _v=self._v _range=(self._range.sub beg end by) }}

fun _unsafe_slice_clear data:@!u8 elsize:size first:size last:size = void
fun _unsafe_slice_addr data:@!u8 elsize:size n:size = @!u8

type slice t = (random_container t)
  _data :@!u8
  _len :size

  method! _ctor ?len:?@size = void
    self!resize (optional len 0)

  method! _dtor = void
    nlang.unsafe.free self!_data self._len

  method len = size
    return self._len

  method raw_data = @u8
    return self._data

  method! clear = void
    _unsafe_slice_clear self!_data (sizeof t) 0 (self._len - 1)

  method all = (element_range this)
    return (element_range this).mk self

  method first = t
    return self.[0]

  method last = t
    return self.[self.len - 1]

  method! resize new_len:size = void
    let old_len = self.len
    if new_len == old_len
      return
    self!_data = nlang.unsafe.realloc self._data old_len new_len
    self!_len = new_len
    if new_len > old_len
      _unsafe_slice_clear self!_data (sizeof t) old_len new_len
    else
      _unsafe_slice_clear self!_data (sizeof t) new_len old_len

  method! resize_with new_len:size x:t = void
    let old_len = self.len
    self!resize new_len
    for n:size in range old_len self.len
      self![n] = x

  method operator_get__ n:size = t
    #! self.valid_index n
    #? self.check_index n
    let r:t
      let pdst = (nlang.unsafe.cast @!u8 @!t) @!r
      let psrc = _unsafe_slice_addr self._data (sizeof t) n
      nlang.unsafe.memcpy pdst psrc (sizeof t) 1
    return r

  method! operator_set__ n:size x:t = void
    #! self.valid_index n
    #? self.check_index n
    let pdst = _unsafe_slice_addr self._data (sizeof t) n
    let psrc = (nlang.unsafe.cast @u8 @t) @x
    nlang.unsafe.memcpy pdst psrc (sizeof t) 1

  method check_index n:size = bool
    #~ eval self.check_index self.valid_index n
    return n < self._len

  method range beg:size end:size ?by:?@size = (element_range this)
    let er:nlang.meta.alias = (element_range this)
    let c = er.mk self
    return c.sub beg end by

  method all_index = index_range
    return range 0 self.len

  method range_index beg:size end:size ?by:?@size = index_range
    let r = index_range.mk self
    return r.sub beg end by

  method! extend x:@this ?offset:?@size ?len:?@size = void
    let xoffset = optional offset 0
    let xlen = optional len x.len - xoffset
    let at = self.len
    self!resize at + xlen

    let pdst = _unsafe_slice_addr self._data (sizeof t) at
    let psrc = _unsafe_slice_addr x._data (sizeof t) xoffset
    nlang.unsafe.memcpy pdst psrc (sizeof t) xlen

  method! unsafe_extend_memcpy src:@t offset:size len:size = void
    let at = self.len
    self!resize self.len + len
    let pdst = _unsafe_slice_addr self._data (sizeof t) offset
    let psrc = (nlang.unsafe.cast @u8 @t) src
    nlang.unsafe.memcpy pdst psrc (sizeof t) len

(fun t) no_alias a:?@t b:?@t = bool
  #~ eval thisfun a b no_alias a b
  return a != b
