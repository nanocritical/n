from nlang.prelude import *
from nlang.charmod import *
import nlang.show
from nlang.slicemod import *
import nlang.vectormod
import nlang.heap
import nlang.utils
import nlang.predicates
import c99

let __EMPTY_CSTR:@u8

type string = nlang.show.show copyable comparable (random_container u8) nlang.utils.has_compare
  inherit nlang.utils.ordered_with_compare this

  _bytes:(nlang.vectormod.vector u8)

  method! ctor = void
    self._bytes!resize 1
    self._bytes![0] = 0

  -- Should return a nerror, but we don't yet support the cross-dependencies
  -- between stringmod and errormod.
  fun from_bytes bytes:@[]u8 = this, bool
    let r = this{{}}
      r._bytes!reserve bytes.len+1
      r._bytes!extend @bytes.all
      if r._bytes.last != 0
        r._bytes!push 0
    -- FIXME Validate UTF8 encoding.
    return r, true:bool

  fun from_cstr cstr:@u8 = this
    let r = this.mk
      let cstr_len = (c99.strlen cstr) + 1
      let slice_cstr:(slice u8)
        slice_cstr!unsafe_reinit ((nlang.unsafe.cast @!u8 @u8) cstr) cstr_len
      r._bytes!pop
      r._bytes!extend @slice_cstr.all
    return r

  method compare other:@this = i32
    let arange = self._bytes.all
    let brange = other._bytes.all
    for a, b in zip @arange @brange
      let c = compare a. b.
      if c != 0
        return c
    return 0

  method len = size
    return self._bytes.len - 1

  method byte_len = size
    return self._bytes.len - 1

  method bytes = @(nlang.vectormod.vector u8)
    return @self._bytes

  method! append x:@this = void
    self._bytes!pop
    self._bytes!extend @x._bytes.all

  method! push x:char = void
    let c, FIXME = x.to_ascii
    let last = self._bytes.len
    self._bytes!resize last+1
    self._bytes![last-1] = c
    self._bytes![last] = 0

  method! pop = char
    let c = self._bytes.[self._bytes.len-2]
    self._bytes!pop
    self._bytes![self._bytes.len-1] = 0
    return char.from_ascii c

  method cstr = @u8
    if self.len == 0
      return __EMPTY_CSTR
    else
      return nlang.unsafe.nonnull_cast self._bytes.storage_slice.unsafe_rawdata

  method to_s = this
    return self.

  method format_s ?flags:?@u32 ?width:?@size ?precision:?@size = this
    let plen = max (optional precision 0) self.len
    let pwidth = optional width 0
    let padding = 0:size
      if plen < pwidth
        padding = pwidth - plen
    let padding_range = range 0 padding

    let left = (optional flags 0) & nlang.show.LEFT_ALIGN != 0
    let r = this.mk
      if not left
        for n in padding_range.iter
          r!push ' ':char

      r._bytes!pop
      r._bytes!extend @self._bytes.all

      if left
        for n in padding_range.iter
          r!push ' ':char

    return r

  method operator_hash__ = size
    -- From Dan Bernstein, http://www.cse.yorku.ca/~oz/hash.html
    let h = 5381:size
      for i in (self._bytes.range_index 0 self._bytes.len-1).iter
        let c = self._bytes.[i].to_u64.trim_size
        h = ((h << 5) + h) ^ c
    return h
