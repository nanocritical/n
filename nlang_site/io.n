from nlang import *
import nlang.utils
import posix
import os
from nlang.bytestringmod import bytestring

-- No encoding is assumed for the path. We only store a vector of bytes.
-- There is no guarantee, in general on POSIX systems, that a pathname has
-- any particular encoding.

type path = copyable hashable nlang.show.show nlang.utils.has_compare
  inherit nlang.utils.ordered_with_compare this

  _bstr:bytestring

  fun from_string p:@string = this
    let r = this.mk
      r._bstr!extend @p.bytes.all
    return r

  fun from_bytestring p:@bytestring = this
    let r = this{{}}
      r!_bstr = p.
    return r

  method to_s = string, nerror
    let s, ok = string.from_bytes self._bstr.bytes.storage_slice
    if not ok
      return '', nerror.EILSEQ
    else
      return s, nerror.OK

  method cstr = @u8
    return self._bstr.cstr

  method bytes = @bytestring
    return @self._bstr

  method compare other:@this = i32
    return self._bstr.compare @other._bstr

  fun concat a:this b:this = this
    let r = this.mk
      r._bstr!append @a._bstr
      r._bstr!append @b._bstr
    return r

  fun join a:@this b:@this = this
    let r = this.mk
      r._bstr!append @a._bstr

      let slash_code, _ = ('/':char).to_ascii
      if r._bstr.last != slash_code
        r._bstr!push slash_code

      r._bstr!append @b._bstr
    return r

  method! operator_copy__ other:@this = void
    self!_bstr = other._bstr


type open_mode = (nlang.utils.bitwise_mask u32)
  inherit nlang.utils.bitwise_mask_impl u32
  let NONE = this{{ _bits=0 }}
  let S_IRWXU = this{{ _bits=00700 }}
  let S_IRUSR = this{{ _bits=00400 }}
  let S_IWUSR = this{{ _bits=00200 }}
  let S_IXUSR = this{{ _bits=00100 }}
  let S_IRWXG = this{{ _bits=00070 }}
  let S_IRGRP = this{{ _bits=00040 }}
  let S_IWGRP = this{{ _bits=00020 }}
  let S_IXGRP = this{{ _bits=00010 }}
  let S_IRWXO = this{{ _bits=00007 }}
  let S_IROTH = this{{ _bits=00004 }}
  let S_IWOTH = this{{ _bits=00002 }}
  let S_IXOTH = this{{ _bits=00001 }}

type file_mode = (nlang.utils.bitwise_mask u32)
  inherit open_mode
  let S_IFMT = this{{ _bits=0170000 }} -- bit mask for the file type bit fields
  let S_IFSOCK = this{{ _bits=0140000 }} -- socket
  let S_IFLNK = this{{ _bits=0120000 }} -- symbolic link
  let S_IFREG = this{{ _bits=0100000 }} -- regular file
  let S_IFBLK = this{{ _bits=0060000 }} -- block device
  let S_IFDIR = this{{ _bits=0040000 }} -- directory
  let S_IFCHR = this{{ _bits=0020000 }} -- character device
  let S_IFIFO = this{{ _bits=0010000 }} -- FIFO
  let S_ISUID = this{{ _bits=0004000 }} -- set UID bit
  let S_ISGID = this{{ _bits=0002000 }} -- set-group-ID bit (see below)
  let S_ISVTX = this{{ _bits=0001000 }} -- sticky bit (see below)

  extern method isreg = bool
  extern method isdir = bool
  extern method ischr = bool
  extern method isblk = bool
  extern method isfifo = bool
  extern method islnk = bool
  extern method issock = bool


type stat =
  _p:path
  _st:posix.stat_t
  _valid:bool

  method pathname = path
    return self._p

  method! stat_path p:@path = nerror
    self!_p = p.
    let err = posix.stat p.cstr @!self._st
    self!_valid = err == nerror.OK
    return err

  method! stat_file f:@file = nerror
    self!_p = f.pathname
    let err = posix.fstat f.fd @!self._st
    self!_valid = err == nerror.OK
    return err

  method valid_entry = bool
    return self._valid

  method device = u64
    return self._st.dev
  method inode = u64
    return self._st.ino
  method mode = file_mode
    return file_mode{{ _bits=self._st.mode }}
  method link_count = u64
    return self._st.nlink
  method uid = u64
    return self._st.uid
  method gid = u64
    return self._st.gid
  method size = size
    return self._st.size
  method block_size = size
    return self._st.blksize
  method block_count = size
    return self._st.blocks
  method atime = os.time64
    return os.time64.from_sec self._st.atime
  method mtime = os.time64
    return os.time64.from_sec self._st.mtime
  method ctime = os.time64
    return os.time64.from_sec self._st.ctime


let _O_RDONLY:i32
let _O_WRONLY:i32
let _O_RDWR:i32
let _O_APPEND:i32
let _O_ASYNC:i32
let _O_CLOEXEC:i32
let _O_CREAT:i32
let _O_DIRECT:i32
let _O_DIRECTORY:i32
let _O_EXCL:i32
let _O_NOATIME:i32
let _O_NOCTTY:i32
let _O_NOFOLLOW:i32
let _O_NONBLOCK:i32
let _O_NDELAY:i32
let _O_SYNC:i32
let _O_TRUNC:i32

type open_flags = (nlang.utils.bitwise_mask i32)
  inherit nlang.utils.bitwise_mask_impl i32
  let O_RDONLY = this{{ _bits=_O_RDONLY }}
  let O_WRONLY = this{{ _bits=_O_WRONLY }}
  let O_RDWR = this{{ _bits=_O_RDWR }}
  let O_APPEND = this{{ _bits=_O_APPEND }}
  let O_ASYNC = this{{ _bits=_O_ASYNC }}
  let O_CLOEXEC = this{{ _bits=_O_CLOEXEC }}
  let O_CREAT = this{{ _bits=_O_CREAT }}
  let O_DIRECT = this{{ _bits=_O_DIRECT }}
  let O_DIRECTORY = this{{ _bits=_O_DIRECTORY }}
  let O_EXCL = this{{ _bits=_O_EXCL }}
  let O_NOATIME = this{{ _bits=_O_NOATIME }}
  let O_NOCTTY = this{{ _bits=_O_NOCTTY }}
  let O_NOFOLLOW = this{{ _bits=_O_NOFOLLOW }}
  let O_NONBLOCK = this{{ _bits=_O_NONBLOCK }}
  let O_NDELAY = this{{ _bits=_O_NDELAY }}
  let O_SYNC = this{{ _bits=_O_SYNC }}
  let O_TRUNC = this{{ _bits=_O_TRUNC }}


type file =
  _p:path
  _fd:i32

  method! open p:path flags:open_flags ?mode:?@open_mode = nerror
    let fd, err = posix.open p.cstr flags.to_bits (optional mode open_mode.NONE).to_bits
    if err != nerror.OK
      return err
    self!_fd = fd
    self!_p = p
    return nerror.OK

  method! close = nerror
    return posix.close self.fd

  method fd = i32
    return self._fd

  method pathname = path
    return self._p

  method! read buf:@![]u8 ?range:?@index_range = size, nerror

  method! write buf:@[]u8 ?range:?@index_range = size, nerror

  method! sync = nerror
    return posix.fsync self.fd

  method! datasync = nerror
    return posix.fdatasync self.fd
