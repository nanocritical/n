from n import *
import n.io
import n.fmt

inline struct Reader =
	isa io.`Reader
	R		:?#io.`Reader
	bufr		:?#Reader -- If wrapping an already buffered reader.
	rdy		:Bool
	buf		:Stringbuf
	pending		:String
	copier		:io.Copier

Reader fun Mk r:#io.`Reader = ret:this
	ret#R = r

Reader met Total_filled = Uint
	if self.bufr?
		return self.bufr.Total_filled
	return self.copier.Total_written

Reader met# Read b:[!]U8 = [!]U8, Error
	if not self.R?
		return {}, OK
	if self.bufr?
		return self#bufr#Read b

	if self.Buffered == 0
		return b, io.EOF

	let before = b.Count
	let result = b!Append self.pending.Bytes
	let read = result.Count - before
	self!pending = self.pending.[read ..]
	return result, OK

Reader met Buffered = Uint
	if self.bufr?
		return self.bufr.Buffered
	return self.pending.Count

-- Returns OK if max bytes were read. If unspecified, reads until io.EOF or
-- another read or write error.
Reader met# Fill ?max:?Uint = Error
	if not self.R?
		return OK
	if not self.rdy
		self#bufr = (Dyncast Reader) self#R
		self!rdy = true
		if not self#bufr?
			self!copier#Reset #self#buf self#R

	if self#bufr?
		return self#bufr#Fill max=max

	self#buf#Copy self.pending.Bytes
	let _, err = self!copier#Copy max=max
	self#pending = self.buf.String
	return err

-- Does not Fill more data.
-- The returned slice is valid until the next call to Fill.
Reader met! Read_bytes ?max:?Uint = []U8
	return (self!Read_string max=max).Bytes

-- Does not Fill more data.
-- The returned string is valid until the next call to Fill.
Reader met! Read_string ?max:?Uint = String
	if self.bufr?
		return self!bufr!Read_string max=max
	let len = Min (max else Uint.MAX) self.pending.Count
	let r = self.pending.[.. len]
	self!pending = self.pending.[len ..]
	return r

-- Does not Fill more data. Does not advance.
-- The returned slice is valid until the next call to Fill.
Reader met Peek_bytes ?max:?Uint = []U8
	return (self.Peek_string max=max).Bytes

-- Does not Fill more data. Does not advance.
-- The returned string is valid until the next call to Fill.
Reader met Peek_string ?max:?Uint = String
	if self.bufr?
		return self.bufr.Peek_string max=max
	let len = Min (max else Uint.MAX) self.pending.Count
	return self.pending.[.. len]

Reader met! Advance cnt:Uint
	if self.bufr?
		self!bufr!Advance cnt
		return
	self!pending = self.pending.[cnt ..]

Reader met! Rewind cnt:Uint
	if self.bufr?
		self!bufr!Rewind cnt
		return
	-- pending is a sub-string of buf.
	let cur = self.buf.Count - self.pending.Count
	assert cur >= cnt
	self!pending = self.buf.[cur ..]

-- Does not Fill more data.
-- The returned slice is valid until the next call to Fill.
-- If a newline ("\r\n" or "\n") is not reached, it returns partial==true.
-- Advances past the newline.
Reader met! Read_line = partial:Bool, line:String
	if self.bufr?
		return self!bufr!Read_line
	let i = self.pending.Index_byte '\n'
	if i < 0
		line = self.pending
		self!pending = {}
		partial = true
	else
		var eol = i.Unsigned
		if eol > 0 and self!pending![eol-1] == '\r'
			eol -= 1
		line = self.pending.[.. eol]
		self!pending = self!pending![i.Unsigned+1 ..]

-- Does not Fill more data.
-- The returned slice is valid until the next call to Fill.
-- If a newline ("\r\n" or "\n") is not reached, it returns partial==true.
Reader met Peek_line = partial:Bool, line:String
	if self.bufr?
		return self!bufr!Peek_line
	let i = self.pending.Index_byte '\n'
	if i < 0
		line = self.pending
		partial = true
	else
		var eol = i.Unsigned
		if eol > 0 and self!pending![eol-1] == '\r'
			eol -= 1
		line = self.pending.[.. eol]


example reader
	let s = "This is a test"
	var sr = #<- io.Mk_string_reader s
	var r = #<- Reader.Mk sr
	var buf:Stringbuf
	buf#Reserve 32
	var b = buf!Bytes
	var err = OK

	b, err = r#Read b
	assert b.Count == 0 and err == io.EOF

	except = r#Fill max=4
	b, err = r#Read b
	assert b.Count == 4 and err == OK and b.Const == "This".Bytes

	err = r#Fill
	assert err == io.EOF
	b, err = r#Read b![.. 0]
	assert b.Count == s.Count-4 and err == OK and b.Const == s.Bytes.[4 ..]

	b, err = r#Read b
	assert b.Count == s.Count-4 and err == io.EOF

	assert r.Total_filled == s.Count


-- Write never block or return AGAIN. However, Flush may.
-- Flushes are not automatic. The buffer has no maximum size, it will keep
-- allocating more memory until it is flushed.

inline struct Writer =
	isa io.`Writer
	W		:?#io.`Writer
	bufw		:?#Writer
	rdy		:Bool
	buf		:Stringbuf
	pending		:[]U8
	count_flushed	:Uint

Writer fun Mk w:#io.`Writer = ret:this
	ret#W = w

Writer met Count_flushed = Uint
	if self.bufw?
		return self.bufw.Count_flushed
	return self.count_flushed

Writer met# Write b:[]U8 = []U8, Error
	if not self.rdy
		self#bufw = (Dyncast Writer) self#W
		self!rdy = true

	if not self.W? or not self.rdy
		return {}, OK
	if self.bufw?
		return self#bufw#Write b
	_, _ = self#buf#Write b
	self!pending = self.buf.Bytes
	return {}, OK

Writer met Buffered = Uint
	if self.bufw?
		return self.bufw.Buffered
	return self.pending.Count

Writer met# Write_string s:String = Error
	_, except = self#Write s.Bytes

Writer met# Flush ?max:?Uint = Error
	if not self.W?
		return OK
	if self.bufw?
		return self#bufw#Flush max=max

	let len = max else self.pending.Count
	let left, wr_err = io.Write_full self#W self.pending.[.. len]
	let copied = len - left.Count
	self!count_flushed += copied
	self!pending = self.pending.[copied ..]
	self#buf#Copy self.pending
	self!pending = self.buf.Bytes
	return wr_err

example writer
	var buf:Stringbuf
	var w = #<- Writer.Mk #buf

	fmt.F w "This is a test."
	assert buf == ""
	fmt.F w " This is only a test."
	fmt.F w " Do not leave the dancefloor."
	assert buf == ""

	except = w#Flush max=4
	assert buf == "This"

	except = w#Flush
	assert buf == "This is a test. This is only a test. Do not leave the dancefloor."

	assert w.Count_flushed == buf.Count


enum Auto_mode =
	| FULLY_BUFFERED = 0
	| LINE_BUFFERED
	| UNBUFFERED


-- Wraps around a bufio.Reader and automatically loads the buffer when
-- depleted. May block.
inline struct Auto_reader =
	isa io.`Reader
	R	:#Reader

Auto_reader met# Read b:[!]U8 = r:[!]U8, err:Error
	r, err = self#R#Read b
	if r.Count == b.Count and err == io.EOF
		err = self#R#Fill
		if err != OK
			return r, err
		r, err = self#R#Read b


-- Wraps around a bufio.Writer, and automatically flushes the buffer when it
-- contains Max bytes, or sooner according to the buffering mode.
-- Writes may block while the buffer is flushed.
--
-- FULLY_BUFFERED: automatically flush blocks of exactly Max bytes, or less if
-- flushed manually.
--
-- LINE_BUFFERED: automatically flush after the last newline byte in a write,
-- or flush blocks of exactly Max bytes, or less if flushed manually.
--
-- UNBUFFERED: bypass the underlying bufio.Writer entirely, uses io.Write_full
-- on the inner `Writer in the bufio.Writer.
--
-- Auto_writer does not assume that it is the only writer to the bufio.Writer.
inline struct Auto_writer =
	isa io.`Writer io.`Flusher
	W	:#Writer
	Mode	:Auto_mode
	Max	:Uint

-- Underlying writes will be of max bytes, or self.Max if left unspecified.
Auto_writer met# Flush ?max:?Uint = Error
	return self#W#Flush max=max

Auto_writer met# buffered_write b:[]U8 = r:[]U8, err:Error
	-- If someone else is writing to the bufio.Writer, try to maintain the
	-- block flushing behavior.
	while self.W.Buffered > self.Max
		err = self#W#Flush max=self.Max
		if err != OK
			return b, err

	r = b
	while r.Count > 0
		let room = self.Max - self.W.Buffered
		if r.Count <= room
			return self#W#Write r

		let head, tail = r.[.. room], r.[room ..]
		_, never = self#W#Write head

		err = self#W#Flush
		if err != OK
			return tail, err

		r = tail

Auto_writer met# Write b:[]U8 = r:[]U8, err:Error
	match self.Mode
	| FULLY_BUFFERED
		return self#buffered_write b

	| LINE_BUFFERED
		let bs = String.From_bytes b
		let last_nl = bs.Last_index_byte '\n'
		if last_nl < 0
			return self#buffered_write b

		let to_flush, not_to_flush = bs.Cut_at last_nl.Unsigned+1

		r, err = self#buffered_write to_flush.Bytes
		if err != OK
			return r, err
		err = self#W#Flush
		if err != OK
			return r, err

		return self#buffered_write not_to_flush.Bytes

	| UNBUFFERED
		return io.Write_full self#W#W b

example auto_writer_fully_buffered
	var buf:Stringbuf
	var w = {W=#buf}:Writer
	var aw = #{W=#w Mode=FULLY_BUFFERED Max=16}:Auto_writer
	var left

	left, except = aw#Write "abc\n".Bytes
	assert left.Count == 0 and buf == ""

	left, except = aw#Write "abcabcabcabc".Bytes -- 4 + 12 bytes, will just hit Max: no flush.
	assert left.Count == 0 and buf == ""

	left, except = aw#Write "".Bytes
	assert left.Count == 0 and buf == ""
	left, except = aw#Write "a".Bytes
	assert left.Count == 0 and buf == "abc\nabcabcabcabc"

	except = aw#Flush
	assert buf == "abc\nabcabcabcabca"

example auto_writer_line_buffered
	var buf:Stringbuf
	var w = {W=#buf}:Writer
	var aw = #{W=#w Mode=LINE_BUFFERED Max=16}:Auto_writer
	var left

	left, except = aw#Write "abc".Bytes
	assert left.Count == 0 and buf == ""

	left, except = aw#Write "\n".Bytes
	assert left.Count == 0 and buf == "abc\n"

	left, except = aw#Write "abc\nabc".Bytes
	assert left.Count == 0 and buf == "abc\nabc\n"
	assert aw.W.Buffered == 3

	left, except = aw#Write "abcabcabcabcd".Bytes -- 3 + 13 bytes, will just hit Max: no flush.
	assert left.Count == 0 and buf == "abc\nabc\n"

	left, except = aw#Write "e".Bytes -- Over Max: flush.
	assert left.Count == 0 and buf == "abc\nabc\nabcabcabcabcabcd"

	except = aw#Flush
	assert buf == "abc\nabc\nabcabcabcabcabcde"

	buf#Clear
	left, except = aw#Write "a\nabcabcabcabcabcd".Bytes -- nl flush, and 16 chars.
	assert left.Count == 0 and buf == "a\n"

	except = aw#Flush
	buf#Clear
	left, except = aw#Write "a\nabcabcabcabcabcde".Bytes -- nl flush, and 17 chars flush.
	assert left.Count == 0 and buf == "a\nabcabcabcabcabcd"

example auto_writer_unbuffered
	var buf:Stringbuf
	var w = {W=#buf}:Writer
	var aw = #{W=#w Mode=UNBUFFERED}:Auto_writer
	var left

	left, except = aw#Write "abc".Bytes
	assert left.Count == 0 and buf == "abc"

	left, except = aw#Write "\n".Bytes
	assert left.Count == 0 and buf == "abc\n"

	left, except = aw#Write "abc\nabc".Bytes
	assert left.Count == 0 and buf == "abc\nabc\nabc"
