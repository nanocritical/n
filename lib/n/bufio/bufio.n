from n import *
import n.io
import n.fmt

let buf_size = 4096

inline struct Reader =
	isa io.`Reader
	R	:?#io.`Reader
	bufr	:?#Reader -- If wrapping an already buffered reader.
	rdy	:Bool
	buf	:Stringbuf
	pending	:String
	copier	:io.Copier

Reader fun Mk r:#io.`Reader = ret:this
	ret#R = r

Reader met# Read b:[!]U8 = [!]U8, Error
	if not self.R?
		return {}, OK
	if self.bufr?
		return self#bufr#Read b

	if self.Buffered == 0
		return b, io.EOF

	let before = b.Count
	let result = b!Append self.pending.Bytes
	let read = result.Count - before
	self!pending = self.pending.[read ..]
	return result, OK

Reader met Buffered = Uint
	if self.bufr?
		return self.bufr.Buffered
	return self.pending.Count

Reader met# Load ?max:?Uint = Error
	if not self.R?
		return OK
	if not self.rdy
		self#bufr = (Dyncast Reader) self#R
		self!rdy = true
		if not self#bufr?
			self!copier#Reset #self#buf self#R

	if self#bufr?
		return self#bufr#Load max=max

	self#buf#Copy self.pending.Bytes
	_, except = self!copier#Copy max=(max else buf_size)
	self#pending = self.buf.String

-- Does not Load more data.
-- The returned slice is valid until the next call to Load.
Reader met! Read_slice max:Uint = []U8
	return (self!Read_string max).Bytes

-- Does not Load more data.
-- The returned string is valid until the next call to Load.
Reader met! Read_string max:Uint = String
	let len = Min max self.pending.Count
	self!pending = self.pending.[len ..]
	return self.pending.[.. len]

-- Does not Load more data. Does not advance.
-- The returned slice is valid until the next call to Load.
Reader met Peek_slice max:Uint = []U8
	return (self.Peek_string max).Bytes

-- Does not Load more data. Does not advance.
-- The returned string is valid until the next call to Load.
Reader met Peek_string max:Uint = String
	let len = Min max self.pending.Count
	return self.pending.[.. len]

Reader met! Advance cnt:Uint
	self!pending = self.pending.[cnt ..]

-- Does not Load more data.
-- The returned slice is valid until the next call to Load.
-- If a newline ("\r\n" or "\n") is not reached, it returns true.
-- Advances past the newline.
Reader met! Read_line = partial:Bool, line:String
	let i = self.pending.Index_byte '\n'
	if i < 0
		line = self.pending
		self!pending = {}
		partial = true
	else
		var eol = i.Unsigned
		if eol > 0 and self.pending.[eol-1] == '\r'
			eol -= 1
		line = self.pending.[.. eol]
		self!pending = self.pending.[i.Unsigned+1 ..]

example reader
	let s = "This is a test"
	var sr = #<- io.Mk_string_reader s
	var r = #<- Reader.Mk sr
	var buf:Stringbuf
	buf#Reserve 32
	var b = buf!Bytes
	var err = OK

	b, err = r#Read b
	assert b.Count == 0 and err == io.EOF

	except = r#Load max=4
	b, err = r#Read b
	assert b.Count == 4 and err == OK and b.Const == "This".Bytes

	except = r#Load
	b, err = r#Read b![.. 0]
	assert b.Count == s.Count-4 and err == OK and b.Const == s.Bytes.[4 ..]

	b, err = r#Read b
	assert b.Count == s.Count-4 and err == io.EOF


-- Writes never block or return AGAIN. However, Flush may.
-- Flushes are not automatic.

inline struct Writer =
	isa io.`Writer
	W	:?#io.`Writer
	bufw	:?#Writer
	rdy	:Bool
	buf	:Stringbuf
	pending	:[]U8

Writer fun Mk w:#io.`Writer = ret:this
	ret#W = w

Writer met# Write b:[]U8 = []U8, Error
	if not self.rdy
		self#bufw = (Dyncast Writer) self#W
		self!rdy = true

	if not self.W? or not self.rdy
		return {}, OK
	if self.bufw?
		return self#bufw#Write b
	_, _ = self#buf#Write b
	self!pending = self.buf.Bytes
	return {}, OK

Writer met Buffered = Uint
	if self.bufw?
		return self.bufw.Buffered
	return self.pending.Count

Writer met# Write_string s:String = Error
	_, except = self#Write s.Bytes

Writer met# Flush ?max:?Uint = Error
	if not self.W?
		return OK
	if self.bufw?
		return self#bufw#Flush max=max

	let len = max else self.pending.Count
	let left, except = io.Write_full self.W self.pending.[.. len]
	let copied = len - left.Count
	self!pending = self.pending.[copied ..]
	self#buf#Copy self.pending
	self!pending = self.buf.Bytes

example writer
	var buf:Stringbuf
	var w = #<- Writer.Mk #buf

	fmt.F w "This is a test."
	assert buf == ""
	fmt.F w " This is only a test."
	fmt.F w " Do not leave the dancefloor."
	assert buf == ""

	except = w#Flush max=4
	assert buf == "This"

	except = w#Flush
	assert buf == "This is a test. This is only a test. Do not leave the dancefloor."
