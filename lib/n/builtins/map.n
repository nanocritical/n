intf `Hashable32 =
	met Hash32 = U32

alias `Map_key = {`Hashable32 `Copyable `Has_equality}

struct sptable T:`Copyable =
	count	:Uint
	groups	:(Buf (Buf T))
	bitmap	:Bitmap

inline let sp_m = 32:Uint
inline let sp_min_size = 2*sp_m

fun sp_num_groups size_pow2:Uint = Uint
	return math.Div_ceil size_pow2 32

sptable met# init size_pow2:Uint
	self!count = 0
	self!bitmap#Resize <- Max size_pow2 sp_min_size
	self!groups#Resize (sp_num_groups self.bitmap.Count)

sptable met size = Uint
	return self.bitmap.Count

fun maskout_after mask:U32 = U32
	return mask - 1

example
	assert maskout_after (1 ov<< 31) == 0x7fffffff
	assert maskout_after (1 ov<< 1) == 0x1
	assert maskout_after (1 ov<< 0) == 0x0

sptable shallow met$ get n:Uint = ?$T
	assert n < self.size
	let word, mask = Bitmap_split n
	let w = self.bitmap.Words.[word]*
	if w & mask == 0
		return nil

	let before_w = w & (maskout_after mask)
	let count_before = math.Bit_popcount before_w
	let gr = self$groups$[word]
	return gr.Operator_at count_before

sptable met# set n:Uint = #T
	assert n < self.size
	let word, mask = Bitmap_split n
	let w = self!bitmap!Words![word]
	let before_w = w & (maskout_after mask)
	let count_before = math.Bit_popcount before_w
	let gr = self.groups![word]
	if w & mask != 0
		return gr![count_before]

	w! |= mask
	self!count += 1

	let old_count = gr.Count
	gr#Resize gr.Count+1

	let src_after = gr![count_before .. old_count]
	let dst_after = gr![count_before+1 ..]
	dst_after!Exact_copy src_after
	return gr![count_before]

sptable met! iter = (sptable_iter T)
	let w = 0:U32 such
		if self.bitmap.Count > 0
			w = self.bitmap.Words.First
	return {table=self ng=self.groups.Count g=0 w=w}

struct sptable_iter T:`Copyable =
	isa (`Iterator (Uint, #T))
	table	:*(sptable T)	--::(owns self)
	ng	:Uint
	g	:Uint
	w	:U32
	w_nth	:U32

sptable_iter met Has_next = Bool
	if self.w != 0
		return true
	if self.g+1 >= self.ng
		return false
	return (self.table.bitmap.Ffs_from (self.g+1)*32)?

sptable_iter met! Next = Uint, #T
	while self.w == 0 and self.g < self.ng
		self!g += 1
		self!w = self.table.bitmap.Words.[self.g]
		self!w_nth = 0

	let nxt = (math.Bit_ffs self.w) - 1
	self!w &= ~(1:U32 ov<< nxt)
	let w_nth = self.w_nth
	self!w_nth += 1
	let gr = self.table.groups![self.g]
	return self.g*32 + nxt, gr![w_nth.Uint]

example sptable_basic
	var t = {}:(sptable Uint)
	t#init 100
	(t#set 0)# = 42
	assert t#get 1 === nil
	assert (t#get 0)* == 42
	assert t.count == 1
	(t#set 7)# = 44
	assert t.count == 2
	assert (t#get 7)* == 44
	(t#set 3)# = 43
	assert t.count == 3
	assert (t#get 3)* == 43
	(t#set 99)# = 45
	assert t.count == 4
	assert (t#get 0)* == 42
	assert (t#get 3)* == 43
	assert (t#get 7)* == 44
	assert (t#get 99)* == 45

	for i, e in t!iter
		match i
		| 0 -> assert e == 42
		| 3 -> assert e == 43
		| 7 -> assert e == 44
		| 99 -> assert e == 45
		| _ -> assert false

example sptable_group_boundary
	var t = {}:(sptable Uint)
	t#init 32+1
	(t#set 32-1)# = 42
	(t#set 32)# = 43
	assert t#get 1 === nil
	assert (t#get 32)* == 43
	assert (t#get 32-1)* == 42
	assert t.count == 2

struct unit K:`Map_key T:`Copyable =
	hash	:?U32
	key	:K
	val	:T

struct Map K:`Map_key T:`Copyable =
	isa `Show (`Slice_compatible (K, T)) `Copyable (`Collection K)
	alias unit_type = (unit K T)
	table	:(sptable unit_type)
	count	:Uint

-- Ignore duplicated keys.
Map fun From_slice c:[](K, T) = r:this
	foreach i in c.All
		let k, v = c.[i]
		let added, p = r#Try_store k
		if added
			p# = v

Map met# init ?size_pow2:?Uint
	self#table#init (size_pow2 else sp_min_size)

Map met# ensure_init
	if self.table.size < sp_min_size
		self#init

Map met# Dtor
	self#Clear

Map met# Clear
	self#table#Dtor
	self!count = 0

Map met# Copy_ctor other:*this
	self#Dtor
	assert self#Ingest other

Map met Count = Uint
	return self.count

-- Quadratic open addressing (see Knuth TAOCP 6.4 exercise 20)
--
-- The table must have at least one empty spot to make sure that, if the
-- table is full, the quadratic search eventually stops.
inline fun quad_open_addr size:Uint hash:U32 nth:Uint = Uint
	return ((hash + (nth.Trim_u32 * (nth.Trim_u32+1)) / 2) & (size.Trim_u32 - 1)).Uint

Map met index hash:U32 nth:Uint = Uint
	return quad_open_addr self.table.size hash nth

example check_bijection
	let hash = 0xcafebabe:U32
	let size = 4096
	var hits = {}:Bitmap
	hits#Resize size
	foreach nth in 0 .. size
		hits!Set <- quad_open_addr size hash nth
	assert hits.Popcount == size

Map shallow met$ get_unit key:*K trying:Bool = ?$this.unit_type, idx:Uint, hash:U32
	if trying and self.Count == 0
		return nil, 0, 0

	hash = key.Hash32
	var nth
	while true
		idx = self.index hash nth
		let u = self.table$get idx
		nth += 1
		if not u?
			return nil, idx, hash
		if Unlikely <- not u.hash?
			-- Deleted
			continue
		if u.hash != hash
			continue
		if u.key == key
			return u, idx, hash

Map met Operator_in key:*K = Bool
	return self.[key]?

Map shallow met$ Operator_at key:*K = ?$T
	let u, _, _ = self$get_unit key true
	if u?
		return $u$val
	return nil

Map met# may_grow = Bool
	-- 3/4 full?
	if self.count <= self.table.size/2
		return false

	-- Grow.
	-- We will move tmp over self, we don't want the memory to be freed.
	var tmp = Alloc this
	-- Must remain a power of 2.
	tmp#init size_pow2=2*self.table.size
	let all = tmp#Ingest self
	assert all

	self#Dtor

	-- Steal the memory owned by tmp.
	Slice_memmove ((Cast #this #U8) self) ((Cast #this #U8) tmp) (sizeof this)
	-- Zero tmp (to ensure its Dtor is a no-op), and free it.
	Slice_memset ((Cast #this #U8) tmp) 0 (sizeof this)
	Free tmp

	assert self.count <= self.table.size/2
	return true

Map met# store key:*K = added:Bool, #T
	self#ensure_init
	var u, idx, hash = self!get_unit key false
	if u?
		return false, #u#val

	-- Need to create a spot.
	if self#may_grow
		-- The table has changed, we need to recompute idx.
		_, idx, _ = self!get_unit key false

	self!count += 1
	let nu = self#table#set idx
	nu#hash = hash
	nu#key = key
	return true, #nu#val

Map met# Store key:*K = #T
	let _, loc = self#store key
	return loc

Map met# Try_store key:*K = added:Bool, #T
	return self#store key

-- Return true if some keys from 'other' were already in 'self'.
Map met# Ingest other:*this = ingested_all:Bool
	ingested_all = true
	for pos in other.table.bitmap.Iter
		let u = other#table#get pos
		if not u.hash?
			continue
		let added, loc = self#Try_store u.key
		if not added
			ingested_all = false
			continue
		loc# = u.val
	return ingested_all

Map met# Try_delete key:*K = deleted:Bool
	if self.Count == 0
		return false

	let u, _, _ = self!get_unit key true
	if u?
		u!hash = nil
		u!key = {}
		u!val = {}
		self!count -= 1
		return true

	return false

Map met# Delete key:*K
	assert self#Try_delete key

Map shallow met$ Iter = (Map_iter this $T)
	-- To avoid this cast, we would have to make sptable_iter more complex.
	let mself = (Cast *this !this) self
	return {iter=mself!table!iter}

(fun t:`Any) show_ptr st:#`Fmt_state x:*t
	"<".Show st
	((Cast *t Voidref) x).Uintptr.Show st
	">".Show st

Map met Show st:#`Fmt_state
	"{".Show st
	var i = 0:Uint
	for k, v in self.Iter
		if i > 0
			", ".Show st
		"(".Show st
		if k isa `Show
			k.Show st
		else
			show_ptr st k
		", ".Show st
		if v* isa `Show
			v.Show st
		else
			show_ptr st v
		")".Show st
		i += 1
	"}".Show st

(struct K:`Map_key T:`Copyable) Map_iter H:(Map K T) RT:`Any_any_ref =
	isa (`Iterator (K, RT)) `Trivial_copy `Trivial_ctor
	iter	:(sptable_iter H.unit_type)

Map_iter met Has_next = Bool
	return self.iter.Has_next

Map_iter met! Next = K, RT
	while true
		let _, u = self!iter!Next
		if u.hash?
			return u.key, #u#val

struct Set T:`Map_key =
	isa (`Set T) `Show `Copyable
	map	:(Map T Bool)

-- Ignore duplicated elements.
Set fun From_slice c:[]T = r:this
	foreach i in c.All
		let x = c.[i]
		let added, p = r!map#Try_store x
		if added
			p# = true

Set met# Clear
	self#map#Dtor

Set met# Copy_ctor other:*this
	self#Clear
	assert self#Add_all other

Set met Count = Uint
	return self.map.Count

Set met Operator_in x:*T = Bool
	return self.map.[x] else false

Set met# Add x:*T = added:Bool
	let added, p = self!map#Try_store x
	if added
		p# = true
		return true
	return false

Set met# Add_all other:*this = added_all:Bool
	added_all = true
	for x in other.Iter
		added_all = self!Add x and added_all

Set met# Remove x:*T = removed:Bool
	return self!map#Try_delete x

Set met# Remove_all other:*this = removed_all:Bool
	removed_all = true
	for x in other.Iter
		removed_all = self!Remove x and removed_all

Set met# Intersect other:*this
	-- We cannot call self#Remove while iterating.
	-- We just set the mapping to false, which is valid.
	-- TODO(e): rehash the set if the size has changed a lot.
	for x, v in self.map!Iter
		if not x in other
			v# = false

Set met# Symmetric_difference other:*this
	for x in other.Iter
		if x in self
			let _ = self.Remove x
		else
			let _ = self.Add x

Set met Operator_eq other:*this = Bool
	if self.Count != other.Count
		return false

	for x in other.Iter
		if not x in self
			return false
	return true

Set met Operator_ne other:*this = Bool
	return not self == other

Set met Operator_le other:*this = Bool
	if self.Count > other.Count
		return false
	for x in self.Iter
		if not x in other
			return false
	return true

Set met Operator_lt other:*this = Bool
	if self.Count >= other.Count
		return false
	return self <= other

Set met Operator_gt other:*this = Bool
	return self <= other

Set met Operator_ge other:*this = Bool
	return self < other

Set met Show st:#`Fmt_state
	"{".Show st
	var i = 0:Uint
	for x in self.Iter
		if i > 0
			" ".Show st
		if x isa `Show
			x.Show st
		else
			show_ptr st x
		i += 1
	"}".Show st

Set met Iter = (Set_iter T)
	return {iter=self.map.Iter}

struct Set_iter T:`Map_key =
	isa (`Iterator T) `Trivial_copy `Trivial_ctor
	iter	:(Map_iter (Map T Bool) *Bool)

Set_iter met Has_next = Bool
	return self.iter.Has_next

Set_iter met! Next = T
	return self!iter!Next.X0
