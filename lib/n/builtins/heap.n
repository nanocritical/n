intf `Heap =
	isa (bench.`Observable_of Heap_stats)
	met! Alloc_raw bytecount:Uint = @#U8
	met! Free_raw p:?@#U8 bytecount:Uint
	met! Realloc_raw s:@#U8 old_bytecount:Uint bytecount:Uint = @#U8

globalenv Heap:@!`Heap

fun Install_sysheap sysheader:@#(Envheader @!`Heap) within Heap
	Globalenv_install Heap sysheader

(fun t:`Any) Alloc = @#t within Heap
	return (Cast @#U8 @#t) <- Heap!Alloc_raw (sizeof t)

(fun t:`Any) Free p:@#t within Heap
	Heap!Free_raw ((Cast @#t @#U8) p) (sizeof t)

(fun t:`Any) Realloc s:@#[]!t count:Uint within Heap
	let old_raw = s#Unsafe_rawdata
	and old_bytecount = s#Bytecount
	and bytecount = count * (sizeof t)
	let raw = Heap!Realloc_raw old_raw old_bytecount bytecount
	s# = {dat=((Cast @#U8 @#t) raw) cnt=s.cnt cap=count}


inline struct Heap_stats =
	isa bench.`Measure
	Allocated	:Int
	Freed		:Int
	Max_size	:Int

Heap_stats met Operator_plus other:@this = r:this
	r!Allocated = self.Allocated + other.Allocated
	r!Freed = self.Freed + other.Freed
	r!Maintain

Heap_stats met Operator_minus other:@this = r:this
	r!Allocated = self.Allocated - other.Allocated
	r!Freed = self.Freed - other.Freed
	r!Maintain

Heap_stats met Operator_uminus other:@this = r:this
	r!Allocated = - self.Allocated
	r!Freed = - self.Freed
	r!Maintain

Heap_stats met Size = Int
	return self.Allocated - self.Freed

Heap_stats met! Maintain
	self!Max_size = Max self!Max_size self.Size
