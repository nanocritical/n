from n.containers import `Iterator `Random_container `Collection `Set `Universal_set
from n.unsafe import Cast Nonnull_cast Voidref
from n import Eprn Epr
import n.reflect
import n.math
import n.mem
import n.env
import n.time
import n.io
import n.fs
import n.bench

extern intf `__literal_nil__ =
	isa `Any_nullable_ref
extern intf `__literal_integer__ =
	isa `Integer
extern intf `__literal_floating__ =
	isa `Floating
extern intf `__literal_slice__ t:`Any =
extern intf `__literal_string__ =
	isa `String

extern struct __internal_not_typeable__ =
extern struct __call_function_slot__ =

extern struct __mutable__ =
extern struct __mercurial__ =

intf `Any =

-- `Prevent_dyn stops the compiler from generating a dyntable for the rest of
-- the isa list.
intf `Prevent_dyn =

intf `Copyable =
	met# Copy_ctor other:@final
intf `Not_copyable =
intf `Copyable_but_owned =
	isa `Copyable -- FIXME
-- FIXME: `Trivial_copy should have other:@this, as it only needs `Any.sizeof.
-- And there should be a copy_slice operation over `Trivial_copy. That's kinda
-- the point.
intf `Trivial_copy =
	isa `Copyable `Trivial_dtor
intf `Trivial_copy_but_owned =
	isa `Trivial_copy -- FIXME
intf `Return_by_copy =
	isa `Trivial_copy
intf `Not_return_by_copy =
intf `Default_ctor =
	met# Ctor
intf `Non_default_ctor =

intf `Default_dtor =
	met# Dtor
intf `Error_dtor =
	met# Dtor = Error

intf `Trivial_ctor =
	isa `Default_ctor
intf `Trivial_dtor =
	isa `Default_dtor

intf `Matchable =
intf `Has_compare =
	-- The relation defined by `Has_compare.Operator_compare may be a partial
	-- order, or maybe not an order, or maybe not even an equality.
	-- `Equality_by_compare and `Ordered_by_compare must be used to indicate what
	-- this relation actually is.
	met Operator_compare other:@final = I32
intf `Trivial_compare =
	isa `Has_compare
intf `Has_equality =
	isa `Matchable
	met Operator_eq other:@final = Bool
	met Operator_ne other:@final = Bool

--	fun exgen n:Uint = final
--	example
--		let a, b = final.exgen 0, final.exgen 0
--		a == b and b == a
--	example
--		let a, b = final.exgen 0, final.exgen 1
--		a != b and b != a

intf `Not_has_equality =
intf `Equality_by_compare =
	-- Compiler generates Operator_{eq,ne}.
	isa `Has_compare `Has_equality
intf `Trivial_equality =
	isa `Trivial_compare `Equality_by_compare

intf `Partially_ordered =
	isa `Has_equality
	met Operator_le other:@final = Bool
	met Operator_lt other:@final = Bool
	met Operator_gt other:@final = Bool
	met Operator_ge other:@final = Bool
intf `Ordered =
	isa `Has_compare `Partially_ordered
intf `Not_ordered =
intf `Ordered_by_compare =
	-- Compiler generates Operator_{le,lt,gt,ge}.
	isa `Has_compare `Ordered
intf `Trivial_order =
	isa `Trivial_compare `Ordered_by_compare
intf `Additive_arithmetic =
	met Operator_plus other:@final = final
	met Operator_minus other:@final = final
	met Operator_uminus = final
intf `Additive_arithmetic_assign =
	isa `Additive_arithmetic
	met! Operator_assign_plus other:@final
	met! Operator_assign_minus other:@final
intf `Arithmetic =
	isa `Additive_arithmetic
	met Operator_divide other:@final = final
	met Operator_times other:@final = final
intf `Arithmetic_assign =
	isa `Arithmetic `Additive_arithmetic_assign
	met! Operator_assign_divide other:@final
	met! Operator_assign_times other:@final
intf `Has_bitwise_operators =
	met Operator_bwor other:@final = final
	met Operator_bwxor other:@final = final
	met Operator_bwand other:@final = final
	met Operator_bwnot = final
intf `Has_bitwise_operators_assign =
	isa `Has_bitwise_operators
	met! Operator_assign_bwor other:@final
	met! Operator_assign_bwxor other:@final
	met! Operator_assign_bwand other:@final
intf `Integer_arithmetic =
	isa `Has_bitwise_operators
	met Operator_modulo other:@final = final
	met Operator_rshift by:Uint = final
	met! Operator_assign_modulo other:@final
	met! Operator_assign_rshift by:Uint
intf `Overflow_arithmetic =
	met Operator_ovplus other:@final = final
	met Operator_ovminus other:@final = final
	met Operator_ovdivide other:@final = final
	met Operator_ovmodulo other:@final = final
	met Operator_ovtimes other:@final = final
	met Operator_ovuminus = final
	met Operator_ovlshift by:Uint = final
	met! Operator_assign_ovplus other:@final
	met! Operator_assign_ovminus other:@final
	met! Operator_assign_ovdivide other:@final
	met! Operator_assign_ovmodulo other:@final
	met! Operator_assign_ovtimes other:@final
	met! Operator_assign_ovlshift by:Uint

intf `Sum_copy =
	isa `Copyable
intf `Sum_equality =
	isa `Has_equality
intf `Sum_order =
	isa `Ordered


extern inline struct Void =
	isa `Prevent_dyn `Return_by_copy `Trivial_copy `Trivial_ctor

extern fun Nonnull_void = @Void

intf `Any_any_ref =
	isa `Return_by_copy `Trivial_copy_but_owned `Trivial_dtor
intf `Any_ref t:`Any =
	isa `Any_any_ref
intf `Any_mutable_ref t:`Any =
	isa (`Any_ref t)
intf `Any_nullable_ref t:`Any =
	isa (`Any_ref t) `Trivial_ctor
intf `Any_nullable_mutable_ref t:`Any =
	isa (`Any_nullable_ref t) (`Any_mutable_ref t)

extern struct Ref t:`Any =
	isa (`Any_ref t)
extern struct Mutable_ref t:`Any =
	isa (`Any_mutable_ref t)
extern struct Mercurial_ref t:`Any =
	isa (`Any_mutable_ref t)

extern struct Nullable_ref t:`Any =
	isa (`Any_nullable_ref t)
extern struct Nullable_mutable_ref t:`Any =
	isa (`Any_nullable_mutable_ref t)
extern struct Nullable_mercurial_ref t:`Any =
	isa (`Any_nullable_mutable_ref t)

-- Builtin primitive. Turned into 'what' if 't isa what'. Otherwise,
-- turned into `Any.
intf `Inherit what:`Any t:`Any =

inline struct Optional t:`Copyable =
	isa
		\ (`Inherit `Return_by_copy t)
		\ (`Inherit `Trivial_copy t)
		\ (`Inherit `Copyable t)
		\ (`Inherit `Trivial_ctor t)
		\ (`Inherit `Default_ctor t)
		\ (`Inherit `Trivial_dtor t)
		\ (`Inherit `Default_dtor t)
	X	:t
	Nonnil	:Bool

-- Uses automagicref on function calls.
inline (fun t:`Any) Take_ref_if_value__ p:@t = @t
	return p

intf `Any_any_slice =
	isa `Trivial_ctor `Trivial_dtor `Return_by_copy `Trivial_copy_but_owned `Show

intf `Any_slice t:`Any =
	isa `Any_any_slice (`Random_container t)
	met Bytecount = Uint
	met Cap = Uint
	met Bytecap = Uint
	met All = Range
	shallow met$ Unsafe_rawdata = @$U8
	shallow met$ Unsafe_data = @$t
	shallow met$ Operator_at n:Uint = @$t
	shallow met$ Operator_sub r:Range = []$t

intf `Any_mutable_slice t:`Any =
	isa (`Any_slice t)
	met! Copy other:[]t = final

-- The body of the methods for Slice and Mutable_slice are actually not used, as
-- Slice_impl is used in codegen for both Slice and Mutable_slice. The code in
-- these functions has only one purpose: triggering the instantiation of the
-- corresponding Slice_impl methods.
-- We will need a better solution down the road, as the code in these bogus
-- methods is All sorts of wrong and is bound to be rejected by the compiler
-- as its bullshit detector improves.
--
-- In reality, it doesn't actually make sense to share the implementations
-- of Slice and Mutable_slice: Slice does not need to carry around a cap
-- field. It's just easier for now as it lets us avoid generating conversion
-- operations between kinds of slices.

opaque struct Slice t:`Any =
	isa (`Any_slice t) -- FIXME missing genarg
	dat	:?@#t
	cnt	:Uint
	cap	:Uint -- will go away

inline Slice fun create_impl_instance = (Slice_impl t)
	return {}
inline Slice met# Unsafe_wrap p:@U8 c:Uint cap:Uint
	let s = this.create_impl_instance
	s#Unsafe_wrap p c cap
inline Slice met Count = Uint
	let s = this.create_impl_instance
	return s.Count
inline Slice met Cap = Uint
	let s = this.create_impl_instance
	return s.Cap
inline Slice met Available = Uint
	let s = this.create_impl_instance
	return s.Available
inline Slice met Bytecount = Uint
	let s = this.create_impl_instance
	return s.Bytecount
inline Slice met Bytecap = Uint
	let s = this.create_impl_instance
	return s.Bytecap
inline Slice met All = Range
	let s = this.create_impl_instance
	return s.All

-- These are shallow wildcard methods because their prototype must match
-- exactly those found in Slice_impl.
inline Slice shallow met$ Unsafe_rawdata = @U8
	let s = this.create_impl_instance
	return s.Unsafe_rawdata
inline Slice shallow met$ Unsafe_data = @t
	let s = this.create_impl_instance
	return s.Unsafe_data
inline Slice shallow met$ Operator_at n:Uint = @t
	let s = this.create_impl_instance
	return s.Operator_at n
inline Slice shallow met$ Operator_sub r:Range = []t
	let s = this.create_impl_instance
	such
		let _ = s.Operator_sub r
	return {}
inline Slice shallow met$ Recapped cap:Uint = this
	let s = this.create_impl_instance
	such
		let _ = s.Recapped cap
	return {}
inline Slice shallow met$ First = @t
	let s = this.create_impl_instance
	return s.First
inline Slice shallow met$ Last = @t
	let s = this.create_impl_instance
	return s.Last
inline Slice met Show st:@#`Fmt_state
	let s = this.create_impl_instance
	such
		s.Show st

opaque struct Mutable_slice t:`Any =
	isa (`Any_mutable_slice t) -- FIXME missing genarg
	dat	:?@#t
	cnt	:Uint
	cap	:Uint

inline Mutable_slice fun create_impl_instance = (Slice_impl t)
	return {}
inline Mutable_slice met# Unsafe_wrap p:@U8 c:Uint cap:Uint
	let s = this.create_impl_instance
	s#Unsafe_wrap p c cap
inline Mutable_slice met Count = Uint
	let s = this.create_impl_instance
	return s.Count
inline Mutable_slice met Cap = Uint
	let s = this.create_impl_instance
	return s.Cap
inline Mutable_slice met Available = Uint
	let s = this.create_impl_instance
	return s.Available
inline Mutable_slice met Bytecount = Uint
	let s = this.create_impl_instance
	return s.Bytecount
inline Mutable_slice met Bytecap = Uint
	let s = this.create_impl_instance
	return s.Bytecap
inline Mutable_slice met All = Range
	let s = this.create_impl_instance
	return s.All
inline Mutable_slice shallow met$ Unsafe_rawdata = @$U8
	let s = this.create_impl_instance
	such
		let _ = s.Unsafe_rawdata
		let _ = s!Unsafe_rawdata
		let _ = s#Unsafe_rawdata
		return s$Unsafe_rawdata
inline Mutable_slice shallow met$ Unsafe_data = @$t
	let s = this.create_impl_instance
	such
		let _ = s.Unsafe_data
		let _ = s!Unsafe_data
		let _ = s#Unsafe_data
		return s$Unsafe_data
inline Mutable_slice shallow met$ Operator_at n:Uint = @$t
	let s = this.create_impl_instance
	such
		let _ = s.Operator_at n
		let _ = s!Operator_at n
		let p = s#Operator_at n
		return s$Operator_at n
inline Mutable_slice met! Full_copy other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Full_copy s
		return {}
inline Mutable_slice met! Copy other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Copy s
		return {}
inline Mutable_slice met! Exact_copy other:this
	let s = this.create_impl_instance
	such
		s!Exact_copy s
inline Mutable_slice met! Append other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Append s
		return {}
inline Mutable_slice shallow met$ Operator_sub r:Range = []$t
	let s = this.create_impl_instance
	such
		let _ = (s.Operator_sub r)
		let _ = (s!Operator_sub r)
		let _ = (s#Operator_sub r)
		return {}
inline Mutable_slice shallow met$ Recapped cap:Uint = this
	let s = this.create_impl_instance
	such
		let _ = (s.Recapped cap)
		let _ = (s!Recapped cap)
		return {}
inline Mutable_slice shallow met$ First = @$t
	let s = this.create_impl_instance
	such
		let _ = s.First
		let _ = s!First
		let p = s#First
		return p
inline Mutable_slice shallow met$ Last = @$t
	let s = this.create_impl_instance
	such
		let _ = s.Last
		let _ = s!Last
		let p = s#Last
		return p
inline Mutable_slice met Show st:@#`Fmt_state
	let s = this.create_impl_instance
	such
		s.Show st

extern inline fun Slice_at_byte dp:@#U8 off:Uint = @#U8
extern inline fun Slice_memmove dst:@#U8 src:@U8 cnt:Uint
extern inline fun Slice_memcmp a:@U8 b:@U8 cnt:Uint = Int
extern inline fun Slice_memset a:@#U8 c:U8 cnt:Uint

inline fun Bytes_compare a:[]U8 b:[]U8 = Int
	let acnt, bcnt = a.Count, b.Count
	let c = Slice_memcmp a.Unsafe_rawdata b.Unsafe_rawdata (Min acnt bcnt)
	if c == 0
		return acnt.Signed - bcnt.Signed
	return c

opaque struct Slice_impl t:`Any =
	isa (`Any_mutable_slice t)
	dat	:?@#t
	cnt	:Uint
	cap	:Uint

inline Slice_impl met# Unsafe_wrap p:@U8 cnt:Uint cap:Uint
	self#dat = (Cast @U8 @#t) p
	self#cnt = cnt
	self#cap = cap

inline Slice_impl met Count = Uint
	return self.cnt

inline Slice_impl met Cap = Uint
	return self.cap

inline Slice_impl met Available = Uint
	return self.Cap - self.Count

inline Slice_impl met Bytecount = Uint
	return (sizeof t) * self.cnt

inline Slice_impl met Bytecap = Uint
	return (sizeof t) * self.cap

inline Slice_impl met All = Range
	return 0 .. self.cnt

inline Slice_impl shallow met$ Unsafe_rawdata = @$U8
	return (Cast ?@$t @$U8) self$dat

inline Slice_impl shallow met$ Unsafe_data = @$t
	return Nonnull_cast self$dat

inline Slice_impl shallow met$ Operator_at n:Uint = r:@$t
	assert n < self.cnt
	let raw = (Cast ?@t @#U8) self.dat
	and off = n * (sizeof t)
	return (Cast @#U8 @$t) <- Slice_at_byte raw off

---- FIXME: the copy operations are only available if the t is `Copyable. We
-- would like that detection to be static. And we would want
-- to allow method arguments whose type require `Copyable, say.

inline Slice_impl met! Full_copy other:this = r:this
	assert t isa `Copyable
	assert self.cap >= other.cnt
	let dst = self!Unsafe_rawdata
	r = {dat=((Cast @#U8 @#t) dst) cnt=other.cnt cap=self.cap}
	if t isa `Trivial_copy
		let src = other.Unsafe_rawdata
		and bytecnt = other.cnt * (sizeof t)
		Slice_memmove dst src bytecnt
	else
		let p_dst = ((Cast @#U8 Voidref) dst).Uintptr
		let p_src = ((Cast @U8 Voidref) other.Unsafe_rawdata).Uintptr
		let bytecnt = other.cnt * (sizeof t)
		if p_dst - p_src >= bytecnt.Uintptr -- Unsigned comparison
			foreach i in r.All
				if t isa `Copyable
					r![i]#Copy_ctor other.[i]
		else
			for i in r.All.Reverse_iter
				if t isa `Copyable
					r![i]#Copy_ctor other.[i]
	return r

-- Copy what it can, and return a slice to the result.
inline Slice_impl met! Copy other:this = this
	let cnt = Min self.cap other.cnt
	return self!Full_copy other.[.. cnt]

inline Slice_impl met! Exact_copy other:this
	assert self.cnt == other.cnt
	let _ = self!Full_copy other

-- Append what it can, and return a slice to the result.
inline Slice_impl met! Append other:this = this
	if other.cnt == 0
		return self.
	let newcnt = self.cnt + other.cnt
	assert newcnt <= self.cap
	let _ = self.[self.cnt .. newcnt]!Copy other
	return {dat=self.Unsafe_data cnt=newcnt cap=self.cap}

inline Slice_impl shallow met$ Operator_sub r:Range = this
	assert r.Begin <= self.cap
	assert r.End <= self.cap
	let newcap = self.cap - r.Begin

	let raw0 = (Cast @U8 @#U8) self.Unsafe_rawdata
	and off = r.Begin * (sizeof t)
	let raw = Slice_at_byte raw0 off
	return {dat=((Cast @#U8 @#t) raw) cnt=r.Count cap=newcap}

inline Slice_impl shallow met$ Recapped cap:Uint = this
	assert cap <= self.cap
	return {dat=self.dat cnt=(Min self.Count cap) cap=cap}

inline Slice_impl shallow met$ First = @$t
	return self$[0]

inline Slice_impl shallow met$ Last = @$t
	return self$[self.cnt - 1]

inline Slice_impl met Show st:@#`Fmt_state
	"{".Show st
	foreach i in self.All
		if i != 0
			" ".Show st
		let x = self.[i]
		if x. isa `Show
			x.Show st
		else
			let px = ((Cast @t Voidref) x).Uintptr
			"<".Show st
			px.Show st
			">".Show st
	"}".Show st

example
	let a = { 0:Uint 1 2 3 4 5 6 7 }
	assert a.Count == 8
	assert a.All == 0 .. 8
	assert a.Unsafe_rawdata === (Cast @Uint @U8) a.Unsafe_data
	foreach i in a.All
		assert a.[i] == i
	assert a.First == 0
	assert a.Last == 7
	assert a.[..].All == a.All
	assert a.[7 ..].Count == 1
	assert a.[7 ..].Cap == 1
	assert a.[7 .. 7].Count == 0
	assert a.[7 .. 7].Cap == 1
	-- OK to create slice of cap 0:
	assert a.[8 .. ].Count == 0
	let b = a.[4 ..]
	foreach i in b.All
		assert b.[i] == a.[4 + i]
	let c = a.[0 .. 4]
	assert c.Cap == a.Cap
	let d = c.Recapped 8
	assert d.Cap == a.Cap
	assert d.Count == c.Count

example
	let ref = { 0:Uint 1 2 3 4 5 6 7 }
	let a = { 0 1 2 3 4 5 6 7 }:[]!Uint such
		let b = a![4 ..]
		foreach i in b.All
			b![i]! = 0

		let suma = 0
		and sumb = 0 such
			foreach x in a.[4 ..]
				suma += x.
			foreach x in b
				sumb += x.
		assert suma == sumb

	let c = { 8 8 8 8 8 8 8 8 }:[]!Uint such
		let d = c!Full_copy ref
		assert d.Count == ref.Count
		assert d.Count == c.Count
		foreach i in c.All
			assert c.[i] == ref.[i]
			assert d.[i] == ref.[i]

	let e = { 8 8 8 8 8 8 8 8 }:[]!Uint such
		let f = e![4 ..] such
			let g = f!Copy ref.[4 ..]
			assert g.Count == 4
			foreach i in g.All
				assert g.[i] == ref.[4 + i]
		let h = e![.. 4] such
			let m = h!Copy ref
			assert m.Count > h.Count
			assert m.Count == ref.Count
			foreach i in m.All
				if i < h.Count
					assert h.[i] == ref.[i]
				assert m.[i] == ref.[i]
			let n = h!Full_copy ref
			assert n.Count == m.Count
	let o = { 8 8 8 8 8 8 8 8 }:[]!Uint such
		o = o#Copy ref
	let p = o.[0 .. 0]
	assert p.Count == 0
	let q = p.[0 .. 8]
	assert q.Count == 8

intf `Numeric =
	isa `Copyable `Arithmetic_assign `Ordered `Show

intf `Number_literal_compatible =
	fun From_number_literal v:String = final

intf `Integer =
	isa `Numeric `Integer_arithmetic `Has_compare `Number_literal_compatible
	fun MIN = final
	fun MAX = final

intf `Signed_integer =
	isa `Integer
	alias This_unsigned = `Unsigned_integer
	met Unsigned = final.This_unsigned
	met Try_unsigned = Error, final.This_unsigned
	met Abs = final.This_unsigned
	met I64 = I64

intf `Unsigned_integer =
	isa `Integer
	alias This_signed = `Signed_integer
	met Signed = final.This_signed
	met Try_signed = Error, final.This_signed
	met U64 = U64

intf `Native =
	isa `Trivial_ctor `Trivial_dtor `Trivial_copy `Trivial_order `Return_by_copy `Hashable32

intf `Native_integer =
	isa `Native `Integer `Show
intf `Native_signed_integer =
	isa `Signed_integer `Native_integer
intf `Native_unsigned_integer =
	isa `Unsigned_integer `Native_integer

intf `Native_sized_signed_integer =
	isa `Native_signed_integer
intf `Native_sized_unsigned_integer =
	isa `Native_unsigned_integer `Overflow_arithmetic

intf `Generalized_boolean =
	isa `Ordered
	met Operator_test = Bool

intf `Bool_compatible =
	fun From_bool b:Bool = final

intf `Native_boolean =
	isa `Native `Generalized_boolean `Bool_compatible `Show

intf `Floating =
	isa `Numeric `Has_compare `Number_literal_compatible
	fun MIN = final
	fun MAX = final
	fun EPSILON = final
	fun SMALLEST_POSITIVE_NORMAL = final
	fun RADIX = Uint
	fun MANTISSA_WIDTH = Uint
	fun MAX_DECIMAL_DIGIT_EXACT = Uint
	fun MIN_EXP = Int
	fun MAX_EXP = Int
	fun MIN_10_EXP = Int
	fun MAX_10_EXP = Int

intf `Native_floating =
	isa `Native `Floating `Show

intf `Enum =
	isa `Trivial_order `Trivial_equality `Trivial_copy `Return_by_copy `Trivial_dtor `Show
	alias Tag_type = `Unsigned_integer

	-- Generated for use by Enumset/Enummap.
	let COUNT:Uint
	let BWALL:U64

	fun From_tag value:final.Tag_type = final
	met Tag = final.Tag_type

intf `Union =
	alias Tag_type = `Integer
	met Tag = final.Tag_type

intf `Union_trivial_ctor =
	isa `Union `Trivial_ctor
	fun From_tag value:final.Tag_type = final

alias Error_range = Error -- FIXME ::|OK|INVAL_RANGE

extern inline struct Bool =
	isa `Native_boolean
extern inline Bool met Operator_eq other:@this = Bool
extern inline Bool met Operator_ne other:@this = Bool
extern inline Bool met Operator_le other:@this = Bool
extern inline Bool met Operator_lt other:@this = Bool
extern inline Bool met Operator_gt other:@this = Bool
extern inline Bool met Operator_ge other:@this = Bool
Bool fun From_bool b:Bool = this
	return b
extern inline Bool met Operator_test = Bool
extern inline Bool met Operator_not = Bool
extern inline Bool met U8 = U8
extern inline Bool met U16 = U16
extern inline Bool met U32 = U32
extern inline Bool met U64 = U64
extern Bool met Show st:@#`Fmt_state
inline Bool met Hash32 = U32
	return self.U32

extern inline struct I8 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U8
inline I8 fun MIN = this
	return -0x80
inline I8 fun MAX = this
	return 0x7f
extern I8 fun From_number_literal v:String = this
extern inline I8 met Operator_eq other:@this = Bool
extern inline I8 met Operator_ne other:@this = Bool
extern inline I8 met Operator_le other:@this = Bool
extern inline I8 met Operator_lt other:@this = Bool
extern inline I8 met Operator_gt other:@this = Bool
extern inline I8 met Operator_ge other:@this = Bool
extern inline I8 met Operator_plus other:@this = this
extern inline I8 met Operator_minus other:@this = this
extern inline I8 met Operator_divide other:@this = this
extern inline I8 met Operator_modulo other:@this = this
extern inline I8 met Operator_times other:@this = this
extern inline I8 met Operator_uminus = this
extern inline I8 met! Operator_assign_plus other:@this
extern inline I8 met! Operator_assign_minus other:@this
extern inline I8 met! Operator_assign_divide other:@this
extern inline I8 met! Operator_assign_modulo other:@this
extern inline I8 met! Operator_assign_times other:@this
extern inline I8 met Operator_bwor other:@this = this
extern inline I8 met Operator_bwxor other:@this = this
extern inline I8 met Operator_bwand other:@this = this
extern inline I8 met Operator_rshift by:Uint = this
extern inline I8 met Operator_bwnot = this
extern inline I8 met! Operator_assign_bwor other:@this
extern inline I8 met! Operator_assign_bwxor other:@this
extern inline I8 met! Operator_assign_bwand other:@this
extern inline I8 met! Operator_assign_rshift by:Uint
inline I8 met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline I8 met Unsigned = U8
	assert self >= 0
	return self.Bitwise_unsigned
inline I8 met Try_unsigned = Error_range, U8
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I8 met Bitwise_unsigned = U8
extern inline I8 met I16 = I16
extern inline I8 met I32 = I32
extern inline I8 met I64 = I64
extern inline I8 met Int = Int
extern inline I8 met U16 = U16
extern inline I8 met U32 = U32
extern inline I8 met U64 = U64
extern inline I8 met Uint = Uint
extern inline I8 met Exact_float = Float
extern inline I8 met Exact_double = Double
extern I8 met Show st:@#`Fmt_state
inline I8 met Hash32 = U32
	return self.Bitwise_unsigned.Hash32

extern inline struct I16 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U16
inline I16 fun MIN = this
	return -0x8000
inline I16 fun MAX = this
	return 0x7fff
extern I16 fun From_number_literal v:String = this
extern inline I16 met Operator_eq other:@this = Bool
extern inline I16 met Operator_ne other:@this = Bool
extern inline I16 met Operator_le other:@this = Bool
extern inline I16 met Operator_lt other:@this = Bool
extern inline I16 met Operator_gt other:@this = Bool
extern inline I16 met Operator_ge other:@this = Bool
extern inline I16 met Operator_plus other:@this = this
extern inline I16 met Operator_minus other:@this = this
extern inline I16 met Operator_divide other:@this = this
extern inline I16 met Operator_modulo other:@this = this
extern inline I16 met Operator_times other:@this = this
extern inline I16 met Operator_uminus = this
extern inline I16 met! Operator_assign_plus other:@this
extern inline I16 met! Operator_assign_minus other:@this
extern inline I16 met! Operator_assign_divide other:@this
extern inline I16 met! Operator_assign_modulo other:@this
extern inline I16 met! Operator_assign_times other:@this
extern inline I16 met Operator_bwor other:@this = this
extern inline I16 met Operator_bwxor other:@this = this
extern inline I16 met Operator_bwand other:@this = this
extern inline I16 met Operator_rshift by:Uint = this
extern inline I16 met Operator_bwnot = this
extern inline I16 met! Operator_assign_bwor other:@this
extern inline I16 met! Operator_assign_bwxor other:@this
extern inline I16 met! Operator_assign_bwand other:@this
extern inline I16 met! Operator_assign_rshift by:Uint
inline I16 met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline I16 met Unsigned = U16
	assert self >= 0
	return self.Bitwise_unsigned
inline I16 met Try_unsigned = Error_range, U16
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I16 met Bitwise_unsigned = U16
extern inline I16 met Trim_i8 = I8
extern inline I16 met I32 = I32
extern inline I16 met I64 = I64
extern inline I16 met Int = Int
extern inline I16 met U32 = U32
extern inline I16 met U64 = U64
extern inline I16 met Uint = Uint
extern inline I16 met Exact_float = Float
extern inline I16 met Exact_double = Double
extern I16 met Show st:@#`Fmt_state
inline I16 met Hash32 = U32
	return self.Bitwise_unsigned.Hash32

extern inline struct I32 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U32
inline I32 fun MIN = this
	return -0x80000000
inline I32 fun MAX = this
	return 0x7fffffff
extern I32 fun From_number_literal v:String = this
extern inline I32 met Operator_eq other:@this = Bool
extern inline I32 met Operator_ne other:@this = Bool
extern inline I32 met Operator_le other:@this = Bool
extern inline I32 met Operator_lt other:@this = Bool
extern inline I32 met Operator_gt other:@this = Bool
extern inline I32 met Operator_ge other:@this = Bool
extern inline I32 met Operator_plus other:@this = this
extern inline I32 met Operator_minus other:@this = this
extern inline I32 met Operator_divide other:@this = this
extern inline I32 met Operator_modulo other:@this = this
extern inline I32 met Operator_times other:@this = this
extern inline I32 met Operator_uminus = this
extern inline I32 met! Operator_assign_plus other:@this
extern inline I32 met! Operator_assign_minus other:@this
extern inline I32 met! Operator_assign_divide other:@this
extern inline I32 met! Operator_assign_modulo other:@this
extern inline I32 met! Operator_assign_times other:@this
extern inline I32 met Operator_bwor other:@this = this
extern inline I32 met Operator_bwxor other:@this = this
extern inline I32 met Operator_bwand other:@this = this
extern inline I32 met Operator_rshift by:Uint = this
extern inline I32 met Operator_bwnot = this
extern inline I32 met! Operator_assign_bwor other:@this
extern inline I32 met! Operator_assign_bwxor other:@this
extern inline I32 met! Operator_assign_bwand other:@this
extern inline I32 met! Operator_assign_rshift by:Uint
inline I32 met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline I32 met Unsigned = U32
	assert self >= 0
	return self.Bitwise_unsigned
inline I32 met Try_unsigned = Error_range, U32
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I32 met Bitwise_unsigned = U32
extern inline I32 met Trim_i8 = I8
extern inline I32 met Trim_i16 = I16
extern inline I32 met I64 = I64
extern inline I32 met Int = Int
extern inline I32 met U64 = U64
extern inline I32 met Uint = Uint
extern inline I32 met Round_float = Float
extern inline I32 met Exact_double = Double
extern I32 met Show st:@#`Fmt_state
inline I32 met Hash32 = U32
	return self.Bitwise_unsigned.Hash32

---- TODO Integer conversions to floats must be extended with:
-- met Try_exact_float = Error_range, Float
-- met Unsafe_exact_float = Float
-- met Bitwise_float = Float

extern inline struct I64 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U64
inline I64 fun MIN = this
	return -0x8000000000000000
inline I64 fun MAX = this
	return 0x7fffffffffffffff
extern I64 fun From_number_literal v:String = this
extern inline I64 met Operator_eq other:@this = Bool
extern inline I64 met Operator_ne other:@this = Bool
extern inline I64 met Operator_le other:@this = Bool
extern inline I64 met Operator_lt other:@this = Bool
extern inline I64 met Operator_gt other:@this = Bool
extern inline I64 met Operator_ge other:@this = Bool
extern inline I64 met Operator_plus other:@this = this
extern inline I64 met Operator_minus other:@this = this
extern inline I64 met Operator_divide other:@this = this
extern inline I64 met Operator_modulo other:@this = this
extern inline I64 met Operator_times other:@this = this
extern inline I64 met Operator_uminus = this
extern inline I64 met! Operator_assign_plus other:@this
extern inline I64 met! Operator_assign_minus other:@this
extern inline I64 met! Operator_assign_divide other:@this
extern inline I64 met! Operator_assign_modulo other:@this
extern inline I64 met! Operator_assign_times other:@this
extern inline I64 met Operator_bwor other:@this = this
extern inline I64 met Operator_bwxor other:@this = this
extern inline I64 met Operator_bwand other:@this = this
extern inline I64 met Operator_rshift by:Uint = this
extern inline I64 met Operator_bwnot = this
extern inline I64 met! Operator_assign_bwor other:@this
extern inline I64 met! Operator_assign_bwxor other:@this
extern inline I64 met! Operator_assign_bwand other:@this
extern inline I64 met! Operator_assign_rshift by:Uint
inline I64 met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline I64 met Unsigned = U64
	assert self >= 0
	return self.Bitwise_unsigned
inline I64 met Try_unsigned = Error_range, U64
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I64 met Bitwise_unsigned = U64
extern inline I64 met Trim_i8 = I8
extern inline I64 met Trim_i16 = I16
extern inline I64 met Trim_i32 = I32
inline I64 met I64 = I64
	return self.
extern inline I64 met force_int = Int
extern inline I64 met force_intptr = Intptr
inline I64 met To_int = Int
	assert self >= Int.MIN.I64 and self <= Int.MAX.I64
	return self.force_int
inline I64 met Try_int = Error_range, Int
	if Likely <- self >= Int.MIN.I64 and self <= Int.MAX.I64
		return OK, self.force_int
	return OK, 0
extern inline I64 met Round_float = Float
extern inline I64 met Round_double = Double
extern I64 met Show st:@#`Fmt_state
inline I64 met Hash32 = U32
	return self.Bitwise_unsigned.Hash32

extern inline struct U8 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I8
inline U8 fun MIN = this
	return 0
inline U8 fun MAX = this
	return 0xff
extern U8 fun From_number_literal v:String = this
extern inline U8 met Operator_eq other:@this = Bool
extern inline U8 met Operator_ne other:@this = Bool
extern inline U8 met Operator_le other:@this = Bool
extern inline U8 met Operator_lt other:@this = Bool
extern inline U8 met Operator_gt other:@this = Bool
extern inline U8 met Operator_ge other:@this = Bool
extern inline U8 met Operator_plus other:@this = this
extern inline U8 met Operator_minus other:@this = this
extern inline U8 met Operator_divide other:@this = this
extern inline U8 met Operator_modulo other:@this = this
extern inline U8 met Operator_times other:@this = this
extern inline U8 met Operator_uminus = this
extern inline U8 met! Operator_assign_plus other:@this
extern inline U8 met! Operator_assign_minus other:@this
extern inline U8 met! Operator_assign_divide other:@this
extern inline U8 met! Operator_assign_modulo other:@this
extern inline U8 met! Operator_assign_times other:@this
extern inline U8 met Operator_ovplus other:@this = this
extern inline U8 met Operator_ovminus other:@this = this
extern inline U8 met Operator_ovdivide other:@this = this
extern inline U8 met Operator_ovmodulo other:@this = this
extern inline U8 met Operator_ovtimes other:@this = this
extern inline U8 met Operator_ovuminus = this
extern inline U8 met! Operator_assign_ovplus other:@this
extern inline U8 met! Operator_assign_ovminus other:@this
extern inline U8 met! Operator_assign_ovdivide other:@this
extern inline U8 met! Operator_assign_ovmodulo other:@this
extern inline U8 met! Operator_assign_ovtimes other:@this
extern inline U8 met Operator_bwor other:@this = this
extern inline U8 met Operator_bwxor other:@this = this
extern inline U8 met Operator_bwand other:@this = this
extern inline U8 met Operator_ovlshift by:Uint = this
extern inline U8 met Operator_rshift by:Uint = this
extern inline U8 met Operator_bwnot = this
extern inline U8 met! Operator_assign_bwor other:@this
extern inline U8 met! Operator_assign_bwxor other:@this
extern inline U8 met! Operator_assign_bwand other:@this
extern inline U8 met! Operator_assign_ovlshift by:Uint
extern inline U8 met! Operator_assign_rshift by:Uint
inline U8 met Signed = I8
	assert self <= I8.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U8 met Try_signed = Error_range, I8
	if Likely <- self <= I8.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U8 met Bitwise_signed = I8
extern inline U8 met U16 = U16
extern inline U8 met U32 = U32
extern inline U8 met U64 = U64
extern inline U8 met Uint = Uint
extern inline U8 met I16 = I16
extern inline U8 met I32 = I32
extern inline U8 met I64 = I64
extern inline U8 met Int = Int
extern inline U8 met Exact_float = Float
extern inline U8 met Exact_double = Double
extern U8 met Show st:@#`Fmt_state
inline U8 met Hash32 = U32
	return self.U32

extern inline struct U16 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I16
inline U16 fun MIN = this
	return 0
inline U16 fun MAX = this
	return 0xffff
extern U16 fun From_number_literal v:String = this
extern inline U16 met Operator_eq other:@this = Bool
extern inline U16 met Operator_ne other:@this = Bool
extern inline U16 met Operator_le other:@this = Bool
extern inline U16 met Operator_lt other:@this = Bool
extern inline U16 met Operator_gt other:@this = Bool
extern inline U16 met Operator_ge other:@this = Bool
extern inline U16 met Operator_plus other:@this = this
extern inline U16 met Operator_minus other:@this = this
extern inline U16 met Operator_divide other:@this = this
extern inline U16 met Operator_modulo other:@this = this
extern inline U16 met Operator_times other:@this = this
extern inline U16 met Operator_uminus = this
extern inline U16 met! Operator_assign_plus other:@this
extern inline U16 met! Operator_assign_minus other:@this
extern inline U16 met! Operator_assign_divide other:@this
extern inline U16 met! Operator_assign_modulo other:@this
extern inline U16 met! Operator_assign_times other:@this
extern inline U16 met Operator_ovplus other:@this = this
extern inline U16 met Operator_ovminus other:@this = this
extern inline U16 met Operator_ovdivide other:@this = this
extern inline U16 met Operator_ovmodulo other:@this = this
extern inline U16 met Operator_ovtimes other:@this = this
extern inline U16 met Operator_ovuminus = this
extern inline U16 met! Operator_assign_ovplus other:@this
extern inline U16 met! Operator_assign_ovminus other:@this
extern inline U16 met! Operator_assign_ovdivide other:@this
extern inline U16 met! Operator_assign_ovmodulo other:@this
extern inline U16 met! Operator_assign_ovtimes other:@this
extern inline U16 met Operator_bwor other:@this = this
extern inline U16 met Operator_bwxor other:@this = this
extern inline U16 met Operator_bwand other:@this = this
extern inline U16 met Operator_ovlshift by:Uint = this
extern inline U16 met Operator_rshift by:Uint = this
extern inline U16 met Operator_bwnot = this
extern inline U16 met! Operator_assign_bwor other:@this
extern inline U16 met! Operator_assign_bwxor other:@this
extern inline U16 met! Operator_assign_bwand other:@this
extern inline U16 met! Operator_assign_ovlshift by:Uint
extern inline U16 met! Operator_assign_rshift by:Uint
inline U16 met Signed = I16
	assert self <= I16.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U16 met Try_signed = Error_range, I16
	if Likely <- self <= I16.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U16 met Bitwise_signed = I16
extern inline U16 met Trim_u8 = U8
extern inline U16 met U32 = U32
extern inline U16 met U64 = U64
extern inline U16 met Uint = Uint
extern inline U16 met I32 = I32
extern inline U16 met I64 = I64
extern inline U16 met Int = Int
extern inline U16 met Exact_float = Float
extern inline U16 met Exact_double = Double
extern U16 met Show st:@#`Fmt_state
inline U16 met Hash32 = U32
	return self.U32

extern inline struct U32 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I32
inline U32 fun MIN = this
	return 0
inline U32 fun MAX = this
	return 0xffffffff
extern U32 fun From_number_literal v:String = this
extern inline U32 met Operator_eq other:@this = Bool
extern inline U32 met Operator_ne other:@this = Bool
extern inline U32 met Operator_le other:@this = Bool
extern inline U32 met Operator_lt other:@this = Bool
extern inline U32 met Operator_gt other:@this = Bool
extern inline U32 met Operator_ge other:@this = Bool
extern inline U32 met Operator_plus other:@this = this
extern inline U32 met Operator_minus other:@this = this
extern inline U32 met Operator_divide other:@this = this
extern inline U32 met Operator_modulo other:@this = this
extern inline U32 met Operator_times other:@this = this
extern inline U32 met Operator_uminus = this
extern inline U32 met! Operator_assign_plus other:@this
extern inline U32 met! Operator_assign_minus other:@this
extern inline U32 met! Operator_assign_divide other:@this
extern inline U32 met! Operator_assign_modulo other:@this
extern inline U32 met! Operator_assign_times other:@this
extern inline U32 met Operator_ovplus other:@this = this
extern inline U32 met Operator_ovminus other:@this = this
extern inline U32 met Operator_ovdivide other:@this = this
extern inline U32 met Operator_ovmodulo other:@this = this
extern inline U32 met Operator_ovtimes other:@this = this
extern inline U32 met Operator_ovuminus = this
extern inline U32 met! Operator_assign_ovplus other:@this
extern inline U32 met! Operator_assign_ovminus other:@this
extern inline U32 met! Operator_assign_ovdivide other:@this
extern inline U32 met! Operator_assign_ovmodulo other:@this
extern inline U32 met! Operator_assign_ovtimes other:@this
extern inline U32 met Operator_bwor other:@this = this
extern inline U32 met Operator_bwxor other:@this = this
extern inline U32 met Operator_bwand other:@this = this
extern inline U32 met Operator_ovlshift by:Uint = this
extern inline U32 met Operator_rshift by:Uint = this
extern inline U32 met Operator_bwnot = this
extern inline U32 met! Operator_assign_bwor other:@this
extern inline U32 met! Operator_assign_bwxor other:@this
extern inline U32 met! Operator_assign_bwand other:@this
extern inline U32 met! Operator_assign_ovlshift by:Uint
extern inline U32 met! Operator_assign_rshift by:Uint
inline U32 met Signed = I32
	assert self <= I32.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U32 met Try_signed = Error_range, I32
	if Likely <- self <= I32.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U32 met Bitwise_signed = I32
extern inline U32 met Trim_u8 = U8
extern inline U32 met Trim_u16 = U16
extern inline U32 met U64 = U64
extern inline U32 met Uint = Uint
extern inline U32 met I64 = I64
extern inline U32 met Int = Int
extern inline U32 met Round_float = Float
extern inline U32 met Exact_double = Double
extern U32 met Show st:@#`Fmt_state
inline U32 met Hash32 = U32
	return self.

extern inline struct U64 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I64
inline U64 fun MIN = this
	return 0
inline U64 fun MAX = this
	return 0xffffffffffffffff
extern U64 fun From_number_literal v:String = this
extern inline U64 met Operator_eq other:@this = Bool
extern inline U64 met Operator_ne other:@this = Bool
extern inline U64 met Operator_le other:@this = Bool
extern inline U64 met Operator_lt other:@this = Bool
extern inline U64 met Operator_gt other:@this = Bool
extern inline U64 met Operator_ge other:@this = Bool
extern inline U64 met Operator_plus other:@this = this
extern inline U64 met Operator_minus other:@this = this
extern inline U64 met Operator_divide other:@this = this
extern inline U64 met Operator_modulo other:@this = this
extern inline U64 met Operator_times other:@this = this
extern inline U64 met Operator_uminus = this
extern inline U64 met! Operator_assign_plus other:@this
extern inline U64 met! Operator_assign_minus other:@this
extern inline U64 met! Operator_assign_divide other:@this
extern inline U64 met! Operator_assign_modulo other:@this
extern inline U64 met! Operator_assign_times other:@this
extern inline U64 met Operator_ovplus other:@this = this
extern inline U64 met Operator_ovminus other:@this = this
extern inline U64 met Operator_ovdivide other:@this = this
extern inline U64 met Operator_ovmodulo other:@this = this
extern inline U64 met Operator_ovtimes other:@this = this
extern inline U64 met Operator_ovuminus = this
extern inline U64 met! Operator_assign_ovplus other:@this
extern inline U64 met! Operator_assign_ovminus other:@this
extern inline U64 met! Operator_assign_ovdivide other:@this
extern inline U64 met! Operator_assign_ovmodulo other:@this
extern inline U64 met! Operator_assign_ovtimes other:@this
extern inline U64 met Operator_bwor other:@this = this
extern inline U64 met Operator_bwxor other:@this = this
extern inline U64 met Operator_bwand other:@this = this
extern inline U64 met Operator_ovlshift by:Uint = this
extern inline U64 met Operator_rshift by:Uint = this
extern inline U64 met Operator_bwnot = this
extern inline U64 met! Operator_assign_bwor other:@this
extern inline U64 met! Operator_assign_bwxor other:@this
extern inline U64 met! Operator_assign_bwand other:@this
extern inline U64 met! Operator_assign_ovlshift by:Uint
extern inline U64 met! Operator_assign_rshift by:Uint
inline U64 met Signed = I64
	assert self <= I64.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U64 met Try_signed = Error_range, I64
	if Likely <- self <= I64.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U64 met Bitwise_signed = I64
extern inline U64 met Trim_u8 = U8
extern inline U64 met Trim_u16 = U16
extern inline U64 met Trim_u32 = U32
inline U64 met U64 = U64
	return self.
extern inline U64 met force_uint = Uint
extern inline U64 met force_uintptr = Uintptr
inline U64 met To_uint = Uint
	assert self <= Uint.MAX.U64
	return self.force_uint
inline U64 met Try_uint = Error_range, Uint
	if Likely <- self <= Uint.MAX.U64
		return OK, self.force_uint
	return INVAL_RANGE, 0
extern inline U64 met Round_float = Float
extern inline U64 met Round_double = Double
extern U64 met Show st:@#`Fmt_state
inline U64 met Hash32 = U32
	let lo = self.Trim_u32
	and hi = (self >> 32).Trim_u32
	-- So that small numbers less than 1<<32 hash to themselves.
	return 31 ov* hi ov+ lo

-- There are no Bitwise_ operations for Int and Uint. Their width is not
-- specified and users are supposed to use explicit conversion through sized
-- types.

extern inline struct Int =
	isa `Native_signed_integer
	alias This_signed = this
	alias This_unsigned = Uint
	alias impl = I64
inline Int fun MIN = this
	return this.impl.MIN.force_int
inline Int fun MAX = this
	return this.impl.MAX.force_int
extern Int fun From_number_literal v:String = this
extern inline Int met Operator_eq other:@this = Bool
extern inline Int met Operator_ne other:@this = Bool
extern inline Int met Operator_le other:@this = Bool
extern inline Int met Operator_lt other:@this = Bool
extern inline Int met Operator_gt other:@this = Bool
extern inline Int met Operator_ge other:@this = Bool
extern inline Int met Operator_plus other:@this = this
extern inline Int met Operator_minus other:@this = this
extern inline Int met Operator_divide other:@this = this
extern inline Int met Operator_modulo other:@this = this
extern inline Int met Operator_times other:@this = this
extern inline Int met Operator_uminus = this
extern inline Int met Operator_rshift by:Uint = final
extern inline Int met! Operator_assign_plus other:@this
extern inline Int met! Operator_assign_minus other:@this
extern inline Int met! Operator_assign_divide other:@this
extern inline Int met! Operator_assign_modulo other:@this
extern inline Int met! Operator_assign_times other:@this
extern inline Int met! Operator_assign_modulo other:@final
extern inline Int met! Operator_assign_rshift by:Uint
extern inline Int met Operator_bwor other:@final = final
extern inline Int met Operator_bwxor other:@final = final
extern inline Int met Operator_bwand other:@final = final
extern inline Int met Operator_bwnot = final
extern inline Int met! Operator_assign_bwor other:@final
extern inline Int met! Operator_assign_bwxor other:@final
extern inline Int met! Operator_assign_bwand other:@final
inline Int met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline Int met Unsigned = Uint
	assert self >= 0
	return self.force_unsigned
inline Int met Try_unsigned = Error_range, Uint
	if Likely <- self >= 0
		return OK, self.force_unsigned
	return INVAL_RANGE, 0
extern inline Int met force_unsigned = Uint
extern inline Int met Trim_i8 = I8
extern inline Int met Trim_i16 = I16
extern inline Int met Trim_i32 = I32
extern inline Int met I64 = I64
inline Int met Intptr = Intptr
	return self.I64.force_intptr
extern inline Int met Round_float = Float
extern inline Int met Round_double = Double
extern Int met Show st:@#`Fmt_state
inline Int met Hash32 = U32
	return self.I64.Hash32

extern inline struct Uint =
	isa `Native_unsigned_integer
	alias This_unsigned = this
	alias This_signed = Int
	alias impl = U64
inline Uint fun MIN = this
	return impl.MIN.force_uint
inline Uint fun MAX = this
	return impl.MAX.force_uint
extern Uint fun From_number_literal v:String = this
extern inline Uint met Operator_eq other:@this = Bool
extern inline Uint met Operator_ne other:@this = Bool
extern inline Uint met Operator_le other:@this = Bool
extern inline Uint met Operator_lt other:@this = Bool
extern inline Uint met Operator_gt other:@this = Bool
extern inline Uint met Operator_ge other:@this = Bool
extern inline Uint met Operator_plus other:@this = this
extern inline Uint met Operator_minus other:@this = this
extern inline Uint met Operator_divide other:@this = this
extern inline Uint met Operator_modulo other:@this = this
extern inline Uint met Operator_times other:@this = this
extern inline Uint met Operator_uminus = this
extern inline Uint met Operator_rshift by:Uint = final
extern inline Uint met! Operator_assign_plus other:@this
extern inline Uint met! Operator_assign_minus other:@this
extern inline Uint met! Operator_assign_divide other:@this
extern inline Uint met! Operator_assign_modulo other:@this
extern inline Uint met! Operator_assign_times other:@this
extern inline Uint met! Operator_assign_rshift by:Uint
extern inline Uint met Operator_bwor other:@final = final
extern inline Uint met Operator_bwxor other:@final = final
extern inline Uint met Operator_bwand other:@final = final
extern inline Uint met Operator_bwnot = final
extern inline Uint met! Operator_assign_bwor other:@final
extern inline Uint met! Operator_assign_bwxor other:@final
extern inline Uint met! Operator_assign_bwand other:@final
inline Uint met Signed = Int
	assert self <= Int.MAX.force_unsigned
	return self.force_signed
inline Uint met Try_signed = Error_range, Int
	if Likely <- self <= Int.MAX.force_unsigned
		return OK, self.force_signed
	return INVAL_RANGE, 0
extern inline Uint met force_signed = Int
extern inline Uint met Trim_u8 = U8
extern inline Uint met Trim_u16 = U16
extern inline Uint met Trim_u32 = U32
extern inline Uint met U64 = U64
inline Uint met Uintptr = Uintptr
	return self.U64.force_uintptr
extern inline Uint met Round_float = Float
extern inline Uint met Round_double = Double
extern Uint met Show st:@#`Fmt_state
inline Uint met Hash32 = U32
	return self.U64.Hash32

extern inline struct Intptr =
	isa `Native_signed_integer
	alias This_unsigned = Uintptr
	alias This_signed = this
	alias impl = I64
inline Intptr fun MIN = this
	return impl.MIN.force_intptr
inline Intptr fun MAX = this
	return impl.MAX.force_intptr
extern Intptr fun From_number_literal v:String = this
extern inline Intptr met Operator_eq other:@this = Bool
extern inline Intptr met Operator_ne other:@this = Bool
extern inline Intptr met Operator_le other:@this = Bool
extern inline Intptr met Operator_lt other:@this = Bool
extern inline Intptr met Operator_gt other:@this = Bool
extern inline Intptr met Operator_ge other:@this = Bool
extern inline Intptr met Operator_plus other:@this = this
extern inline Intptr met Operator_minus other:@this = this
extern inline Intptr met Operator_divide other:@this = this
extern inline Intptr met Operator_modulo other:@this = this
extern inline Intptr met Operator_times other:@this = this
extern inline Intptr met Operator_uminus = this
extern inline Intptr met Operator_rshift by:Uint = final
extern inline Intptr met! Operator_assign_plus other:@this
extern inline Intptr met! Operator_assign_minus other:@this
extern inline Intptr met! Operator_assign_divide other:@this
extern inline Intptr met! Operator_assign_modulo other:@this
extern inline Intptr met! Operator_assign_times other:@this
extern inline Intptr met! Operator_assign_rshift by:Uint
extern inline Intptr met Operator_bwor other:@final = final
extern inline Intptr met Operator_bwxor other:@final = final
extern inline Intptr met Operator_bwand other:@final = final
extern inline Intptr met Operator_bwnot = final
extern inline Intptr met! Operator_assign_bwor other:@final
extern inline Intptr met! Operator_assign_bwxor other:@final
extern inline Intptr met! Operator_assign_bwand other:@final
inline Intptr met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline Intptr met Unsigned = Uintptr
	assert self >= 0
	return self.force_unsigned
inline Intptr met Try_unsigned = Error_range, Uintptr
	if Likely <- self >= 0
		return OK, self.force_unsigned
	return INVAL_RANGE, 0
extern inline Intptr met force_unsigned = Uintptr
extern inline Intptr met I64 = I64
extern Intptr met Show st:@#`Fmt_state
inline Intptr met Hash32 = U32
	return self.I64.Hash32

extern inline struct Uintptr =
	isa `Native_unsigned_integer
	alias This_unsigned = this
	alias This_signed = Intptr
	alias impl = U64
inline Uintptr fun MIN = this
	return impl.MIN.force_uintptr
inline Uintptr fun MAX = this
	return impl.MAX.force_uintptr
extern Uintptr fun From_number_literal v:String = this
extern inline Uintptr met Operator_eq other:@this = Bool
extern inline Uintptr met Operator_ne other:@this = Bool
extern inline Uintptr met Operator_le other:@this = Bool
extern inline Uintptr met Operator_lt other:@this = Bool
extern inline Uintptr met Operator_gt other:@this = Bool
extern inline Uintptr met Operator_ge other:@this = Bool
extern inline Uintptr met Operator_plus other:@this = this
extern inline Uintptr met Operator_minus other:@this = this
extern inline Uintptr met Operator_divide other:@this = this
extern inline Uintptr met Operator_modulo other:@this = this
extern inline Uintptr met Operator_times other:@this = this
extern inline Uintptr met Operator_uminus = this
extern inline Uintptr met Operator_rshift by:Uint = final
extern inline Uintptr met! Operator_assign_plus other:@this
extern inline Uintptr met! Operator_assign_minus other:@this
extern inline Uintptr met! Operator_assign_divide other:@this
extern inline Uintptr met! Operator_assign_modulo other:@this
extern inline Uintptr met! Operator_assign_times other:@this
extern inline Uintptr met! Operator_assign_rshift by:Uint
extern inline Uintptr met Operator_bwor other:@final = final
extern inline Uintptr met Operator_bwxor other:@final = final
extern inline Uintptr met Operator_bwand other:@final = final
extern inline Uintptr met Operator_bwnot = final
extern inline Uintptr met! Operator_assign_bwor other:@final
extern inline Uintptr met! Operator_assign_bwxor other:@final
extern inline Uintptr met! Operator_assign_bwand other:@final
inline Uintptr met Signed = Intptr
	assert self <= Intptr.MAX.force_unsigned
	return self.force_signed
inline Uintptr met Try_signed = Error_range, Intptr
	if Likely <- self <= Intptr.MAX.force_unsigned
		return OK, self.force_signed
	return INVAL_RANGE, 0
extern inline Uintptr met force_signed = Intptr
extern inline Uintptr met U64 = U64
extern Uintptr met Show st:@#`Fmt_state
inline Uintptr met Hash32 = U32
	return self.U64.Hash32

extern inline struct Float =
	isa `Native_floating
extern Float fun From_number_literal v:String = this
extern inline Float fun MIN = this
extern inline Float fun MAX = this
extern inline Float fun EPSILON = this
extern inline Float fun SMALLEST_POSITIVE_NORMAL = this
extern inline Float fun RADIX = Uint
extern inline Float fun MANTISSA_WIDTH = Uint
extern inline Float fun MAX_DECIMAL_DIGIT_EXACT = Uint
extern inline Float fun MIN_EXP = Int
extern inline Float fun MAX_EXP = Int
extern inline Float fun MIN_10_EXP = Int
extern inline Float fun MAX_10_EXP = Int
extern inline Float met Operator_eq other:@this = Bool
extern inline Float met Operator_ne other:@this = Bool
extern inline Float met Operator_le other:@this = Bool
extern inline Float met Operator_lt other:@this = Bool
extern inline Float met Operator_gt other:@this = Bool
extern inline Float met Operator_ge other:@this = Bool
extern inline Float met Operator_plus other:@this = this
extern inline Float met Operator_minus other:@this = this
extern inline Float met Operator_divide other:@this = this
extern inline Float met Operator_times other:@this = this
extern inline Float met Operator_uminus = this
extern inline Float met! Operator_assign_plus other:@this
extern inline Float met! Operator_assign_minus other:@this
extern inline Float met! Operator_assign_divide other:@this
extern inline Float met! Operator_assign_times other:@this
extern inline Float met Round0_i8 = I8
extern inline Float met Round0_i16 = I16
extern inline Float met Round0_i32 = I32
extern inline Float met Round0_i64 = I64
extern inline Float met Double = Double
extern inline Float met Round0_int = Int
extern Float met Show st:@#`Fmt_state
extern inline Float met Bitwise_u32 = U32
inline Float met Hash32 = U32
	return self.Bitwise_u32.Hash32

extern inline struct Double =
	isa `Native_floating
extern Double fun From_number_literal v:String = this
extern inline Double fun MIN = this
extern inline Double fun MAX = this
extern inline Double fun EPSILON = this
extern inline Double fun SMALLEST_POSITIVE_NORMAL = this
extern inline Double fun RADIX = Uint
extern inline Double fun MANTISSA_WIDTH = Uint
extern inline Double fun MAX_DECIMAL_DIGIT_EXACT = Uint
extern inline Double fun MIN_EXP = Int
extern inline Double fun MAX_EXP = Int
extern inline Double fun MIN_10_EXP = Int
extern inline Double fun MAX_10_EXP = Int
extern inline Double met Operator_eq other:@this = Bool
extern inline Double met Operator_ne other:@this = Bool
extern inline Double met Operator_le other:@this = Bool
extern inline Double met Operator_lt other:@this = Bool
extern inline Double met Operator_gt other:@this = Bool
extern inline Double met Operator_ge other:@this = Bool
extern inline Double met Operator_plus other:@this = this
extern inline Double met Operator_minus other:@this = this
extern inline Double met Operator_divide other:@this = this
extern inline Double met Operator_times other:@this = this
extern inline Double met Operator_uminus = this
extern inline Double met! Operator_assign_plus other:@this
extern inline Double met! Operator_assign_minus other:@this
extern inline Double met! Operator_assign_divide other:@this
extern inline Double met! Operator_assign_times other:@this
extern inline Double met Round0_i8 = I8
extern inline Double met Round0_i16 = I16
extern inline Double met Round0_i32 = I32
extern inline Double met Round0_i64 = I64
extern inline Double met Round0_int = Int
-- FIXME Rounding mode is dependent on FP context. Should we provide
-- different alternatives, enforce round-to-nearest (the x86 default)?
-- Have a clear name to a fixed default?
extern inline Double met Round_float = Float
extern Double met Show st:@#`Fmt_state
extern inline Double met Bitwise_u64 = U64
inline Double met Hash32 = U32
	return self.Bitwise_u64.Hash32

inline struct Bounds =
	First	:Bool
	Last	:Bool
	Begin	:Uint
	End	:Uint

inline Bounds (met t:`Any c:(`Random_container t)) Range_of v:@c = Range
	if self.First and self.Last
		return {Begin=0 End=v.Count}
	elif self.First
		return {Begin=0 End=self.End}
	elif self.Last
		return {Begin=self.Begin End=v.Count}
	else
		return {Begin=0 End=v.Count}

inline struct Range =
	isa `Trivial_copy `Trivial_equality `Trivial_ctor `Return_by_copy
		\ (`Collection Uint) `Show
	Begin	:Uint
	End	:Uint

inline Range met Count = Uint
	if self.Begin >= self.End
		return 0
	return self.End - self.Begin

example -> assert ({Begin=1 End=0}:Range).Count == 0

inline Range met Operator_in x:@Uint = Bool
	return x >= self.Begin and x < self.End

inline Range met With_offset offset:Uint = this
	return {Begin=self.Begin+offset End=self.End+offset}

inline Range met All = this
	return self.

inline Range met Operator_at p:Uint = Uint
	return p

inline Range met Operator_sub begin:Uint end:Uint = this
	assert begin >= self.Begin and end <= self.End
	return {Begin=begin End=end}

inline Range met Iter = Index_iterator
	return { r=self. p=self.Begin }

inline Range met Reverse_iter = Reverse_index_iterator
	return { it=self.Iter }

inline Range met First count:Uint = Range
	return {Begin=self.Begin
		\ End=(self.Begin + (Min self.Count count))}

inline Range met Last count:Uint = Range
	return {Begin=(self.End - (Min self.Count count))
		\ End=self.End}

Range met Show st:@#`Fmt_state
	"[".Show st
	self.Begin.Show st
	" .. ".Show st
	self.End.Show st
	"]".Show st

inline struct Index_iterator =
	isa (`Iterator Uint) `Trivial_copy `Trivial_ctor
	r	:Range
	p	:Uint

inline Index_iterator met Has_next = Bool
	return self.p < self.r.End

inline Index_iterator met! Next = Uint
	let nxt = self.p
	self!p += 1
	return nxt

inline struct Reverse_index_iterator =
	isa (`Iterator Uint) `Trivial_copy `Trivial_ctor
	it	:Index_iterator

inline Reverse_index_iterator met Has_next = Bool
	return self.it.Has_next

inline Reverse_index_iterator met! Next = Uint
	let nxt = self!it!Next
	return self.it.r.End - 1 - nxt + self.it.r.Begin

example
	let r = {Begin=2 End=10}:Range
	assert r.Count == 8
	let j = 7 such
		for i in r.Reverse_iter
			assert i >= r.Begin and i < r.End
			assert j == i - r.Begin
			j -= 1

example
	let r = {Begin=10 End=20}:Range
	assert r.Count == 10
	let n = 0 such
		foreach i in r
			assert i >= r.Begin and i < r.End
			assert n == i - r.Begin
			n += 1

intf `Slice_compatible t:`Any =
	fun From_slice c:[]t = final


extern inline (fun$ i:`Any j:`Any) Dyncast x:@$j = ?@$i


extern inline fun Likely x:Bool = Bool
extern inline fun Unlikely x:Bool = Bool

inline (fun t:`Any) Unused x:t
	noop

inline (fun t:`Numeric) Min a:t b:t = t
	if a <= b
		return a
	else
		return b

inline (fun t:`Numeric) Max a:t b:t = t
	if a >= b
		return a
	else
		return b

inline struct Error =
	-- FIXME Two different errors with the same string literal may compare
	-- as equal if the compiler merges the literals. This won't be a
	-- problem once @ are refcounted, there will be no merging then.
	isa `Trivial_order `Show
	Why	:?@String -- FIXME Make it ?@`Show

	let OK = {}:this
	let UNKNOWN = {Why=@"Unknown error"}:this
	let INVAL = {Why=@"invalid value"}:this
	let INVAL_RANGE = {Why=@"invalid value range"}:this

inline Error met Operator_test = Bool
	return self.Why?

Error met Show st:@#`Fmt_state
	if self.Why?
		"Error: ".Show st
		self.Why.Show st
	else
		"Success".Show st

fun Drop err:Error
	noop

fun Fatal err:Error
	Eprn "Fatal:" err
	Abort


extern inline struct Varargint =
	isa `Trivial_copy `Trivial_ctor `Trivial_dtor

extern inline Varargint met Count_left = Uint

intf `no_dyn_iterator r:`Any_any_ref =
	isa `Prevent_dyn (`Iterator r)

opaque struct Vararg r:`Any_any_ref =
	isa (`no_dyn_iterator r)
	isa `Trivial_copy -- FIXME: remove `Trivial_copy, needed by bootstrap
	ap	:Varargint

inline Vararg met Has_next = Bool
	return self.Count_left > 0

extern Vararg met! Next = r

inline Vararg met Count_left = Uint
	return self.ap.Count_left


inline (struct t:`Any) Envheader r:(`Any_ref t) =
	Env	:r
	Parent	:?@#this

(fun t:`Any r:(`Any_ref t)) Internal_globalenv_installed env:r where:@!?@#(Envheader r) where_env:?@#r = Bool
	return where_env. !== nil

(fun t:`Any r:(`Any_ref t)) Internal_globalenv_parent env:r where:@!?@#(Envheader r) where_env:?@#r = r
	return (where!)#Parent#Env

(fun t:`Any r:(`Any_ref t)) Internal_globalenv_install env:r header:@#(Envheader r) where:@!?@#(Envheader r) where_env:?@#r
	header#Parent = where!
	where! = header
	where_env! = header#Env

(fun t:`Any r:(`Any_ref t)) Internal_globalenv_uninstall env:r where:@!?@#(Envheader r) where_env:?@#r
	where! = (where!)#Parent
	if (where!)?
		where_env! = (where!)#Env
	else
		where_env! = nil

-- Rewritten into Internal_* versions by the compiler.
extern (fun t:`Any_any_ref) Globalenv_installed env:t = Bool
extern (fun t:`Any_any_ref) Globalenv_parent env:t = t
extern (fun t:`Any_any_ref) Globalenv_install env:t n:t
extern (fun t:`Any_any_ref) Globalenv_uninstall env:t

--intf `Debugenv =
--  isa (`Environment this)
--  met! _Assert cond:Bool ?expr:?@String
--  met! _pre cond:Bool ?expr:?@String
--  met! _post cond:Bool ?expr:?@String
--  met! _invariant cond:Bool ?expr:?@String
--  met! _example cond:Bool ?expr:?@String
--
--  met! Pr ?sep:?@String ...v:(vararg @`Showable)
--  met! Prn ?sep:?@String ...v:(vararg @`Showable)
--
--struct Debugenv =
--  export isa `Debugenv


--atom identity_transitivity P =
--  forall P, x
--    P x => forall y
--      y === x => P y
--atom equality_transitivity P =
--  identity_transitivity P
--  forall P, x
--    P x => forall y
--      y == x => P y
--
--atom nonnull x =
--  equality_transitivity this
--
--atom has_tag tag x =
--  x ==| tag

inline struct Codeloc =
	File	:String
	Line	:Uint
	Col	:Uint
	Expr	:String

fun Message_at msg:String c:?@Codeloc
	if c?
		Epr sep=':' c.File c.Line c.Col
		Eprn ":" msg "'" c.Expr "'"
	else
		Eprn msg

extern fun abort

fun Abort
	abort

inline fun Assert__ cond:Bool ?_Ncodeloc:?@Codeloc
	if Likely cond
		return
	else
		Message_at "assert failed" _Ncodeloc
		Abort

inline fun Unreached ?_Ncodeloc:?@Codeloc
	Message_at "unreached" _Ncodeloc
	Abort

inline fun Pre__ cond:Bool ?_Ncodeloc:?@Codeloc
	if Likely cond
		return
	else
		Message_at "pre failed" _Ncodeloc
		Abort

inline fun Post__ cond:Bool ?_Ncodeloc:?@Codeloc
	if Likely cond
		return
	else
		Message_at "post failed" _Ncodeloc
		Abort

inline fun Invariant__ cond:Bool ?_Ncodeloc:?@Codeloc
	if Likely cond
		return
	else
		Message_at "invariant failed" _Ncodeloc
		Abort

fun Break
	return
