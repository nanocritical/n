from n.containers import `Iterator `Random_container `Collection `Set `Universal_set
from n.unsafe import Cast Nonnull_cast Voidref
from n import Eprn Epr
import n.reflect
import n.math
import n.mem
import n.logging
import n.env
import n.time
import n.io
import n.bufio
import n.stdio
import n.fs
import n.bench
import n.fmt

extern intf `__literal_nil__ =
	isa `Any_nullable_ref
extern intf `__literal_integer__ =
	isa `Integer
extern intf `__literal_floating__ =
	isa `Floating
extern intf `__literal_slice__ t:`Any =
extern intf `__literal_string__ =
	isa `String

extern struct __internal_not_typeable__ =
extern struct __call_function_slot__ =

extern struct __mutable__ =
extern struct __mercurial__ =

intf `Any =
	-- While all types implement these 2, they return nil if the types
	-- are not exported inline. TODO(e): visibility rules are TBD: it's
	-- debattable whether these numbers should ever be hidden. We could
	-- also make these methods part of a difference interface to
	-- indicate that a type wishes to publish this information.
	fun Sizeof = ?Uint
	fun Alignof = ?Uint

-- `Prevent_dyn stops the compiler from generating a dyntable for the rest of
-- the isa list.
intf `Prevent_dyn =

intf `Copyable =
	met# Copy_ctor other:*final
intf `Not_copyable =
intf `Copyable_but_owned =
	isa `Copyable -- FIXME

-- TODO(e): Declaring something like `Trivial_move is essentially unsafe in
-- general. Therefore we should split the two concepts: isa declarations
-- that are purely (optional) confirmations -- autointf still does its job,
-- and checks that its inferences are consistent with the isa declaration;
-- and isa declarations that are autointf overrides. We will therefore have
-- `Trivial_move and unsafe.`Trivial_move, etc.

-- TODO(e): There should be a Copy_slice operation over `Trivial_copy.
-- That's kinda the point.
intf `Trivial_copy =
	isa `Copyable `Trivial_dtor `Trivial_move
intf `Trivial_copy_but_owned =
	isa `Trivial_copy -- FIXME
intf `Return_by_copy =
	isa `Trivial_copy
intf `Not_return_by_copy =

intf `Moveable =
	met# Move = final
intf `Not_moveable =
intf `Trivial_move =
	isa `Moveable

intf `Default_ctor =
	met# Ctor
intf `Non_default_ctor =

intf `Default_dtor =
	met# Dtor
intf `Error_dtor =
	met# Dtor = Error

intf `Trivial_ctor =
	isa `Default_ctor
intf `Trivial_dtor =
	isa `Default_dtor

intf `Matchable =
intf `Has_compare =
	-- The relation defined by `Has_compare.Operator_compare may be a partial
	-- order, or maybe not an order, or maybe not even an equality.
	-- `Equality_by_compare and `Ordered_by_compare must be used to indicate what
	-- this relation actually is.
	met Operator_compare other:*final = I32
intf `Trivial_compare =
	isa `Has_compare
intf `Has_equality =
	isa `Matchable
	met Operator_eq other:*final = Bool
	met Operator_ne other:*final = Bool

--	fun exgen n:Uint = final
--	example
--		let a, b = final.exgen 0, final.exgen 0
--		a == b and b == a
--	example
--		let a, b = final.exgen 0, final.exgen 1
--		a != b and b != a

intf `Not_has_equality =
intf `Equality_by_compare =
	-- Compiler generates Operator_{eq,ne}.
	isa `Has_compare `Has_equality
intf `Trivial_equality =
	isa `Trivial_compare `Equality_by_compare

-- Remember that it is possible for
--	not a < b and not b < a
-- Using `Partially_ordered requires some thought. Typically, any of these
-- operations returning false is not informative.
intf `Partially_ordered =
	isa `Has_equality
	met Operator_le other:*final = Bool
	met Operator_lt other:*final = Bool
	met Operator_gt other:*final = Bool
	met Operator_ge other:*final = Bool
intf `Ordered =
	isa `Partially_ordered
intf `Not_ordered =
intf `Ordered_by_compare =
	-- Compiler generates Operator_{le,lt,gt,ge}.
	isa `Has_compare `Ordered
intf `Trivial_order =
	isa `Trivial_equality `Trivial_compare `Ordered
intf `Additive_arithmetic =
	met Operator_plus other:*final = final
	met Operator_minus other:*final = final
	met Operator_uminus = final
intf `Additive_arithmetic_assign =
	isa `Additive_arithmetic
	met! Operator_assign_plus other:*final
	met! Operator_assign_minus other:*final
intf `Arithmetic =
	isa `Additive_arithmetic
	met Operator_divide other:*final = final
	met Operator_times other:*final = final
intf `Arithmetic_assign =
	isa `Arithmetic `Additive_arithmetic_assign
	met! Operator_assign_divide other:*final
	met! Operator_assign_times other:*final
intf `Has_bitwise_operators =
	met Operator_bwor other:*final = final
	met Operator_bwxor other:*final = final
	met Operator_bwand other:*final = final
	met Operator_bwnot = final
intf `Has_bitwise_operators_assign =
	isa `Has_bitwise_operators
	met! Operator_assign_bwor other:*final
	met! Operator_assign_bwxor other:*final
	met! Operator_assign_bwand other:*final
intf `Integer_arithmetic =
	isa `Has_bitwise_operators
	met Operator_modulo other:*final = final
	met Operator_rshift by:Uint = final
	met! Operator_assign_modulo other:*final
	met! Operator_assign_rshift by:Uint
intf `Overflow_arithmetic =
	met Operator_ovplus other:*final = final
	met Operator_ovminus other:*final = final
	met Operator_ovdivide other:*final = final
	met Operator_ovmodulo other:*final = final
	met Operator_ovtimes other:*final = final
	met Operator_ovuminus = final
	met Operator_ovlshift by:Uint = final
	met! Operator_assign_ovplus other:*final
	met! Operator_assign_ovminus other:*final
	met! Operator_assign_ovdivide other:*final
	met! Operator_assign_ovmodulo other:*final
	met! Operator_assign_ovtimes other:*final
	met! Operator_assign_ovlshift by:Uint

intf `Sum_copy =
	isa `Copyable
intf `Sum_equality =
	isa `Has_equality
intf `Sum_order =
	isa `Ordered


extern inline struct Void =
	isa `Prevent_dyn `Return_by_copy `Trivial_copy `Trivial_ctor

extern fun Nonnil_void = *Void

intf `Any_any_ref =
	isa `Return_by_copy `Trivial_copy_but_owned `Trivial_dtor
intf `Any_ref t:`Any =
	isa `Any_any_ref
intf `Any_mutable_ref t:`Any =
	isa (`Any_ref t)
intf `Any_nullable_ref t:`Any =
	isa (`Any_ref t) `Trivial_ctor
intf `Any_nullable_mutable_ref t:`Any =
	isa (`Any_nullable_ref t) (`Any_mutable_ref t)

extern struct Ref t:`Any =
	isa (`Any_ref t)
extern struct Mutable_ref t:`Any =
	isa (`Any_mutable_ref t)
extern struct Mercurial_ref t:`Any =
	isa (`Any_mutable_ref t)

extern struct Nullable_ref t:`Any =
	isa (`Any_nullable_ref t)
extern struct Nullable_mutable_ref t:`Any =
	isa (`Any_nullable_mutable_ref t)
extern struct Nullable_mercurial_ref t:`Any =
	isa (`Any_nullable_mutable_ref t)

-- Builtin primitive* Turned into 'what' if 't isa what'* Otherwise,
-- turned into `Any.
intf `Inherit what:`Any t:`Any =

-- FIXME(e): ???syscall.Fd is not instantiable.

inline struct Optional t:`Copyable =
	isa (`Inherit `Return_by_copy t)
	X	:t
	Nonnil	:Bool

-- Uses automagicref on function calls.
inline (fun t:`Any) Take_ref_if_value__ p:*t = *t
	return p

intf `Any_any_slice =
	isa `Trivial_ctor `Trivial_dtor `Return_by_copy `Trivial_copy_but_owned `Show

intf `Any_slice t:`Any =
	isa `Any_any_slice (`Random_container t)
		\ `Has_equality -- FIXME(e): use `Inherit
	met Bytecount = Uint
	met Cap = Uint
	met Bytecap = Uint
	met All = Range
	shallow met$ Unsafe_rawdata = ?$U8
	shallow met$ Unsafe_data = ?$t
	shallow met$ Operator_at n:Uint = $t
	shallow met$ Operator_sub r:Range = [$]t

intf `Any_mutable_slice t:`Any =
	isa (`Any_slice t)
	met! Copy_from other:[]t = final

-- The body of the methods for Slice and Mutable_slice are actually not used, as
-- Slice_impl is used in codegen for both Slice and Mutable_slice* The code in
-- these functions has only one purpose: triggering the instantiation of the
-- corresponding Slice_impl methods.
-- We will need a better solution down the road, as the code in these bogus
-- methods is All sorts of wrong and is bound to be rejected by the compiler
-- as its bullshit detector improves.
--
-- In reality, it doesn't actually make sense to share the implementations
-- of Slice and Mutable_slice: Slice does not need to carry around a cap
-- field* It's just easier for now as it lets us avoid generating conversion
-- operations between kinds of slices.

opaque struct Slice t:`Any =
	isa (`Any_slice t) -- FIXME missing genarg
	dat	:?#t
	cnt	:Uint
	cap	:Uint -- will go away

inline Slice fun create_impl_instance = r:(Slice_impl t)
	assert false -- Better not actually get called!
	-- Ensure visibility of dyns too.
	let d:*(`Any_slice t)
	d = *r
inline Slice fun From_slice c:[]t = this
	return {}
inline Slice met# Unsafe_wrap p:*U8 c:Uint cap:Uint
	let s = this.create_impl_instance
	s#Unsafe_wrap p c cap
inline Slice met Count = Uint
	let s = this.create_impl_instance
	return s.Count
inline Slice met Cap = Uint
	let s = this.create_impl_instance
	return s.Cap
inline Slice met Available = Uint
	let s = this.create_impl_instance
	return s.Available
inline Slice met Bytecount = Uint
	let s = this.create_impl_instance
	return s.Bytecount
inline Slice met Bytecap = Uint
	let s = this.create_impl_instance
	return s.Bytecap
inline Slice met All = Range
	let s = this.create_impl_instance
	return s.All
inline Slice met Rawbytes = []U8
	let s = this.create_impl_instance
	return s.Rawbytes

-- These are shallow wildcard methods because their prototype must match
-- exactly those found in Slice_impl.
inline Slice shallow met$ Unsafe_rawdata = ?*U8
	let s = this.create_impl_instance
	return s.Unsafe_rawdata
inline Slice shallow met$ Unsafe_data = ?*t
	let s = this.create_impl_instance
	return s.Unsafe_data
inline Slice shallow met$ Operator_at n:Uint = *t
	let s = this.create_impl_instance
	return s.Operator_at n
inline Slice shallow met$ Operator_sub r:Range = []t
	let s = this.create_impl_instance
	such
		let _ = s.Operator_sub r
	return {}
inline Slice shallow met$ Recapped cap:Uint = this
	let s = this.create_impl_instance
	such
		let _ = s.Recapped cap
	return {}
inline Slice shallow met$ First = *t
	let s = this.create_impl_instance
	return s.First
inline Slice shallow met$ Last = *t
	let s = this.create_impl_instance
	return s.Last
inline Slice met Show st:#`Fmt_state
	let s = this.create_impl_instance
	such
		s.Show st
inline Slice met Operator_eq other:*this = Bool
	let s = this.create_impl_instance
	return s == s
inline Slice met Operator_ne other:*this = Bool
	let s = this.create_impl_instance
	return s != s
inline Slice met Overlap other:this = ?(Intptr, Intptr)
	let s = this.create_impl_instance
	such
		let _ = s.Overlap s
		return {}

opaque struct Mutable_slice t:`Any =
	isa (`Any_mutable_slice t) -- FIXME missing genarg
	dat	:?#t
	cnt	:Uint
	cap	:Uint

inline Mutable_slice fun create_impl_instance = r:(Slice_impl t)
	assert false -- Better not actually get called!
	let d:*(`Any_slice t)
	d = *r
inline Mutable_slice fun From_slice c:[]t = this
	return {}
inline Mutable_slice met# Unsafe_wrap p:*U8 c:Uint cap:Uint
	let s = this.create_impl_instance
	s#Unsafe_wrap p c cap
inline Mutable_slice met Count = Uint
	let s = this.create_impl_instance
	return s.Count
inline Mutable_slice met Cap = Uint
	let s = this.create_impl_instance
	return s.Cap
inline Mutable_slice met Available = Uint
	let s = this.create_impl_instance
	return s.Available
inline Mutable_slice met Bytecount = Uint
	let s = this.create_impl_instance
	return s.Bytecount
inline Mutable_slice met Bytecap = Uint
	let s = this.create_impl_instance
	return s.Bytecap
inline Mutable_slice met All = Range
	let s = this.create_impl_instance
	return s.All
inline Mutable_slice met$ Rawbytes = [$]U8
	let s = this.create_impl_instance
	return s$Rawbytes
inline Mutable_slice shallow met$ Unsafe_rawdata = ?$U8
	let s = this.create_impl_instance
	such
		let _ = s.Unsafe_rawdata
		let _ = s!Unsafe_rawdata
		let _ = s#Unsafe_rawdata
		return s$Unsafe_rawdata
inline Mutable_slice shallow met$ Unsafe_data = ?$t
	let s = this.create_impl_instance
	such
		let _ = s.Unsafe_data
		let _ = s!Unsafe_data
		let _ = s#Unsafe_data
		return s$Unsafe_data
inline Mutable_slice shallow met$ Operator_at n:Uint = $t
	let s = this.create_impl_instance
	such
		let _ = s.Operator_at n
		let _ = s!Operator_at n
		let p = s#Operator_at n
		return s$Operator_at n
inline Mutable_slice met! Clear
	let s = this.create_impl_instance
	such
		s!Clear
		return {}
inline Mutable_slice met Overlap other:this = ?(Intptr, Intptr)
	let s = this.create_impl_instance
	such
		let _ = s.Overlap s
		return {}
inline Mutable_slice met! Full_copy other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Full_copy s
		return {}
inline Mutable_slice met! Copy_from other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Copy_from s
		return {}
inline Mutable_slice met! Exact_copy other:[]t
	let s = this.create_impl_instance
	such
		s!Exact_copy s
inline Mutable_slice met! Full_move other:[!]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Full_move s
		return {}
inline Mutable_slice met! Move_from other:[!]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Move_from s
		return {}
inline Mutable_slice met! Exact_move other:[!]t
	let s = this.create_impl_instance
	such
		s!Exact_move s
inline Mutable_slice met! Append other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Append s
		return {}
inline Mutable_slice met! Full_append other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Full_append s
		return {}
inline Mutable_slice shallow met$ Operator_sub r:Range = [$]t
	let s = this.create_impl_instance
	such
		let _ = (s.Operator_sub r)
		let _ = (s!Operator_sub r)
		let _ = (s#Operator_sub r)
		return {}
-- FIXME(e): Deprecated. But ncc0 doesn't actually support wildcard slices.
inline Mutable_slice met Const = []t
	let s = this.create_impl_instance
	such
		let _ = s.Const
	return {}
inline Mutable_slice met! Available_capacity = this
	let s = this.create_impl_instance
	such
		let _ = s!Available_capacity
	return {}
inline Mutable_slice met! Available_elements = this
	let s = this.create_impl_instance
	such
		let _ = s!Available_elements
	return {}
inline Mutable_slice shallow met$ Recapped cap:Uint = this
	let s = this.create_impl_instance
	such
		let _ = (s.Recapped cap)
		let _ = (s!Recapped cap)
		return {}
inline Mutable_slice shallow met$ First = $t
	let s = this.create_impl_instance
	such
		let _ = s.First
		let _ = s!First
		let p = s#First
		return p
inline Mutable_slice shallow met$ Last = $t
	let s = this.create_impl_instance
	such
		let _ = s.Last
		let _ = s!Last
		let p = s#Last
		return p
inline Mutable_slice met Show st:#`Fmt_state
	let s = this.create_impl_instance
	such
		s.Show st
inline Mutable_slice met Operator_eq other:*this = Bool
	let s = this.create_impl_instance
	return s == s
inline Mutable_slice met Operator_ne other:*this = Bool
	let s = this.create_impl_instance
	return s != s

extern inline fun Slice_at_byte dp:#U8 off:Uint = #U8
extern inline fun Slice_memmove dst:#U8 src:*U8 cnt:Uint
extern inline fun Slice_memcmp a:*U8 b:*U8 cnt:Uint = Int
extern inline fun Slice_memset a:#U8 c:U8 cnt:Uint

inline fun Bytes_compare a:[]U8 b:[]U8 = Int
	let acnt, bcnt = a.Count, b.Count
	let c = Slice_memcmp a.Unsafe_rawdata b.Unsafe_rawdata (Min acnt bcnt)
	if c == 0
		return acnt.Signed - bcnt.Signed
	return c

opaque struct Slice_impl t:`Any =
	isa (`Any_mutable_slice t)
	dat	:?#t
	cnt	:Uint
	cap	:Uint

inline Slice_impl fun From_slice c:[]t = this
	return {dat=c.dat cnt=c.cnt cap=c.cap}

inline Slice_impl met# Unsafe_wrap p:*U8 cnt:Uint cap:Uint
	self#dat = (Cast *U8 #t) p
	self#cnt = cnt
	self#cap = cap

inline Slice_impl met Count = Uint
	return self.cnt

inline Slice_impl met Cap = Uint
	return self.cap

inline Slice_impl met Available = Uint
	return self.Cap - self.Count

inline Slice_impl met Bytecount = Uint
	return (sizeof t) * self.cnt

inline Slice_impl met Bytecap = Uint
	return (sizeof t) * self.cap

inline Slice_impl met All = Range
	return 0 .. self.cnt

inline Slice_impl met$ Rawbytes = [$]U8
	return {dat=((Cast ?$t #U8) self$dat) cnt=self.Bytecount cap=self.Bytecap}

inline Slice_impl shallow met$ Unsafe_rawdata = ?$U8
	return (Cast ?$t ?$U8) self$dat

inline Slice_impl shallow met$ Unsafe_data = ?$t
	return self$dat

inline Slice_impl shallow met$ Operator_at n:Uint = r:$t
	assert n < self.cnt
	let raw = (Cast ?*t #U8) self.dat
	and off = n * (sizeof t)
	return (Cast #U8 $t) <- Slice_at_byte raw off

inline Slice_impl met! Clear
	assert t isa `Default_dtor
	if t isa `Trivial_dtor
		let dst = self.Unsafe_rawdata
		and bytecnt = self.cnt * (sizeof t)
		Slice_memset dst 0 bytecnt
	else
		foreach i over self.All
			if t isa `Default_dtor
				self![i]#Dtor

-- Note on the C implementation:
--
-- In pedantic C, pointers can only be compared if they point into the same
-- aggregate. This means that Overlap is well-defined only if we already know
-- something about the slices ability to overlap, which is a little besides the
-- point.
--
-- Internally, we use a conversion via a Intptr and signed comparisons thereon.
--
-- We do want to make sure we don't get hit by undefined-behavior optimizations
-- in the C compiler, though, so we perform the overlap computations inside a
-- non-inline function on *U8. This is probably unnecessarily paranoid. But
-- just because you're paranoid doesn't mean that an optimizing compiler is not
-- trying to fuck with your code.
extern fun Slice_overlap a:*U8 acnt:Uint acap:Uint b:*U8 bcnt:Uint bcap:Uint = Bool, Intptr, Intptr

inline Slice_impl met Overlap other:this = ?(Intptr, Intptr)
	let comparable, left, right
		\ = Slice_overlap self.Unsafe_rawdata self.Bytecount self.Bytecap
			\ other.Unsafe_rawdata other.Bytecount other.Bytecap
	if not comparable
		return nil
	return left/(sizeof t).Signed.Intptr, right/(sizeof t).Signed.Intptr

example overlap
	let s = {0 1 2 3 4}:[]Uint
	assert (0, 0) == s.Overlap s
	assert (1, -1) == s.Overlap s.[1 .. 4]
	assert (-1, 1) == s.[1 .. 4].Overlap s
	assert (1, 1) == s.[0 .. 1].Overlap s.[1 .. 2]
	assert (-1, -1) == s.[1 .. 2].Overlap s.[0 .. 1]

	let t = {8 9}:[]Uint
	assert not (s.Overlap t)?
	assert not (t.Overlap s)?

---- FIXME: the copy operations are only available if the t is `Copyable* We
-- would like that detection to be static* And we would want
-- to allow method arguments whose type require `Copyable, say.

inline Slice_impl met! Full_copy other:this = r:this
	assert t isa `Copyable
	assert self.cap >= other.cnt

	if self.dat === other.dat
		-- Nothing to copy, same memory.
		return {dat=self.dat cnt=other.cnt cap=self.cap}

	let dst = self!Unsafe_rawdata
	r = {dat=((Cast #U8 #t) dst) cnt=other.cnt cap=self.cap}
	if t isa `Trivial_copy
		let src = other.Unsafe_rawdata
		and bytecnt = other.cnt * (sizeof t)
		Slice_memmove dst src bytecnt
	else
		let p_dst = (Voidref.From_ptr dst).Uintptr
		let p_src = (Voidref.From_ptr other.Unsafe_rawdata).Uintptr
		let bytecnt = other.cnt * (sizeof t)
		if p_dst - p_src >= bytecnt.Uintptr -- Unsigned comparison
			foreach i over r.All
				if t isa `Copyable -- To appease the compiler.
					r![i]#Copy_ctor other.[i]
		else
			for i over r.All.Reverse_iter
				if t isa `Copyable -- To appease the compiler.
					r![i]#Copy_ctor other.[i]
	return r

-- Copy what it can, and return a slice to the result.
inline Slice_impl met! Copy_from other:this = this
	let cnt = Min self.cap other.cnt
	return self!Full_copy other.[.. cnt]

inline Slice_impl met! Exact_copy other:this
	assert self.cnt == other.cnt
	let _ = self!Full_copy other

-- Fall back to copy if not `Moveable, clears/dtor the source.
inline Slice_impl met! Full_move other:this = r:this
	assert self.cap >= other.cnt

	if self.dat === other.dat
		return {dat=self.dat cnt=other.cnt cap=self.cap}

	if t isa `Moveable
		let dst = self!Unsafe_rawdata
		r = {dat=((Cast #U8 #t) dst) cnt=other.cnt cap=self.cap}
		if t isa `Trivial_copy
			-- Includes `Trivial_move case.
			let src = other!Unsafe_rawdata
			and bytecnt = other.cnt * (sizeof t)
			Slice_memmove dst src bytecnt

			let p_dst = (Voidref.From_ptr dst).Uintptr
			let p_src = (Voidref.From_ptr other.Unsafe_rawdata).Uintptr
			if p_dst - p_src >= bytecnt.Uintptr -- Unsigned comparison
				Slice_memset src 0 bytecnt
			else
				if p_src < p_dst and p_src+bytecnt.Uintptr >= p_dst
					Slice_memset src 0 (p_dst - p_src).U64.To_uint
				elif p_dst < p_src and p_dst+bytecnt.Uintptr >= p_src
					let cnt_pre_overlap = p_src - p_dst
					let end_overlap = p_dst + bytecnt.Uintptr
					let start_zero = (Voidref.From_uintptr end_overlap)#Unsafe_cast #U8
					let cnt_post_overlap = cnt_pre_overlap
					Slice_memset start_zero 0 cnt_post_overlap.U64.To_uint
				else
					Slice_memset src 0 bytecnt
		else
			let p_dst = (Voidref.From_ptr dst).Uintptr
			let p_src = (Voidref.From_ptr other.Unsafe_rawdata).Uintptr
			let bytecnt = other.cnt * (sizeof t)
			if p_dst - p_src >= bytecnt.Uintptr -- Unsigned comparison
				foreach i over r.All
					if t isa `Moveable -- To appease the compiler.
						r![i]# = other![i]#Move
			else
				for i over r.All.Reverse_iter
					if t isa `Moveable -- To appease the compiler.
						r![i]# = other![i]#Move
		return r
	else
		assert t isa `Copyable
		let dst = self!Unsafe_rawdata
		r = {dat=((Cast #U8 #t) dst) cnt=other.cnt cap=self.cap}

		let p_dst = (Voidref.From_ptr dst).Uintptr
		let p_src = (Voidref.From_ptr other.Unsafe_rawdata).Uintptr
		let bytecnt = other.cnt * (sizeof t)
		if p_dst - p_src >= bytecnt.Uintptr -- Unsigned comparison
			foreach i over r.All
				if t isa `Copyable -- To appease the compiler.
					r![i]#Copy_ctor other.[i]
				if t isa `Default_dtor
					other![i]#Dtor
				else
					assert false
		else
			for i over r.All.Reverse_iter
				let e = r![i]
				if t isa `Copyable -- To appease the compiler.
					r![i]#Copy_ctor other.[i]
				if t isa `Default_dtor
					other![i]#Dtor
				else
					assert false
		return r

-- Move what it can, and return a slice to the result.
inline Slice_impl met! Move_from other:this = this
	let cnt = Min self.cap other.cnt
	return self!Full_move other.[.. cnt]

inline Slice_impl met! Exact_move other:this
	assert self.cnt == other.cnt
	let _ = self!Full_move other

-- Append what it can, and return a slice to the result.
inline Slice_impl met! Append other:this = this
	let r = self!Available_elements!Copy_from other
	return {dat=self.dat cnt=self.cnt+r.cnt cap=self.cap}

-- Append all, and return a slice to the result.
inline Slice_impl met! Full_append other:this = this
	let r = self!Available_elements!Full_copy other
	return {dat=self.dat cnt=self.cnt+r.cnt cap=self.cap}

inline Slice_impl shallow met$ Operator_sub r:Range = this
	assert r.Begin <= self.cap
	assert r.End <= self.cap
	let newcap = self.cap - r.Begin

	let raw0 = (Cast *U8 #U8) self.Unsafe_rawdata
	and off = r.Begin * (sizeof t)
	let raw = Slice_at_byte raw0 off
	return {dat=((Cast #U8 #t) raw) cnt=r.Count cap=newcap}

inline Slice_impl met Const = []t
	return {dat=self.dat cnt=self.cnt cap=self.cap}

inline Slice_impl met! Available_capacity = this
	return self.[self.Count .. self.Count]

inline Slice_impl met! Available_elements = this
	return self.[self.Count .. self.Cap]

inline Slice_impl shallow met$ Recapped cap:Uint = this
	assert cap <= self.cap
	return {dat=self.dat cnt=(Min self.Count cap) cap=cap}

inline Slice_impl shallow met$ First = $t
	return self$[0]

inline Slice_impl shallow met$ Last = $t
	return self$[self.cnt - 1]

inline (fun t:`Any) generic_show st:#`Fmt_state x:*t
	if t isa `Show
		x.Show st
	elif t isa Optional
		if not (x*)?
			"(nil)".Show st
		else
			"?".Show st
			generic_show st (x* else {})
	elif t isa (`Any_nullable_ref `Any)
		if not (x*)?
			"(nil)".Show st
		else
			generic_show st x*
	elif t isa `Any_any_ref
		generic_show st x*
	else
		let px = (Voidref.From_ptr x).Uintptr
		"<".Show st
		px.Show st
		">".Show st

inline Slice_impl met Show st:#`Fmt_state
	"{".Show st
	foreach i over self.All
		if i != 0
			" ".Show st
		let x = self.[i]
		(generic_show t) st x
	"}".Show st

inline Slice_impl met Operator_eq other:*this = Bool
	if t isa `Trivial_equality
		return 0 == Bytes_compare self.Rawbytes other.Rawbytes
	elif t isa `Has_equality
		if self.Count != other.Count
			return false
		foreach i over self.All
			if self.[i] != other.[i]
				return false
		return true
	else
		assert false
		return false

inline Slice_impl met Operator_ne other:*this = Bool
	if t isa `Has_equality
		return not self == other
	else
		assert false
		return false

example
	let a = { 0:Uint 1 2 3 4 5 6 7 }
	assert a.Count == 8
	assert a.All == 0 .. 8
	assert a.Unsafe_rawdata === (Cast *Uint ?*U8) a.Unsafe_data
	foreach i over a.All
		assert a.[i] == i
	assert a.First == 0
	assert a.Last == 7
	assert a.[..].All == a.All
	assert a.[7 ..].Count == 1
	assert a.[7 ..].Cap == 1
	assert a.[7 .. 7].Count == 0
	assert a.[7 .. 7].Cap == 1
	-- OK to create slice of cap 0:
	assert a.[8 ..].Count == 0
	let b = a.[4 ..]
	foreach i over b.All
		assert b.[i] == a.[4 + i]
	let c = a.[0 .. 4]
	assert c.Cap == a.Cap
	let d = c.Recapped 8
	assert d.Cap == a.Cap
	assert d.Count == c.Count

example
	let ref = { 0:Uint 1 2 3 4 5 6 7 }
	let a = { 0 1 2 3 4 5 6 7 }:[!]Uint such
		let b = a![4 ..]
		foreach i over b.All
			b![i]! = 0

		let suma = 0
		and sumb = 0 such
			foreach x over a.[4 ..]
				suma += x*
			foreach x over b
				sumb += x*
		assert suma == sumb

	let c = { 8 8 8 8 8 8 8 8 }:[!]Uint such
		let d = c!Full_copy ref
		assert d.Count == ref.Count
		assert d.Count == c.Count
		foreach i over c.All
			assert c.[i] == ref.[i]
			assert d.[i] == ref.[i]

	let e = { 8 8 8 8 8 8 8 8 }:[!]Uint such
		let f = e![4 ..] such
			let g = f!Copy_from ref.[4 ..]
			assert g.Count == 4
			foreach i over g.All
				assert g.[i] == ref.[4 + i]
		let h = e![.. 4] such
			let m = h!Copy_from ref
			assert m.Count > h.Count
			assert m.Count == ref.Count
			foreach i over m.All
				if i < h.Count
					assert h.[i] == ref.[i]
				assert m.[i] == ref.[i]
			let n = h!Full_copy ref
			assert n.Count == m.Count
	let o = { 8 8 8 8 8 8 8 8 }:[!]Uint such
		o = o#Copy_from ref
	let p = o.[0 .. 0]
	assert p.Count == 0
	let q = p.[0 .. 8]
	assert q.Count == 8

intf `Numeric =
	isa `Copyable `Arithmetic_assign `Ordered `Show

intf `Number_literal_compatible =
	fun From_number_literal v:String = final

intf `Integer =
	isa `Numeric `Integer_arithmetic `Has_compare `Number_literal_compatible
	fun MIN = final
	fun MAX = final

intf `Signed_integer =
	isa `Integer
	alias This_unsigned = `Unsigned_integer
	met Unsigned = final.This_unsigned
	met Try_unsigned = Error, final.This_unsigned
	met Abs = final.This_unsigned
	met I64 = I64

intf `Unsigned_integer =
	isa `Integer
	alias This_signed = `Signed_integer
	met Signed = final.This_signed
	met Try_signed = Error, final.This_signed
	met U64 = U64

intf `Native =
	isa `Trivial_ctor `Trivial_dtor `Trivial_copy `Trivial_equality `Trivial_order `Return_by_copy `Hashable32

intf `Native_integer =
	isa `Native `Integer `Show
intf `Native_signed_integer =
	isa `Signed_integer `Native_integer
intf `Native_unsigned_integer =
	isa `Unsigned_integer `Native_integer

intf `Native_sized_signed_integer =
	isa `Native_signed_integer
intf `Native_sized_unsigned_integer =
	isa `Native_unsigned_integer `Overflow_arithmetic

intf `Generalized_boolean =
	isa `Ordered
	met Operator_test = Bool

intf `Bool_compatible =
	fun From_bool b:Bool = final

intf `Native_boolean =
	isa `Native `Generalized_boolean `Bool_compatible `Show

inline enum Floating_class =
	-- Values must be equal to libc's.
	| NAN = 0
	| INFINITE = 1
	| ZERO = 2
	| SUBNORMAL = 3
	| NORMAL = 4

intf `Floating =
	isa `Numeric `Has_compare `Number_literal_compatible
	fun MIN = final
	fun MAX = final
	fun EPSILON = final
	fun SMALLEST_POSITIVE_NORMAL = final
	fun RADIX = Uint
	fun MANTISSA_WIDTH = Uint
	fun MAX_DECIMAL_DIGIT_EXACT = Uint
	fun MIN_EXP = Int
	fun MAX_EXP = Int
	fun MIN_10_EXP = Int
	fun MAX_10_EXP = Int

intf `Native_floating =
	isa `Native `Floating `Show

intf `Enum =
	isa `Trivial_order `Trivial_equality `Trivial_copy `Return_by_copy `Trivial_dtor `Show
	alias Tag_type = `Unsigned_integer

	-- Generated for use by Enumset/Enummap.
	let COUNT:Uint
	let BWALL:U64

	fun From_tag value:final.Tag_type = final
	met Tag = final.Tag_type

intf `Union =
	alias Tag_type = `Integer
	met Tag = final.Tag_type

-- TODO(e): Could make this work with non-trivial `Default_ctor as well.
intf `Union_from_tag_ctor =
	isa `Union `Trivial_ctor
	fun From_tag value:final.Tag_type = final

alias Error_range = Error -- FIXME ::|OK|INVAL_RANGE

extern inline struct Bool =
	isa `Native_boolean
extern inline Bool met Operator_eq other:*this = Bool
extern inline Bool met Operator_ne other:*this = Bool
extern inline Bool met Operator_le other:*this = Bool
extern inline Bool met Operator_lt other:*this = Bool
extern inline Bool met Operator_gt other:*this = Bool
extern inline Bool met Operator_ge other:*this = Bool
Bool fun From_bool b:Bool = this
	return b
extern inline Bool met Operator_test = Bool
extern inline Bool met Operator_not = Bool
extern inline Bool met U8 = U8
extern inline Bool met U16 = U16
extern inline Bool met U32 = U32
extern inline Bool met U64 = U64
extern Bool met Show st:#`Fmt_state
inline Bool met Hash32 = U32
	return self.U32

extern inline struct I8 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U8
inline I8 fun MIN = this
	return -0x80
inline I8 fun MAX = this
	return 0x7f
extern I8 fun From_number_literal v:String = this
extern inline I8 met Operator_eq other:*this = Bool
extern inline I8 met Operator_ne other:*this = Bool
extern inline I8 met Operator_le other:*this = Bool
extern inline I8 met Operator_lt other:*this = Bool
extern inline I8 met Operator_gt other:*this = Bool
extern inline I8 met Operator_ge other:*this = Bool
extern inline I8 met Operator_plus other:*this = this
extern inline I8 met Operator_minus other:*this = this
extern inline I8 met Operator_divide other:*this = this
extern inline I8 met Operator_modulo other:*this = this
extern inline I8 met Operator_times other:*this = this
extern inline I8 met Operator_uminus = this
extern inline I8 met! Operator_assign_plus other:*this
extern inline I8 met! Operator_assign_minus other:*this
extern inline I8 met! Operator_assign_divide other:*this
extern inline I8 met! Operator_assign_modulo other:*this
extern inline I8 met! Operator_assign_times other:*this
extern inline I8 met Operator_bwor other:*this = this
extern inline I8 met Operator_bwxor other:*this = this
extern inline I8 met Operator_bwand other:*this = this
extern inline I8 met Operator_rshift by:Uint = this
extern inline I8 met Operator_bwnot = this
extern inline I8 met! Operator_assign_bwor other:*this
extern inline I8 met! Operator_assign_bwxor other:*this
extern inline I8 met! Operator_assign_bwand other:*this
extern inline I8 met! Operator_assign_rshift by:Uint
inline I8 met Abs = this
	if self >= 0
		return self*
	else
		return -self*
inline I8 met Unsigned = U8
	assert self >= 0
	return self.Bitwise_unsigned
inline I8 met Try_unsigned = Error_range, U8
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I8 met Bitwise_unsigned = U8
extern inline I8 met I16 = I16
extern inline I8 met I32 = I32
extern inline I8 met I64 = I64
extern inline I8 met Int = Int
extern inline I8 met U16 = U16
extern inline I8 met U32 = U32
extern inline I8 met U64 = U64
extern inline I8 met Uint = Uint
extern inline I8 met Exact_float = Float
extern inline I8 met Exact_double = Double
extern I8 met Show st:#`Fmt_state
inline I8 met Hash32 = U32
	return self.Bitwise_unsigned.Hash32

extern inline struct I16 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U16
inline I16 fun MIN = this
	return -0x8000
inline I16 fun MAX = this
	return 0x7fff
extern I16 fun From_number_literal v:String = this
extern inline I16 met Operator_eq other:*this = Bool
extern inline I16 met Operator_ne other:*this = Bool
extern inline I16 met Operator_le other:*this = Bool
extern inline I16 met Operator_lt other:*this = Bool
extern inline I16 met Operator_gt other:*this = Bool
extern inline I16 met Operator_ge other:*this = Bool
extern inline I16 met Operator_plus other:*this = this
extern inline I16 met Operator_minus other:*this = this
extern inline I16 met Operator_divide other:*this = this
extern inline I16 met Operator_modulo other:*this = this
extern inline I16 met Operator_times other:*this = this
extern inline I16 met Operator_uminus = this
extern inline I16 met! Operator_assign_plus other:*this
extern inline I16 met! Operator_assign_minus other:*this
extern inline I16 met! Operator_assign_divide other:*this
extern inline I16 met! Operator_assign_modulo other:*this
extern inline I16 met! Operator_assign_times other:*this
extern inline I16 met Operator_bwor other:*this = this
extern inline I16 met Operator_bwxor other:*this = this
extern inline I16 met Operator_bwand other:*this = this
extern inline I16 met Operator_rshift by:Uint = this
extern inline I16 met Operator_bwnot = this
extern inline I16 met! Operator_assign_bwor other:*this
extern inline I16 met! Operator_assign_bwxor other:*this
extern inline I16 met! Operator_assign_bwand other:*this
extern inline I16 met! Operator_assign_rshift by:Uint
inline I16 met Abs = this
	if self >= 0
		return self*
	else
		return -self*
inline I16 met Unsigned = U16
	assert self >= 0
	return self.Bitwise_unsigned
inline I16 met Try_unsigned = Error_range, U16
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I16 met Bitwise_unsigned = U16
extern inline I16 met Trim_i8 = I8
extern inline I16 met I32 = I32
extern inline I16 met I64 = I64
extern inline I16 met Int = Int
extern inline I16 met U32 = U32
extern inline I16 met U64 = U64
extern inline I16 met Uint = Uint
extern inline I16 met Exact_float = Float
extern inline I16 met Exact_double = Double
extern I16 met Show st:#`Fmt_state
inline I16 met Hash32 = U32
	return self.Bitwise_unsigned.Hash32

extern inline struct I32 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U32
inline I32 fun MIN = this
	return -0x80000000
inline I32 fun MAX = this
	return 0x7fffffff
extern I32 fun From_number_literal v:String = this
extern inline I32 met Operator_eq other:*this = Bool
extern inline I32 met Operator_ne other:*this = Bool
extern inline I32 met Operator_le other:*this = Bool
extern inline I32 met Operator_lt other:*this = Bool
extern inline I32 met Operator_gt other:*this = Bool
extern inline I32 met Operator_ge other:*this = Bool
extern inline I32 met Operator_plus other:*this = this
extern inline I32 met Operator_minus other:*this = this
extern inline I32 met Operator_divide other:*this = this
extern inline I32 met Operator_modulo other:*this = this
extern inline I32 met Operator_times other:*this = this
extern inline I32 met Operator_uminus = this
extern inline I32 met! Operator_assign_plus other:*this
extern inline I32 met! Operator_assign_minus other:*this
extern inline I32 met! Operator_assign_divide other:*this
extern inline I32 met! Operator_assign_modulo other:*this
extern inline I32 met! Operator_assign_times other:*this
extern inline I32 met Operator_bwor other:*this = this
extern inline I32 met Operator_bwxor other:*this = this
extern inline I32 met Operator_bwand other:*this = this
extern inline I32 met Operator_rshift by:Uint = this
extern inline I32 met Operator_bwnot = this
extern inline I32 met! Operator_assign_bwor other:*this
extern inline I32 met! Operator_assign_bwxor other:*this
extern inline I32 met! Operator_assign_bwand other:*this
extern inline I32 met! Operator_assign_rshift by:Uint
inline I32 met Abs = this
	if self >= 0
		return self*
	else
		return -self*
inline I32 met Unsigned = U32
	assert self >= 0
	return self.Bitwise_unsigned
inline I32 met Try_unsigned = Error_range, U32
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I32 met Bitwise_unsigned = U32
extern inline I32 met Trim_i8 = I8
extern inline I32 met Trim_i16 = I16
extern inline I32 met I64 = I64
extern inline I32 met Int = Int
extern inline I32 met U64 = U64
extern inline I32 met Uint = Uint
extern inline I32 met Round_float = Float
extern inline I32 met Exact_double = Double
extern I32 met Show st:#`Fmt_state
inline I32 met Hash32 = U32
	return self.Bitwise_unsigned.Hash32

---- TODO Integer conversions to floats must be extended with:
-- met Try_exact_float = Error_range, Float
-- met Unsafe_exact_float = Float
-- met Bitwise_float = Float

extern inline struct I64 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U64
inline I64 fun MIN = this
	return -0x8000000000000000
inline I64 fun MAX = this
	return 0x7fffffffffffffff
extern I64 fun From_number_literal v:String = this
extern inline I64 met Operator_eq other:*this = Bool
extern inline I64 met Operator_ne other:*this = Bool
extern inline I64 met Operator_le other:*this = Bool
extern inline I64 met Operator_lt other:*this = Bool
extern inline I64 met Operator_gt other:*this = Bool
extern inline I64 met Operator_ge other:*this = Bool
extern inline I64 met Operator_plus other:*this = this
extern inline I64 met Operator_minus other:*this = this
extern inline I64 met Operator_divide other:*this = this
extern inline I64 met Operator_modulo other:*this = this
extern inline I64 met Operator_times other:*this = this
extern inline I64 met Operator_uminus = this
extern inline I64 met! Operator_assign_plus other:*this
extern inline I64 met! Operator_assign_minus other:*this
extern inline I64 met! Operator_assign_divide other:*this
extern inline I64 met! Operator_assign_modulo other:*this
extern inline I64 met! Operator_assign_times other:*this
extern inline I64 met Operator_bwor other:*this = this
extern inline I64 met Operator_bwxor other:*this = this
extern inline I64 met Operator_bwand other:*this = this
extern inline I64 met Operator_rshift by:Uint = this
extern inline I64 met Operator_bwnot = this
extern inline I64 met! Operator_assign_bwor other:*this
extern inline I64 met! Operator_assign_bwxor other:*this
extern inline I64 met! Operator_assign_bwand other:*this
extern inline I64 met! Operator_assign_rshift by:Uint
inline I64 met Abs = this
	if self >= 0
		return self*
	else
		return -self*
inline I64 met Unsigned = U64
	assert self >= 0
	return self.Bitwise_unsigned
inline I64 met Try_unsigned = Error_range, U64
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I64 met Bitwise_unsigned = U64
extern inline I64 met Trim_i8 = I8
extern inline I64 met Trim_i16 = I16
extern inline I64 met Trim_i32 = I32
inline I64 met I64 = I64
	return self*
extern inline I64 met force_int = Int
extern inline I64 met force_intptr = Intptr
inline I64 met To_int = Int
	assert self >= Int.MIN.I64 and self <= Int.MAX.I64
	return self.force_int
inline I64 met Try_int = Error_range, Int
	if Likely <- self >= Int.MIN.I64 and self <= Int.MAX.I64
		return OK, self.force_int
	return OK, 0
extern inline I64 met Round_float = Float
extern inline I64 met Round_double = Double
extern I64 met Show st:#`Fmt_state
inline I64 met Hash32 = U32
	return self.Bitwise_unsigned.Hash32

extern inline struct U8 =
	isa `Native_sized_unsigned_integer `String_compatible
	alias This_unsigned = this
	alias This_signed = I8
inline U8 fun MIN = this
	return 0
inline U8 fun MAX = this
	return 0xff
extern U8 fun From_number_literal v:String = this
inline U8 fun From_string s:String = this
	assert s.Count == 1
	return s.[0]
extern inline U8 met Operator_eq other:*this = Bool
extern inline U8 met Operator_ne other:*this = Bool
extern inline U8 met Operator_le other:*this = Bool
extern inline U8 met Operator_lt other:*this = Bool
extern inline U8 met Operator_gt other:*this = Bool
extern inline U8 met Operator_ge other:*this = Bool
extern inline U8 met Operator_plus other:*this = this
extern inline U8 met Operator_minus other:*this = this
extern inline U8 met Operator_divide other:*this = this
extern inline U8 met Operator_modulo other:*this = this
extern inline U8 met Operator_times other:*this = this
extern inline U8 met Operator_uminus = this
extern inline U8 met! Operator_assign_plus other:*this
extern inline U8 met! Operator_assign_minus other:*this
extern inline U8 met! Operator_assign_divide other:*this
extern inline U8 met! Operator_assign_modulo other:*this
extern inline U8 met! Operator_assign_times other:*this
extern inline U8 met Operator_ovplus other:*this = this
extern inline U8 met Operator_ovminus other:*this = this
extern inline U8 met Operator_ovdivide other:*this = this
extern inline U8 met Operator_ovmodulo other:*this = this
extern inline U8 met Operator_ovtimes other:*this = this
extern inline U8 met Operator_ovuminus = this
extern inline U8 met! Operator_assign_ovplus other:*this
extern inline U8 met! Operator_assign_ovminus other:*this
extern inline U8 met! Operator_assign_ovdivide other:*this
extern inline U8 met! Operator_assign_ovmodulo other:*this
extern inline U8 met! Operator_assign_ovtimes other:*this
extern inline U8 met Operator_bwor other:*this = this
extern inline U8 met Operator_bwxor other:*this = this
extern inline U8 met Operator_bwand other:*this = this
extern inline U8 met Operator_ovlshift by:Uint = this
extern inline U8 met Operator_rshift by:Uint = this
extern inline U8 met Operator_bwnot = this
extern inline U8 met! Operator_assign_bwor other:*this
extern inline U8 met! Operator_assign_bwxor other:*this
extern inline U8 met! Operator_assign_bwand other:*this
extern inline U8 met! Operator_assign_ovlshift by:Uint
extern inline U8 met! Operator_assign_rshift by:Uint
inline U8 met Signed = I8
	assert self <= I8.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U8 met Try_signed = Error_range, I8
	if Likely <- self <= I8.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U8 met Bitwise_signed = I8
extern inline U8 met U16 = U16
extern inline U8 met U32 = U32
extern inline U8 met U64 = U64
extern inline U8 met Uint = Uint
extern inline U8 met I16 = I16
extern inline U8 met I32 = I32
extern inline U8 met I64 = I64
extern inline U8 met Int = Int
extern inline U8 met Exact_float = Float
extern inline U8 met Exact_double = Double
extern U8 met Show st:#`Fmt_state
inline U8 met Hash32 = U32
	return self.U32.Hash32

extern inline struct U16 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I16
inline U16 fun MIN = this
	return 0
inline U16 fun MAX = this
	return 0xffff
extern U16 fun From_number_literal v:String = this
extern inline U16 met Operator_eq other:*this = Bool
extern inline U16 met Operator_ne other:*this = Bool
extern inline U16 met Operator_le other:*this = Bool
extern inline U16 met Operator_lt other:*this = Bool
extern inline U16 met Operator_gt other:*this = Bool
extern inline U16 met Operator_ge other:*this = Bool
extern inline U16 met Operator_plus other:*this = this
extern inline U16 met Operator_minus other:*this = this
extern inline U16 met Operator_divide other:*this = this
extern inline U16 met Operator_modulo other:*this = this
extern inline U16 met Operator_times other:*this = this
extern inline U16 met Operator_uminus = this
extern inline U16 met! Operator_assign_plus other:*this
extern inline U16 met! Operator_assign_minus other:*this
extern inline U16 met! Operator_assign_divide other:*this
extern inline U16 met! Operator_assign_modulo other:*this
extern inline U16 met! Operator_assign_times other:*this
extern inline U16 met Operator_ovplus other:*this = this
extern inline U16 met Operator_ovminus other:*this = this
extern inline U16 met Operator_ovdivide other:*this = this
extern inline U16 met Operator_ovmodulo other:*this = this
extern inline U16 met Operator_ovtimes other:*this = this
extern inline U16 met Operator_ovuminus = this
extern inline U16 met! Operator_assign_ovplus other:*this
extern inline U16 met! Operator_assign_ovminus other:*this
extern inline U16 met! Operator_assign_ovdivide other:*this
extern inline U16 met! Operator_assign_ovmodulo other:*this
extern inline U16 met! Operator_assign_ovtimes other:*this
extern inline U16 met Operator_bwor other:*this = this
extern inline U16 met Operator_bwxor other:*this = this
extern inline U16 met Operator_bwand other:*this = this
extern inline U16 met Operator_ovlshift by:Uint = this
extern inline U16 met Operator_rshift by:Uint = this
extern inline U16 met Operator_bwnot = this
extern inline U16 met! Operator_assign_bwor other:*this
extern inline U16 met! Operator_assign_bwxor other:*this
extern inline U16 met! Operator_assign_bwand other:*this
extern inline U16 met! Operator_assign_ovlshift by:Uint
extern inline U16 met! Operator_assign_rshift by:Uint
inline U16 met Signed = I16
	assert self <= I16.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U16 met Try_signed = Error_range, I16
	if Likely <- self <= I16.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U16 met Bitwise_signed = I16
extern inline U16 met Trim_u8 = U8
extern inline U16 met U32 = U32
extern inline U16 met U64 = U64
extern inline U16 met Uint = Uint
extern inline U16 met I32 = I32
extern inline U16 met I64 = I64
extern inline U16 met Int = Int
extern inline U16 met Exact_float = Float
extern inline U16 met Exact_double = Double
extern U16 met Show st:#`Fmt_state
inline U16 met Hash32 = U32
	return self.U32.Hash32

extern inline struct U32 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I32
inline U32 fun MIN = this
	return 0
inline U32 fun MAX = this
	return 0xffffffff
extern U32 fun From_number_literal v:String = this
extern inline U32 met Operator_eq other:*this = Bool
extern inline U32 met Operator_ne other:*this = Bool
extern inline U32 met Operator_le other:*this = Bool
extern inline U32 met Operator_lt other:*this = Bool
extern inline U32 met Operator_gt other:*this = Bool
extern inline U32 met Operator_ge other:*this = Bool
extern inline U32 met Operator_plus other:*this = this
extern inline U32 met Operator_minus other:*this = this
extern inline U32 met Operator_divide other:*this = this
extern inline U32 met Operator_modulo other:*this = this
extern inline U32 met Operator_times other:*this = this
extern inline U32 met Operator_uminus = this
extern inline U32 met! Operator_assign_plus other:*this
extern inline U32 met! Operator_assign_minus other:*this
extern inline U32 met! Operator_assign_divide other:*this
extern inline U32 met! Operator_assign_modulo other:*this
extern inline U32 met! Operator_assign_times other:*this
extern inline U32 met Operator_ovplus other:*this = this
extern inline U32 met Operator_ovminus other:*this = this
extern inline U32 met Operator_ovdivide other:*this = this
extern inline U32 met Operator_ovmodulo other:*this = this
extern inline U32 met Operator_ovtimes other:*this = this
extern inline U32 met Operator_ovuminus = this
extern inline U32 met! Operator_assign_ovplus other:*this
extern inline U32 met! Operator_assign_ovminus other:*this
extern inline U32 met! Operator_assign_ovdivide other:*this
extern inline U32 met! Operator_assign_ovmodulo other:*this
extern inline U32 met! Operator_assign_ovtimes other:*this
extern inline U32 met Operator_bwor other:*this = this
extern inline U32 met Operator_bwxor other:*this = this
extern inline U32 met Operator_bwand other:*this = this
extern inline U32 met Operator_ovlshift by:Uint = this
extern inline U32 met Operator_rshift by:Uint = this
extern inline U32 met Operator_bwnot = this
extern inline U32 met! Operator_assign_bwor other:*this
extern inline U32 met! Operator_assign_bwxor other:*this
extern inline U32 met! Operator_assign_bwand other:*this
extern inline U32 met! Operator_assign_ovlshift by:Uint
extern inline U32 met! Operator_assign_rshift by:Uint
inline U32 met Signed = I32
	assert self <= I32.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U32 met Try_signed = Error_range, I32
	if Likely <- self <= I32.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U32 met Bitwise_signed = I32
extern inline U32 met Trim_u8 = U8
extern inline U32 met Trim_u16 = U16
extern inline U32 met U64 = U64
extern inline U32 met Uint = Uint
extern inline U32 met I64 = I64
extern inline U32 met Int = Int
extern inline U32 met Round_float = Float
extern inline U32 met Exact_double = Double
extern U32 met Show st:#`Fmt_state
inline U32 met Hash32 = U32
	-- Bob Jenkins, full avalanching.
	-- Public Domain.
	-- http://burtleburtle.net/bob/hash/integer.html
	var a = self*
	a = (a ov+ 0x7ed55d16) ov+ (a ov<< 12)
	a = (a ^ 0xc761c23c) ^ (a >> 19)
	a = (a ov+ 0x165667b1) ov+ (a ov<< 5)
	a = (a ov+ 0xd3a2646c) ^ (a ov<< 9)
	a = (a ov+ 0xfd7046c5) ov+ (a ov<< 3)
	a = (a ^ 0xb55a4f09) ^ (a >> 16)
	return a

extern inline struct U64 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I64
inline U64 fun MIN = this
	return 0
inline U64 fun MAX = this
	return 0xffffffffffffffff
extern U64 fun From_number_literal v:String = this
extern inline U64 met Operator_eq other:*this = Bool
extern inline U64 met Operator_ne other:*this = Bool
extern inline U64 met Operator_le other:*this = Bool
extern inline U64 met Operator_lt other:*this = Bool
extern inline U64 met Operator_gt other:*this = Bool
extern inline U64 met Operator_ge other:*this = Bool
extern inline U64 met Operator_plus other:*this = this
extern inline U64 met Operator_minus other:*this = this
extern inline U64 met Operator_divide other:*this = this
extern inline U64 met Operator_modulo other:*this = this
extern inline U64 met Operator_times other:*this = this
extern inline U64 met Operator_uminus = this
extern inline U64 met! Operator_assign_plus other:*this
extern inline U64 met! Operator_assign_minus other:*this
extern inline U64 met! Operator_assign_divide other:*this
extern inline U64 met! Operator_assign_modulo other:*this
extern inline U64 met! Operator_assign_times other:*this
extern inline U64 met Operator_ovplus other:*this = this
extern inline U64 met Operator_ovminus other:*this = this
extern inline U64 met Operator_ovdivide other:*this = this
extern inline U64 met Operator_ovmodulo other:*this = this
extern inline U64 met Operator_ovtimes other:*this = this
extern inline U64 met Operator_ovuminus = this
extern inline U64 met! Operator_assign_ovplus other:*this
extern inline U64 met! Operator_assign_ovminus other:*this
extern inline U64 met! Operator_assign_ovdivide other:*this
extern inline U64 met! Operator_assign_ovmodulo other:*this
extern inline U64 met! Operator_assign_ovtimes other:*this
extern inline U64 met Operator_bwor other:*this = this
extern inline U64 met Operator_bwxor other:*this = this
extern inline U64 met Operator_bwand other:*this = this
extern inline U64 met Operator_ovlshift by:Uint = this
extern inline U64 met Operator_rshift by:Uint = this
extern inline U64 met Operator_bwnot = this
extern inline U64 met! Operator_assign_bwor other:*this
extern inline U64 met! Operator_assign_bwxor other:*this
extern inline U64 met! Operator_assign_bwand other:*this
extern inline U64 met! Operator_assign_ovlshift by:Uint
extern inline U64 met! Operator_assign_rshift by:Uint
inline U64 met Signed = I64
	assert self <= I64.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U64 met Try_signed = Error_range, I64
	if Likely <- self <= I64.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U64 met Bitwise_signed = I64
extern inline U64 met Trim_u8 = U8
extern inline U64 met Trim_u16 = U16
extern inline U64 met Trim_u32 = U32
inline U64 met U64 = U64
	return self*
extern inline U64 met force_uint = Uint
extern inline U64 met force_uintptr = Uintptr
inline U64 met To_uint = Uint
	assert self <= Uint.MAX.U64
	return self.force_uint
inline U64 met Try_uint = Error_range, Uint
	if Likely <- self <= Uint.MAX.U64
		return OK, self.force_uint
	return INVAL_RANGE, 0
extern inline U64 met Round_float = Float
extern inline U64 met Round_double = Double
extern U64 met Show st:#`Fmt_state
inline U64 met Hash32 = U32
	let lo = self.Trim_u32.Hash32
	and hi = (self >> 32).Trim_u32.Hash32
	return hi ^ lo

-- There are no Bitwise_ operations for Int and Uint* Their width is not
-- specified and users are supposed to use explicit conversion through sized
-- types.

extern inline struct Int =
	isa `Native_signed_integer
	alias This_signed = this
	alias This_unsigned = Uint
	alias impl = I64
inline Int fun MIN = this
	return this.impl.MIN.force_int
inline Int fun MAX = this
	return this.impl.MAX.force_int
extern Int fun From_number_literal v:String = this
extern inline Int met Operator_eq other:*this = Bool
extern inline Int met Operator_ne other:*this = Bool
extern inline Int met Operator_le other:*this = Bool
extern inline Int met Operator_lt other:*this = Bool
extern inline Int met Operator_gt other:*this = Bool
extern inline Int met Operator_ge other:*this = Bool
extern inline Int met Operator_plus other:*this = this
extern inline Int met Operator_minus other:*this = this
extern inline Int met Operator_divide other:*this = this
extern inline Int met Operator_modulo other:*this = this
extern inline Int met Operator_times other:*this = this
extern inline Int met Operator_uminus = this
extern inline Int met Operator_rshift by:Uint = final
extern inline Int met! Operator_assign_plus other:*this
extern inline Int met! Operator_assign_minus other:*this
extern inline Int met! Operator_assign_divide other:*this
extern inline Int met! Operator_assign_modulo other:*this
extern inline Int met! Operator_assign_times other:*this
extern inline Int met! Operator_assign_modulo other:*final
extern inline Int met! Operator_assign_rshift by:Uint
extern inline Int met Operator_bwor other:*final = final
extern inline Int met Operator_bwxor other:*final = final
extern inline Int met Operator_bwand other:*final = final
extern inline Int met Operator_bwnot = final
extern inline Int met! Operator_assign_bwor other:*final
extern inline Int met! Operator_assign_bwxor other:*final
extern inline Int met! Operator_assign_bwand other:*final
inline Int met Abs = this
	if self >= 0
		return self*
	else
		return -self*
inline Int met Unsigned = Uint
	assert self >= 0
	return self.force_unsigned
inline Int met Try_unsigned = Error_range, Uint
	if Likely <- self >= 0
		return OK, self.force_unsigned
	return INVAL_RANGE, 0
extern inline Int met force_unsigned = Uint
extern inline Int met Trim_i8 = I8
extern inline Int met Trim_i16 = I16
extern inline Int met Trim_i32 = I32
extern inline Int met I64 = I64
inline Int met Intptr = Intptr
	return self.I64.force_intptr
extern inline Int met Round_float = Float
extern inline Int met Round_double = Double
extern Int met Show st:#`Fmt_state
inline Int met Hash32 = U32
	return self.I64.Hash32

extern inline struct Uint =
	isa `Native_unsigned_integer
	alias This_unsigned = this
	alias This_signed = Int
	alias impl = U64
inline Uint fun MIN = this
	return impl.MIN.force_uint
inline Uint fun MAX = this
	return impl.MAX.force_uint
extern Uint fun From_number_literal v:String = this
extern inline Uint met Operator_eq other:*this = Bool
extern inline Uint met Operator_ne other:*this = Bool
extern inline Uint met Operator_le other:*this = Bool
extern inline Uint met Operator_lt other:*this = Bool
extern inline Uint met Operator_gt other:*this = Bool
extern inline Uint met Operator_ge other:*this = Bool
extern inline Uint met Operator_plus other:*this = this
extern inline Uint met Operator_minus other:*this = this
extern inline Uint met Operator_divide other:*this = this
extern inline Uint met Operator_modulo other:*this = this
extern inline Uint met Operator_times other:*this = this
extern inline Uint met Operator_uminus = this
extern inline Uint met Operator_rshift by:Uint = final
extern inline Uint met! Operator_assign_plus other:*this
extern inline Uint met! Operator_assign_minus other:*this
extern inline Uint met! Operator_assign_divide other:*this
extern inline Uint met! Operator_assign_modulo other:*this
extern inline Uint met! Operator_assign_times other:*this
extern inline Uint met! Operator_assign_rshift by:Uint
extern inline Uint met Operator_bwor other:*final = final
extern inline Uint met Operator_bwxor other:*final = final
extern inline Uint met Operator_bwand other:*final = final
extern inline Uint met Operator_bwnot = final
extern inline Uint met! Operator_assign_bwor other:*final
extern inline Uint met! Operator_assign_bwxor other:*final
extern inline Uint met! Operator_assign_bwand other:*final
inline Uint met Signed = Int
	assert self <= Int.MAX.force_unsigned
	return self.force_signed
inline Uint met Try_signed = Error_range, Int
	if Likely <- self <= Int.MAX.force_unsigned
		return OK, self.force_signed
	return INVAL_RANGE, 0
extern inline Uint met force_signed = Int
extern inline Uint met Trim_u8 = U8
extern inline Uint met Trim_u16 = U16
extern inline Uint met Trim_u32 = U32
extern inline Uint met U64 = U64
inline Uint met Uintptr = Uintptr
	return self.U64.force_uintptr
extern inline Uint met Round_float = Float
extern inline Uint met Round_double = Double
extern Uint met Show st:#`Fmt_state
inline Uint met Hash32 = U32
	return self.U64.Hash32

extern inline struct Intptr =
	isa `Native_signed_integer
	alias This_unsigned = Uintptr
	alias This_signed = this
	alias impl = I64
inline Intptr fun MIN = this
	return impl.MIN.force_intptr
inline Intptr fun MAX = this
	return impl.MAX.force_intptr
extern Intptr fun From_number_literal v:String = this
extern inline Intptr met Operator_eq other:*this = Bool
extern inline Intptr met Operator_ne other:*this = Bool
extern inline Intptr met Operator_le other:*this = Bool
extern inline Intptr met Operator_lt other:*this = Bool
extern inline Intptr met Operator_gt other:*this = Bool
extern inline Intptr met Operator_ge other:*this = Bool
extern inline Intptr met Operator_plus other:*this = this
extern inline Intptr met Operator_minus other:*this = this
extern inline Intptr met Operator_divide other:*this = this
extern inline Intptr met Operator_modulo other:*this = this
extern inline Intptr met Operator_times other:*this = this
extern inline Intptr met Operator_uminus = this
extern inline Intptr met Operator_rshift by:Uint = final
extern inline Intptr met! Operator_assign_plus other:*this
extern inline Intptr met! Operator_assign_minus other:*this
extern inline Intptr met! Operator_assign_divide other:*this
extern inline Intptr met! Operator_assign_modulo other:*this
extern inline Intptr met! Operator_assign_times other:*this
extern inline Intptr met! Operator_assign_rshift by:Uint
extern inline Intptr met Operator_bwor other:*final = final
extern inline Intptr met Operator_bwxor other:*final = final
extern inline Intptr met Operator_bwand other:*final = final
extern inline Intptr met Operator_bwnot = final
extern inline Intptr met! Operator_assign_bwor other:*final
extern inline Intptr met! Operator_assign_bwxor other:*final
extern inline Intptr met! Operator_assign_bwand other:*final
inline Intptr met Abs = this
	if self >= 0
		return self*
	else
		return -self*
inline Intptr met Unsigned = Uintptr
	assert self >= 0
	return self.force_unsigned
inline Intptr met Try_unsigned = Error_range, Uintptr
	if Likely <- self >= 0
		return OK, self.force_unsigned
	return INVAL_RANGE, 0
extern inline Intptr met force_unsigned = Uintptr
extern inline Intptr met I64 = I64
extern Intptr met Show st:#`Fmt_state
inline Intptr met Hash32 = U32
	return self.I64.Hash32

extern inline struct Uintptr =
	isa `Native_unsigned_integer
	alias This_unsigned = this
	alias This_signed = Intptr
	alias impl = U64
inline Uintptr fun MIN = this
	return impl.MIN.force_uintptr
inline Uintptr fun MAX = this
	return impl.MAX.force_uintptr
extern Uintptr fun From_number_literal v:String = this
extern inline Uintptr met Operator_eq other:*this = Bool
extern inline Uintptr met Operator_ne other:*this = Bool
extern inline Uintptr met Operator_le other:*this = Bool
extern inline Uintptr met Operator_lt other:*this = Bool
extern inline Uintptr met Operator_gt other:*this = Bool
extern inline Uintptr met Operator_ge other:*this = Bool
extern inline Uintptr met Operator_plus other:*this = this
extern inline Uintptr met Operator_minus other:*this = this
extern inline Uintptr met Operator_divide other:*this = this
extern inline Uintptr met Operator_modulo other:*this = this
extern inline Uintptr met Operator_times other:*this = this
extern inline Uintptr met Operator_uminus = this
extern inline Uintptr met Operator_rshift by:Uint = final
extern inline Uintptr met! Operator_assign_plus other:*this
extern inline Uintptr met! Operator_assign_minus other:*this
extern inline Uintptr met! Operator_assign_divide other:*this
extern inline Uintptr met! Operator_assign_modulo other:*this
extern inline Uintptr met! Operator_assign_times other:*this
extern inline Uintptr met! Operator_assign_rshift by:Uint
extern inline Uintptr met Operator_bwor other:*final = final
extern inline Uintptr met Operator_bwxor other:*final = final
extern inline Uintptr met Operator_bwand other:*final = final
extern inline Uintptr met Operator_bwnot = final
extern inline Uintptr met! Operator_assign_bwor other:*final
extern inline Uintptr met! Operator_assign_bwxor other:*final
extern inline Uintptr met! Operator_assign_bwand other:*final
inline Uintptr met Signed = Intptr
	assert self <= Intptr.MAX.force_unsigned
	return self.force_signed
inline Uintptr met Try_signed = Error_range, Intptr
	if Likely <- self <= Intptr.MAX.force_unsigned
		return OK, self.force_signed
	return INVAL_RANGE, 0
extern inline Uintptr met force_signed = Intptr
extern inline Uintptr met U64 = U64
extern Uintptr met Show st:#`Fmt_state
inline Uintptr met Hash32 = U32
	return self.U64.Hash32

extern inline struct Float =
	isa `Native_floating
extern Float fun From_number_literal v:String = this
extern inline Float fun MIN = this
extern inline Float fun MAX = this
extern inline Float fun EPSILON = this
extern inline Float fun SMALLEST_POSITIVE_NORMAL = this
extern inline Float fun RADIX = Uint
extern inline Float fun MANTISSA_WIDTH = Uint
extern inline Float fun MAX_DECIMAL_DIGIT_EXACT = Uint
extern inline Float fun MIN_EXP = Int
extern inline Float fun MAX_EXP = Int
extern inline Float fun MIN_10_EXP = Int
extern inline Float fun MAX_10_EXP = Int
extern inline Float met Operator_eq other:*this = Bool
extern inline Float met Operator_ne other:*this = Bool
extern inline Float met Operator_le other:*this = Bool
extern inline Float met Operator_lt other:*this = Bool
extern inline Float met Operator_gt other:*this = Bool
extern inline Float met Operator_ge other:*this = Bool
extern inline Float met Operator_plus other:*this = this
extern inline Float met Operator_minus other:*this = this
extern inline Float met Operator_divide other:*this = this
extern inline Float met Operator_times other:*this = this
extern inline Float met Operator_uminus = this
extern inline Float met! Operator_assign_plus other:*this
extern inline Float met! Operator_assign_minus other:*this
extern inline Float met! Operator_assign_divide other:*this
extern inline Float met! Operator_assign_times other:*this
extern inline Float met Round0_i8 = I8
extern inline Float met Round0_i16 = I16
extern inline Float met Round0_i32 = I32
extern inline Float met Round0_i64 = I64
extern inline Float met Double = Double
extern inline Float met Round0_int = Int
extern Float met Show st:#`Fmt_state
extern inline Float met Bitwise_u32 = U32
inline Float met Hash32 = U32
	return self.Bitwise_u32.Hash32
extern inline Float met Classify = Floating_class
extern inline Float met Is_finite = Bool
extern inline Float met Is_normal = Bool
extern inline Float met Is_nan = Bool
extern inline Float met Is_inf = Int
extern inline Float met Signbit = Bool

extern inline struct Double =
	isa `Native_floating
extern Double fun From_number_literal v:String = this
extern inline Double fun MIN = this
extern inline Double fun MAX = this
extern inline Double fun EPSILON = this
extern inline Double fun SMALLEST_POSITIVE_NORMAL = this
extern inline Double fun RADIX = Uint
extern inline Double fun MANTISSA_WIDTH = Uint
extern inline Double fun MAX_DECIMAL_DIGIT_EXACT = Uint
extern inline Double fun MIN_EXP = Int
extern inline Double fun MAX_EXP = Int
extern inline Double fun MIN_10_EXP = Int
extern inline Double fun MAX_10_EXP = Int
extern inline Double met Operator_eq other:*this = Bool
extern inline Double met Operator_ne other:*this = Bool
extern inline Double met Operator_le other:*this = Bool
extern inline Double met Operator_lt other:*this = Bool
extern inline Double met Operator_gt other:*this = Bool
extern inline Double met Operator_ge other:*this = Bool
extern inline Double met Operator_plus other:*this = this
extern inline Double met Operator_minus other:*this = this
extern inline Double met Operator_divide other:*this = this
extern inline Double met Operator_times other:*this = this
extern inline Double met Operator_uminus = this
extern inline Double met! Operator_assign_plus other:*this
extern inline Double met! Operator_assign_minus other:*this
extern inline Double met! Operator_assign_divide other:*this
extern inline Double met! Operator_assign_times other:*this
extern inline Double met Round0_i8 = I8
extern inline Double met Round0_i16 = I16
extern inline Double met Round0_i32 = I32
extern inline Double met Round0_i64 = I64
extern inline Double met Round0_int = Int
-- FIXME Rounding mode is dependent on FP context* Should we provide
-- different alternatives, enforce round-to-nearest (the x86 default)?
-- Have a clear name to a fixed default?
extern inline Double met Round_float = Float
extern Double met Show st:#`Fmt_state
extern inline Double met Bitwise_u64 = U64
inline Double met Hash32 = U32
	return self.Bitwise_u64.Hash32
extern inline Double met Classify = Floating_class
extern inline Double met Is_finite = Bool
extern inline Double met Is_normal = Bool
extern inline Double met Is_nan = Bool
extern inline Double met Is_inf = Int
extern inline Double met Signbit = Bool

inline struct Bounds =
	First	:Bool
	Last	:Bool
	Begin	:Uint
	End	:Uint

inline Bounds (met t:`Any c:(`Random_container t)) Range_of v:*c = Range
	if self.First and self.Last
		return {Begin=0 End=v.Count}
	elif self.First
		return {Begin=0 End=self.End}
	elif self.Last
		return {Begin=self.Begin End=v.Count}
	else
		return {Begin=0 End=v.Count}

inline struct Range =
	isa  `Return_by_copy (`Collection Uint) `Show
	Begin	:Uint
	End	:Uint

inline Range met Count = Uint
	if self.Begin >= self.End
		return 0
	return self.End - self.Begin

example -> assert ({Begin=1 End=0}:Range).Count == 0

inline Range met Operator_in x:*Uint = Bool
	return x >= self.Begin and x < self.End

inline Range met With_offset offset:Uint = this
	return {Begin=self.Begin+offset End=self.End+offset}

inline Range met All = this
	return self*

inline Range met Operator_at p:Uint = Uint
	return p

inline Range met Operator_sub begin:Uint end:Uint = this
	assert begin >= self.Begin and end <= self.End
	return {Begin=begin End=end}

inline Range met Iter = Index_iterator
	return { r=self* p=self.Begin }

inline Range met Reverse_iter = Reverse_index_iterator
	return { it=self.Iter }

inline Range met First count:Uint = Range
	return {Begin=self.Begin
		\ End=(self.Begin + (Min self.Count count))}

inline Range met Last count:Uint = Range
	return {Begin=(self.End - (Min self.Count count))
		\ End=self.End}

inline Range met With_begin beg:Uint = Range
	if beg > self.End
		beg = self.End
	return {Begin=beg End=self.End}

inline Range met With_end end:Uint = Range
	if end < self.Begin
		end = self.Begin
	return {Begin=self.Begin End=end}

inline Range met Overlap other:*this = Int, Int
	let db = other.Begin.U64.Bitwise_signed - self.Begin.U64.Bitwise_signed
	let de = other.End.U64.Bitwise_signed - self.End.U64.Bitwise_signed
	return db.To_int, de.To_int

inline Range met Is_within other:*this = Bool
	return self.Begin >= other.Begin and self.End <= other.End

Range met Show st:#`Fmt_state
	"[".Show st
	self.Begin.Show st
	" .. ".Show st
	self.End.Show st
	"]".Show st

inline struct Index_iterator =
	isa (`Iterator Uint)
	r	:Range
	p	:Uint

inline Index_iterator met! Next = ?Uint
	if self.p >= self.r.End
		return nil
	let nxt = self.p
	self!p += 1
	return nxt

inline struct Reverse_index_iterator =
	isa (`Iterator Uint) `Trivial_copy `Trivial_ctor
	it	:Index_iterator

inline Reverse_index_iterator met! Next = ?Uint
	let nxt = self!it!Next
	if not nxt?
		return nil
	return self.it.r.End - 1 - nxt + self.it.r.Begin

example
	let r = {Begin=2 End=10}:Range
	assert r.Count == 8
	let j = 7 such
		for i over r.Reverse_iter
			assert i >= r.Begin and i < r.End
			assert j == i - r.Begin
			j -= 1

example
	let r = {Begin=10 End=20}:Range
	assert r.Count == 10
	let n = 0 such
		foreach i over r
			assert i >= r.Begin and i < r.End
			assert n == i - r.Begin
			n += 1

intf `Slice_compatible t:`Any =
	fun From_slice c:[]t = final


extern inline (fun$ i:`Any j:`Any) Dyncast x:$j = ?$i


extern inline fun Likely x:Bool = Bool
extern inline fun Unlikely x:Bool = Bool

inline (fun t:`Any) Unused x:t
	noop

inline (fun t:`Numeric) Min a:t b:t = t
	if a <= b
		return a
	else
		return b

inline (fun t:`Numeric) Max a:t b:t = t
	if a >= b
		return a
	else
		return b

inline struct Error =
	-- FIXME Two different errors with the same string literal may compare
	-- as equal if the compiler merges the literals* This won't be a
	-- problem once * are refcounted, there will be no merging then.
	isa `Has_equality `Show
	Why	:?*String -- FIXME Make it ?*`Show

	let OK = {}:this
	let UNKNOWN = {Why=*"UNKNOWN: Unknown error"}:this
	let INVAL = {Why=*"INVAL: Invalid value"}:this
	let INVAL_RANGE = {Why=*"INVAL_RANGE: Invalid value range"}:this
	let AGAIN = {Why=*"AGAIN: Try again"}:this
	let OVERFLOW = {Why=*"OVERFLOW: Value too large for defined data type"}:this
	let NOMEM = {Why=*"NOMEM: Not enough space"}:this

inline Error met Operator_test = Bool
	return self.Why?

inline Error met Operator_eq other:*this = Bool
	return self.Why === other.Why

inline Error met Operator_ne other:*this = Bool
	return not self == other

Error met Show st:#`Fmt_state
	if self.Why?
		"Error: ".Show st
		self.Why.Show st
	else
		"Success".Show st

fun Drop err:Error
	noop

fun Fatal err:Error
	Eprn "Fatal:" err
	Abort


extern inline struct Varargint =
	isa `Trivial_copy `Trivial_ctor `Trivial_dtor

extern inline Varargint met Count_left = Uint

intf `no_dyn_iterator r:`Any_any_ref =
	isa `Prevent_dyn (`Iterator r)

opaque struct Vararg r:`Any_any_ref =
	isa (`no_dyn_iterator r)
	isa `Trivial_copy -- FIXME: remove `Trivial_copy, needed by bootstrap
	ap	:Varargint

extern Vararg met! Next = ?r

inline Vararg met Count_left = Uint
	return self.ap.Count_left


inline (struct t:`Any) Envheader r:(`Any_ref t) =
	Env	:r
	Parent	:?#this

(fun t:`Any r:(`Any_ref t)) Internal_globalenv_installed env:r where:!?#(Envheader r) where_env:?#r = Bool
	return where_env* !== nil

(fun t:`Any r:(`Any_ref t)) Internal_globalenv_parent env:r where:!?#(Envheader r) where_env:?#r = r
	return (where!)#Parent#Env

(fun t:`Any r:(`Any_ref t)) Internal_globalenv_install env:r header:#(Envheader r) where:!?#(Envheader r) where_env:?#r
	header#Parent = where!
	where! = header
	where_env! = header#Env

(fun t:`Any r:(`Any_ref t)) Internal_globalenv_uninstall env:r where:!?#(Envheader r) where_env:?#r
	where! = (where!)#Parent
	if (where!)?
		where_env! = (where!)#Env
	else
		where_env! = nil

-- Rewritten into Internal_* versions by the compiler.
extern (fun t:`Any_any_ref) Globalenv_installed env:t = Bool
extern (fun t:`Any_any_ref) Globalenv_parent env:t = t
extern (fun t:`Any_any_ref) Globalenv_install env:t n:t
extern (fun t:`Any_any_ref) Globalenv_uninstall env:t

--intf `Debugenv =
--  isa (`Environment this)
--  met! _Assert cond:Bool ?expr:?*String
--  met! _pre cond:Bool ?expr:?*String
--  met! _post cond:Bool ?expr:?*String
--  met! _invariant cond:Bool ?expr:?*String
--  met! _example cond:Bool ?expr:?*String
--
--  met! Pr ?sep:?*String ...v:(vararg *`Showable)
--  met! Prn ?sep:?*String ...v:(vararg *`Showable)
--
--struct Debugenv =
--  export isa `Debugenv


--atom identity_transitivity P =
--  forall P, x
--    P x => forall y
--      y === x => P y
--atom equality_transitivity P =
--  identity_transitivity P
--  forall P, x
--    P x => forall y
--      y == x => P y
--
--atom nonnull x =
--  equality_transitivity this
--
--atom has_tag tag x =
--  x ==| tag

inline struct Codeloc =
	File	:String
	Line	:Uint
	Function:String
	Expr	:String

fun Message_at msg:String c:?*Codeloc
	if c?
		Eprn sep="" c.File ":" c.Line ": " c.Function ": " msg " '" c.Expr "'"
	else
		Eprn msg

extern fun abort

fun Abort
	abort

inline fun Assert__ cond:Bool ?_Ncodeloc:?*Codeloc
	if Likely cond
		return
	else
		Message_at "assert failed" _Ncodeloc
		Abort

inline fun Unreached ?_Ncodeloc:?*Codeloc
	Message_at "unreached" _Ncodeloc
	Abort

inline fun Pre__ cond:Bool ?_Ncodeloc:?*Codeloc
	if Likely cond
		return
	else
		Message_at "pre failed" _Ncodeloc
		Abort

inline fun Post__ cond:Bool ?_Ncodeloc:?*Codeloc
	if Likely cond
		return
	else
		Message_at "post failed" _Ncodeloc
		Abort

inline fun Invariant__ cond:Bool ?_Ncodeloc:?*Codeloc
	if Likely cond
		return
	else
		Message_at "invariant failed" _Ncodeloc
		Abort

fun Trace_except err:Error ?_Ncodeloc:?*Codeloc
	Epr "except:"
	if _Ncodeloc?
		Epr sep="" " " _Ncodeloc.File ":" _Ncodeloc.Line ": " _Ncodeloc.Function ":"
	Eprn "" err

fun Trace_drop err:Error ?_Ncodeloc:?*Codeloc
	Epr "drop:"
	if _Ncodeloc?
		Epr sep="" " " _Ncodeloc.File ":" _Ncodeloc.Line ": " _Ncodeloc.Function ":"
	Eprn "" err

fun Trace_fatal err:Error ?_Ncodeloc:?*Codeloc
	Epr "fatal:"
	if _Ncodeloc?
		Epr sep="" " " _Ncodeloc.File ":" _Ncodeloc.Line ": " _Ncodeloc.Function ":"
	Eprn "" err
	Abort

fun Trace_never err:Error ?_Ncodeloc:?*Codeloc
	Epr "never:"
	if _Ncodeloc?
		Epr sep="" " " _Ncodeloc.File ":" _Ncodeloc.Line ": " _Ncodeloc.Function ":"
	Eprn "" err
	Abort

fun Example_except name:String err:Error
	if err == OK
		return
	Eprn sep="" "Failed example: " name ": " err

fun Break
	return

let sysheap:mem.Sysheap
fun ensure_visible_sysheap_dyn = *`Heap
	return *sysheap
fun Ensure_visible_example_dtor
	let ex = {}:bench.Example
	ex#Dtor

fun Step x:Uint
	noop


(fun t:`Any) try_show st:#`Fmt_state x:*t
	if t isa `Show
		x.Show st
	else
		let px = (Voidref.From_ptr x).Uintptr
		"<".Show st
		px.Show st
		">".Show st
