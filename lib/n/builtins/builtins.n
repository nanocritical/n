from n.containers import `Iterator `Random_container
from n.unsafe import Cast Nonnull_cast
from n import Eprn Epr
import n.reflect
import n.math

extern intf `__literal_null__ =
	isa `Any_nullable_ref
extern intf `__literal_integer__ =
	isa `Integer
extern intf `__literal_floating__ =
	isa `Floating
extern intf `__literal_slice__ t:`Any =
extern intf `__literal_string__ =
	isa `String

extern struct __internal_not_typeable__ =
extern struct __call_function_slot__ =

extern struct __mutable__ =
extern struct __mercurial__ =

intf `Any =

-- `Prevent_dyn stops the compiler from generating a dyntable for the rest of
-- the isa list.
intf `Prevent_dyn =

intf `Copyable =
	met# Copy_ctor other:@final
intf `Not_copyable =
intf `Copyable_but_owned =
	isa `Copyable -- FIXME
-- FIXME: `Trivial_copy should have other:@this, as it only needs `Any.sizeof.
-- And there should be a copy_slice operation over `Trivial_copy. That's kinda
-- the point.
intf `Trivial_copy =
	isa `Copyable
intf `Trivial_copy_but_owned =
	isa `Trivial_copy -- FIXME
intf `Return_by_copy =
intf `Not_return_by_copy =
intf `Default_ctor =
	met# Ctor
intf `Non_default_ctor =

intf `Default_dtor =
	met# Dtor
intf `Error_dtor =
	met# Dtor = Error

intf `Trivial_ctor =
	isa `Default_ctor
intf `Trivial_dtor =
	isa `Default_dtor

intf `Matchable =
intf `Has_compare =
	-- The relation defined by `Has_compare.Operator_compare may be a partial
	-- order, or maybe not an order, or maybe not even an equality.
	-- `Equality_by_compare and `Ordered_by_compare must be used to indicate what
	-- this relation actually is.
	met Operator_compare other:@final = I32
intf `Trivial_compare =
	isa `Has_compare
intf `Has_equality =
	isa `Matchable
	met Operator_eq other:@final = Bool
	met Operator_ne other:@final = Bool

--	fun exgen n:Uint = final
--	example
--		let a, b = final.exgen 0, final.exgen 0
--		a == b and b == a
--	example
--		let a, b = final.exgen 0, final.exgen 1
--		a != b and b != a

intf `Not_has_equality =
intf `Equality_by_compare =
	-- Compiler generates Operator_{eq,ne}.
	isa `Has_compare `Has_equality
intf `Trivial_equality =
	isa `Trivial_compare `Equality_by_compare

intf `Partially_ordered =
	isa `Has_equality
	met Operator_le other:@final = Bool
	met Operator_lt other:@final = Bool
	met Operator_gt other:@final = Bool
	met Operator_ge other:@final = Bool
intf `Ordered =
	isa `Has_equality `Has_compare `Partially_ordered
intf `Not_ordered =
intf `Ordered_by_compare =
	-- Compiler generates Operator_{le,lt,gt,ge}.
	isa `Has_compare `Ordered
intf `Trivial_order =
	isa `Trivial_compare `Ordered_by_compare
intf `Arithmetic =
	met Operator_plus other:@final = final
	met Operator_minus other:@final = final
	met Operator_divide other:@final = final
	met Operator_times other:@final = final
	met Operator_uminus = final
	met! Operator_assign_plus other:@final
	met! Operator_assign_minus other:@final
	met! Operator_assign_divide other:@final
	met! Operator_assign_times other:@final
intf `Has_bitwise_operators =
	met Operator_bwor other:@final = final
	met Operator_bwxor other:@final = final
	met Operator_bwand other:@final = final
	met Operator_bwnot = final
	met! Operator_assign_bwor other:@final
	met! Operator_assign_bwxor other:@final
	met! Operator_assign_bwand other:@final
intf `Integer_arithmetic =
	isa `Has_bitwise_operators
	met Operator_modulo other:@final = final
	met Operator_rshift by:Uint = final
	met! Operator_assign_modulo other:@final
	met! Operator_assign_rshift by:Uint
intf `Overflow_arithmetic =
	met Operator_ovplus other:@this = this
	met Operator_ovminus other:@this = this
	met Operator_ovdivide other:@this = this
	met Operator_ovmodulo other:@this = this
	met Operator_ovtimes other:@this = this
	met Operator_ovuminus = this
	met Operator_ovlshift by:Uint = final
	met! Operator_assign_ovplus other:@this
	met! Operator_assign_ovminus other:@this
	met! Operator_assign_ovdivide other:@this
	met! Operator_assign_ovmodulo other:@this
	met! Operator_assign_ovtimes other:@this
	met! Operator_assign_ovlshift by:Uint

intf `Sum_copy =
	isa `Copyable
intf `Sum_equality =
	isa `Has_equality
intf `Sum_order =
	isa `Ordered


extern inline struct Void =
	isa `Prevent_dyn `Return_by_copy `Trivial_copy `Trivial_ctor

extern fun Nonnull_void = @Void

intf `Any_any_ref =
	isa `Return_by_copy `Trivial_copy_but_owned
intf `Any_ref t:`Any =
	isa `Any_any_ref
intf `Any_mutable_ref t:`Any =
	isa (`Any_ref t)
intf `Any_nullable_ref t:`Any =
	isa (`Any_ref t) `Trivial_ctor
intf `Any_nullable_mutable_ref t:`Any =
	isa (`Any_nullable_ref t) (`Any_mutable_ref t)

extern struct Ref t:`Any =
	isa (`Any_ref t)
extern struct Mutable_ref t:`Any =
	isa (`Any_mutable_ref t)
extern struct Mercurial_ref t:`Any =
	isa (`Any_mutable_ref t)

-- FIXME: to replace with semantic constraint
extern struct Nullable_ref t:`Any =
	isa (`Any_nullable_ref t)
extern struct Nullable_mutable_ref t:`Any =
	isa (`Any_nullable_mutable_ref t)
extern struct Nullable_mercurial_ref t:`Any =
	isa (`Any_nullable_mutable_ref t)

-- Uses automagicref on function calls.
inline (fun t:`Any) Take_ref_if_value__ p:@t = @t
	return p

intf `Any_any_slice =
	isa `Trivial_ctor `Trivial_dtor `Return_by_copy `Trivial_copy_but_owned

intf `Any_slice t:`Any =
	isa `Any_any_slice (`Random_container t)
	met Bytecount = Uint
	met All = Range
	shallow met$ Unsafe_rawdata = @$U8
	shallow met$ Unsafe_data = @$t
	shallow met$ Operator_at n:Uint = @$t
	shallow met$ Operator_sub r:Range = []$t

intf `Any_mutable_slice t:`Any =
	isa (`Any_slice t)
	met! Copy other:[]t

-- The body of the methods for Slice and Mutable_slice are actually not used, as
-- Slice_impl is used in codegen for both Slice and Mutable_slice. The code in
-- these functions has only one purpose: triggering the instantiation of the
-- corresponding Slice_impl methods.
-- We will need a better solution down the road, as the code in these bogus
-- methods is All sorts of wrong and is bound to be rejected by the compiler
-- as its bullshit detector improves.
--
-- In reality, it doesn't actually make sense to share the implementations
-- of Slice and Mutable_slice: Slice does not need to carry around a cap
-- field. It's just easier for now as it lets us avoid generating conversion
-- operations between kinds of slices.

opaque struct Slice t:`Any =
	isa (`Any_slice t) -- FIXME missing genarg
	dat	:?@#t
	cnt	:Uint
	cap	:Uint -- will go away

inline Slice fun create_impl_instance = (Slice_impl t)
	return {}
inline Slice met# Unsafe_wrap p:@U8 c:Uint cap:Uint
	let s = this.create_impl_instance
	s#Unsafe_wrap p c cap
inline Slice met Count = Uint
	let s = this.create_impl_instance
	return s.Count
inline Slice met Cap = Uint
	let s = this.create_impl_instance
	return s.Cap
inline Slice met Bytecount = Uint
	let s = this.create_impl_instance
	return s.Bytecount
inline Slice met All = Range
	let s = this.create_impl_instance
	return s.All

-- These are shallow wildcard methods because their prototype must match
-- exactly those found in Slice_impl.
inline Slice shallow met$ Unsafe_rawdata = @U8
	let s = this.create_impl_instance
	return s.Unsafe_rawdata
inline Slice shallow met$ Unsafe_data = @t
	let s = this.create_impl_instance
	return s.Unsafe_data
inline Slice shallow met$ Operator_at n:Uint = @t
	let s = this.create_impl_instance
	return s.Operator_at n
inline Slice shallow met$ Operator_sub r:Range = []t
	let s = this.create_impl_instance
	such
		let _ = s.Operator_sub r
	return {}
inline Slice shallow met$ Recapped cap:Uint = this
	let s = this.create_impl_instance
	such
		let _ = s.Recapped cap
	return {}
inline Slice shallow met$ First = @t
	let s = this.create_impl_instance
	return s.First
inline Slice shallow met$ Last = @t
	let s = this.create_impl_instance
	return s.Last

opaque struct Mutable_slice t:`Any =
	isa (`Any_mutable_slice t) -- FIXME missing genarg
	dat	:?@#t
	cnt	:Uint
	cap	:Uint

inline Mutable_slice fun create_impl_instance = (Slice_impl t)
	return {}
inline Mutable_slice met# Unsafe_wrap p:@U8 c:Uint cap:Uint
	let s = this.create_impl_instance
	s#Unsafe_wrap p c cap
inline Mutable_slice met Count = Uint
	let s = this.create_impl_instance
	return s.Count
inline Mutable_slice met Cap = Uint
	let s = this.create_impl_instance
	return s.Cap
inline Mutable_slice met Bytecount = Uint
	let s = this.create_impl_instance
	return s.Bytecount
inline Mutable_slice met All = Range
	let s = this.create_impl_instance
	return s.All
inline Mutable_slice shallow met$ Unsafe_rawdata = @$U8
	let s = this.create_impl_instance
	such
		let _ = s.Unsafe_rawdata
		let _ = s!Unsafe_rawdata
		let _ = s#Unsafe_rawdata
		return s$Unsafe_rawdata
inline Mutable_slice shallow met$ Unsafe_data = @$t
	let s = this.create_impl_instance
	such
		let _ = s.Unsafe_data
		let _ = s!Unsafe_data
		let _ = s#Unsafe_data
		return s$Unsafe_data
inline Mutable_slice shallow met$ Operator_at n:Uint = @$t
	let s = this.create_impl_instance
	such
		let _ = s.Operator_at n
		let _ = s!Operator_at n
		let p = s#Operator_at n
		return s$Operator_at n
inline Mutable_slice met! Full_copy other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Full_copy s
		return {}
inline Mutable_slice met! Copy other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Copy s
		return {}
inline Mutable_slice met! Append other:[]t = this
	let s = this.create_impl_instance
	such
		let _ = s!Append s
		return {}
inline Mutable_slice shallow met$ Operator_sub r:Range = []$t
	let s = this.create_impl_instance
	such
		let _ = (s.Operator_sub r)
		let _ = (s!Operator_sub r)
		let _ = (s#Operator_sub r)
		return {}
inline Mutable_slice shallow met$ Recapped cap:Uint = this
	let s = this.create_impl_instance
	such
		let _ = (s.Recapped cap)
		let _ = (s!Recapped cap)
		return {}
inline Mutable_slice shallow met$ First = @$t
	let s = this.create_impl_instance
	such
		let _ = s.First
		let _ = s!First
		let p = s#First
		return p
inline Mutable_slice shallow met$ Last = @$t
	let s = this.create_impl_instance
	such
		let _ = s.Last
		let _ = s!Last
		let p = s#Last
		return p

extern inline fun Slice_at_byte dp:@#U8 off:Uint = @#U8
extern inline fun Slice_memmove dst:@#U8 src:@U8 cnt:Uint
extern inline fun Slice_memcmp a:@U8 b:@U8 cnt:Uint = Int

inline fun Bytes_compare a:[]U8 b:[]U8 = Int
	let acnt, bcnt = a.Count, b.Count
	let c = Slice_memcmp a.Unsafe_rawdata b.Unsafe_rawdata (Min acnt bcnt)
	if c == 0
		return acnt.Signed - bcnt.Signed
	return c

opaque struct Slice_impl t:`Any =
	isa (`Any_mutable_slice t)
	dat	:?@#t
	cnt	:Uint
	cap	:Uint

inline Slice_impl met# Unsafe_wrap p:@U8 cnt:Uint cap:Uint
	self#dat = (Cast @U8 @#t) p
	self#cnt = cnt
	self#cap = cap

inline Slice_impl met Count = Uint
	return self.cnt

inline Slice_impl met Cap = Uint
	return self.cap

inline Slice_impl met Bytecount = Uint
	return (sizeof t) * self.cnt

inline Slice_impl met Bytecap = Uint
	return (sizeof t) * self.cap

inline Slice_impl met All = Range
	return 0 .. self.cnt

inline Slice_impl shallow met$ Unsafe_rawdata = @$U8
	return (Cast ?@$t @$U8) self$dat

inline Slice_impl shallow met$ Unsafe_data = @$t
	return (Nonnull_cast t ?@$t @$t) self$dat

inline Slice_impl shallow met$ Operator_at n:Uint = r:@$t
	assert n < self.cnt
	let raw = (Cast ?@t @#U8) self.dat
	and off = n * (sizeof t)
	return (Cast @#U8 @$t) <- Slice_at_byte raw off

---- FIXME: the copy operations are only available if the t is `Copyable or
-- `Trivial_copy. We would like that detection to be static. And we would want
-- to allow method arguments whose type require `Copyable, say.

inline Slice_impl met! Full_copy other:this = this
	if not t isa `Trivial_copy
		assert false

	assert self.cap >= other.cnt
	let dst = self!Unsafe_rawdata
	and src = other.Unsafe_rawdata
	and bytecnt = other.cnt * (sizeof t)
	Slice_memmove dst src bytecnt
	return {dat=((Cast @#U8 @#t) dst) cnt=other.cnt cap=self.cap}

-- Copy what it can, and return a slice to the result.
inline Slice_impl met! Copy other:this = this
	let cnt = Min self.cap other.cnt
	return self!Full_copy other.[.. cnt]

-- Append what it can, and return a slice to the result.
inline Slice_impl met! Append other:this = this
	if other.cnt == 0
		return self.
	let newcnt = self.cnt + other.cnt
	assert newcnt <= self.cap
	let _ = self.[self.cnt .. newcnt]!Copy other
	return {dat=self.Unsafe_data cnt=newcnt cap=self.cap}

inline Slice_impl shallow met$ Operator_sub r:Range = this
	assert r.Begin <= self.cap
	assert r.End <= self.cap
	let newcap = self.cap - r.Begin

	let raw0 = (Cast @U8 @#U8) self.Unsafe_rawdata
	and off = r.Begin * (sizeof t)
	let raw = Slice_at_byte raw0 off
	return {dat=((Cast @#U8 @#t) raw) cnt=r.Count cap=newcap}

inline Slice_impl shallow met$ Recapped cap:Uint = this
	assert cap <= self.cap
	return {dat=self.dat cnt=(Min self.Count cap) cap=cap}

inline Slice_impl shallow met$ First = @$t
	return self$[0]

inline Slice_impl shallow met$ Last = @$t
	return self$[self.cnt - 1]

example
	let a = { 0:Uint 1 2 3 4 5 6 7 }
	assert a.Count == 8
	assert a.All == 0 .. 8
	assert a.Unsafe_rawdata === (Cast @Uint @U8) a.Unsafe_data
	foreach i in a.All
		assert a.[i] == i
	assert a.First == 0
	assert a.Last == 7
	assert a.[..].All == a.All
	assert a.[7 ..].Count == 1
	assert a.[7 ..].Cap == 1
	assert a.[7 .. 7].Count == 0
	assert a.[7 .. 7].Cap == 1
	-- OK to create slice of cap 0:
	assert a.[8 .. ].Count == 0
	let b = a.[4 ..]
	foreach i in b.All
		assert b.[i] == a.[4 + i]
	let c = a.[0 .. 4]
	assert c.Cap == a.Cap
	let d = c.Recapped 8
	assert d.Cap == a.Cap
	assert d.Count == c.Count

example
	let ref = { 0:Uint 1 2 3 4 5 6 7 }
	let a = { 0 1 2 3 4 5 6 7 }:[]!Uint such
		let b = a![4 ..]
		foreach i in b.All
			b![i]! = 0

		let suma = 0
		and sumb = 0 such
			foreach x in a.[4 ..]
				suma += x.
			foreach x in b
				sumb += x.
		assert suma == sumb

	let c = { 8 8 8 8 8 8 8 8 }:[]!Uint such
		let d = c!Full_copy ref
		assert d.Count == ref.Count
		assert d.Count == c.Count
		foreach i in c.All
			assert c.[i] == ref.[i]
			assert d.[i] == ref.[i]

	let e = { 8 8 8 8 8 8 8 8 }:[]!Uint such
		let f = e![4 ..] such
			let g = f!Copy ref.[4 ..]
			assert g.Count == 4
			foreach i in g.All
				assert g.[i] == ref.[4 + i]
		let h = e![.. 4] such
			let m = h!Copy ref
			assert m.Count > h.Count
			assert m.Count == ref.Count
			foreach i in m.All
				if i < h.Count
					assert h.[i] == ref.[i]
				assert m.[i] == ref.[i]
			let n = h!Full_copy ref
			assert n.Count == m.Count
	let o = { 8 8 8 8 8 8 8 8 }:[]!Uint such
		o = o#Copy ref
	let p = o.[0 .. 0]
	assert p.Count == 0
	let q = p.[0 .. 8]
	assert q.Count == 8

intf `Any_tuple =
	isa `Copyable

inline struct Tuple_2 t0:`Copyable t1:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1

inline struct Tuple_3 t0:`Copyable t1:`Copyable t2:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2

inline struct Tuple_4 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3

inline struct Tuple_5 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4

inline struct Tuple_6 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5

inline struct Tuple_7 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6

inline struct Tuple_8 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7

inline struct Tuple_9 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable t8:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7
	X8	:t8

inline struct Tuple_10 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable t8:`Copyable t9:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7
	X8	:t8
	X9	:t9

inline struct Tuple_11 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable t8:`Copyable t9:`Copyable t10:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7
	X8	:t8
	X9	:t9
	X10	:t10

inline struct Tuple_12 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable t8:`Copyable t9:`Copyable t10:`Copyable t11:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7
	X8	:t8
	X9	:t9
	X10	:t10
	X11	:t11

inline struct Tuple_13 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable t8:`Copyable t9:`Copyable t10:`Copyable t11:`Copyable t12:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7
	X8	:t8
	X9	:t9
	X10	:t10
	X11	:t11
	X12	:t12

inline struct Tuple_14 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable t8:`Copyable t9:`Copyable t10:`Copyable t11:`Copyable t12:`Copyable t13:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7
	X8	:t8
	X9	:t9
	X10	:t10
	X11	:t11
	X12	:t12
	X13	:t13

inline struct Tuple_15 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable t8:`Copyable t9:`Copyable t10:`Copyable t11:`Copyable t12:`Copyable t13:`Copyable t14:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7
	X8	:t8
	X9	:t9
	X10	:t10
	X11	:t11
	X12	:t12
	X13	:t13
	X14	:t14

inline struct Tuple_16 t0:`Copyable t1:`Copyable t2:`Copyable t3:`Copyable t4:`Copyable t5:`Copyable t6:`Copyable t7:`Copyable t8:`Copyable t9:`Copyable t10:`Copyable t11:`Copyable t12:`Copyable t13:`Copyable t14:`Copyable t15:`Copyable =
	isa `Any_tuple
	X0	:t0
	X1	:t1
	X2	:t2
	X3	:t3
	X4	:t4
	X5	:t5
	X6	:t6
	X7	:t7
	X8	:t8
	X9	:t9
	X10	:t10
	X11	:t11
	X12	:t12
	X13	:t13
	X14	:t14
	X15	:t15

intf `Numeric =
	isa `Copyable `Arithmetic `Ordered `Show

intf `Integer_literal_compatible =
	isa `Numeric

intf `Integer =
	isa `Numeric `Integer_arithmetic `Has_compare `Integer_literal_compatible
	fun MIN = final
	fun MAX = final

intf `Signed_integer =
	isa `Integer
	alias This_unsigned = `Unsigned_integer
	met Unsigned = final.This_unsigned
	met Try_unsigned = Error, final.This_unsigned
	met Abs = final.This_unsigned
	met To_i64 = I64

intf `Unsigned_integer =
	isa `Integer
	alias This_signed = `Signed_integer
	met Signed = final.This_signed
	met Try_signed = Error, final.This_signed
	met To_u64 = U64

intf `Native_integer =
	isa `Trivial_ctor `Trivial_dtor `Trivial_copy `Trivial_order `Return_by_copy
		\ `Integer `Show
intf `Native_signed_integer =
	isa `Signed_integer `Native_integer
intf `Native_unsigned_integer =
	isa `Unsigned_integer `Native_integer

intf `Native_sized_signed_integer =
	isa `Native_signed_integer
intf `Native_sized_unsigned_integer =
	isa `Native_unsigned_integer `Overflow_arithmetic

intf `Generalized_boolean =
	isa `Ordered
	met Operator_test = Bool

intf `Bool_compatible =
	fun From_bool b:Bool = final

intf `Native_boolean =
	isa `Trivial_ctor `Trivial_dtor `Trivial_copy `Return_by_copy `Generalized_boolean
		\ `Trivial_order `Bool_compatible `Show

intf `Floating =
	isa `Numeric `Has_compare `Integer_literal_compatible

intf `Native_floating =
	isa `Trivial_ctor `Trivial_dtor `Trivial_copy `Trivial_order `Return_by_copy
		\ `Floating `Show

intf `Enum =
	isa `Trivial_order `Trivial_equality `Trivial_copy `Return_by_copy `Trivial_dtor `Show
	alias Tag_type = `Unsigned_integer
	-- Generated for use by Mask.
	let BWALL:U64
	fun From_tag value:final.Tag_type = final
	met Tag = final.Tag_type

intf `Union =
	alias Tag_type = `Integer
	met Tag = final.Tag_type

intf `Union_trivial_ctor =
	isa `Union `Trivial_ctor
	fun From_tag value:final.Tag_type = final

alias Error_range = Error -- FIXME ::|OK|INVAL_RANGE

extern inline struct Bool =
	isa `Native_boolean
extern inline Bool met Operator_eq other:@this = Bool
extern inline Bool met Operator_ne other:@this = Bool
extern inline Bool met Operator_le other:@this = Bool
extern inline Bool met Operator_lt other:@this = Bool
extern inline Bool met Operator_gt other:@this = Bool
extern inline Bool met Operator_ge other:@this = Bool
Bool fun From_bool b:Bool = this
	return b
extern inline Bool met Operator_test = Bool
extern inline Bool met Operator_not = Bool
extern Bool met To_u8 = U8
extern Bool met To_u16 = U16
extern Bool met To_u32 = U32
extern Bool met To_u64 = U64
extern Bool met Show st:@#`Fmt_state

extern inline struct I8 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U8
inline I8 fun MIN = this
	return -0x7f
inline I8 fun MAX = this
	return 0x80
extern inline I8 met Operator_eq other:@this = Bool
extern inline I8 met Operator_ne other:@this = Bool
extern inline I8 met Operator_le other:@this = Bool
extern inline I8 met Operator_lt other:@this = Bool
extern inline I8 met Operator_gt other:@this = Bool
extern inline I8 met Operator_ge other:@this = Bool
extern inline I8 met Operator_plus other:@this = this
extern inline I8 met Operator_minus other:@this = this
extern inline I8 met Operator_divide other:@this = this
extern inline I8 met Operator_modulo other:@this = this
extern inline I8 met Operator_times other:@this = this
extern inline I8 met Operator_uminus = this
extern inline I8 met! Operator_assign_plus other:@this
extern inline I8 met! Operator_assign_minus other:@this
extern inline I8 met! Operator_assign_divide other:@this
extern inline I8 met! Operator_assign_modulo other:@this
extern inline I8 met! Operator_assign_times other:@this
extern inline I8 met Operator_bwor other:@this = this
extern inline I8 met Operator_bwxor other:@this = this
extern inline I8 met Operator_bwand other:@this = this
extern inline I8 met Operator_rshift by:Uint = this
extern inline I8 met Operator_bwnot = this
extern inline I8 met! Operator_assign_bwor other:@this
extern inline I8 met! Operator_assign_bwxor other:@this
extern inline I8 met! Operator_assign_bwand other:@this
extern inline I8 met! Operator_assign_rshift by:Uint
inline I8 met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline I8 met Unsigned = U8
	assert self >= 0
	return self.Bitwise_unsigned
inline I8 met Try_unsigned = Error_range, U8
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I8 met Bitwise_unsigned = U8
extern inline I8 met To_i16 = I16
extern inline I8 met To_i32 = I32
extern inline I8 met To_i64 = I64
extern inline I8 met To_int = Int
extern inline I8 met Exact_float = Float
extern inline I8 met Exact_double = Double
extern I8 met Show st:@#`Fmt_state

extern inline struct I16 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U16
inline I16 fun MIN = this
	return -0x7fff
inline I16 fun MAX = this
	return 0x8000
extern inline I16 met Operator_eq other:@this = Bool
extern inline I16 met Operator_ne other:@this = Bool
extern inline I16 met Operator_le other:@this = Bool
extern inline I16 met Operator_lt other:@this = Bool
extern inline I16 met Operator_gt other:@this = Bool
extern inline I16 met Operator_ge other:@this = Bool
extern inline I16 met Operator_plus other:@this = this
extern inline I16 met Operator_minus other:@this = this
extern inline I16 met Operator_divide other:@this = this
extern inline I16 met Operator_modulo other:@this = this
extern inline I16 met Operator_times other:@this = this
extern inline I16 met Operator_uminus = this
extern inline I16 met! Operator_assign_plus other:@this
extern inline I16 met! Operator_assign_minus other:@this
extern inline I16 met! Operator_assign_divide other:@this
extern inline I16 met! Operator_assign_modulo other:@this
extern inline I16 met! Operator_assign_times other:@this
extern inline I16 met Operator_bwor other:@this = this
extern inline I16 met Operator_bwxor other:@this = this
extern inline I16 met Operator_bwand other:@this = this
extern inline I16 met Operator_rshift by:Uint = this
extern inline I16 met Operator_bwnot = this
extern inline I16 met! Operator_assign_bwor other:@this
extern inline I16 met! Operator_assign_bwxor other:@this
extern inline I16 met! Operator_assign_bwand other:@this
extern inline I16 met! Operator_assign_rshift by:Uint
inline I16 met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline I16 met Unsigned = U16
	assert self >= 0
	return self.Bitwise_unsigned
inline I16 met Try_unsigned = Error_range, U16
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I16 met Bitwise_unsigned = U16
extern inline I16 met Trim_i8 = I8
extern inline I16 met To_i32 = I32
extern inline I16 met To_i64 = I64
extern inline I16 met To_int = Int
extern inline I16 met Exact_float = Float
extern inline I16 met Exact_double = Double
extern I16 met Show st:@#`Fmt_state

extern inline struct I32 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U32
inline I32 fun MIN = this
	return -0x7fffffff
inline I32 fun MAX = this
	return 0x80000000
extern inline I32 met Operator_eq other:@this = Bool
extern inline I32 met Operator_ne other:@this = Bool
extern inline I32 met Operator_le other:@this = Bool
extern inline I32 met Operator_lt other:@this = Bool
extern inline I32 met Operator_gt other:@this = Bool
extern inline I32 met Operator_ge other:@this = Bool
extern inline I32 met Operator_plus other:@this = this
extern inline I32 met Operator_minus other:@this = this
extern inline I32 met Operator_divide other:@this = this
extern inline I32 met Operator_modulo other:@this = this
extern inline I32 met Operator_times other:@this = this
extern inline I32 met Operator_uminus = this
extern inline I32 met! Operator_assign_plus other:@this
extern inline I32 met! Operator_assign_minus other:@this
extern inline I32 met! Operator_assign_divide other:@this
extern inline I32 met! Operator_assign_modulo other:@this
extern inline I32 met! Operator_assign_times other:@this
extern inline I32 met Operator_bwor other:@this = this
extern inline I32 met Operator_bwxor other:@this = this
extern inline I32 met Operator_bwand other:@this = this
extern inline I32 met Operator_rshift by:Uint = this
extern inline I32 met Operator_bwnot = this
extern inline I32 met! Operator_assign_bwor other:@this
extern inline I32 met! Operator_assign_bwxor other:@this
extern inline I32 met! Operator_assign_bwand other:@this
extern inline I32 met! Operator_assign_rshift by:Uint
inline I32 met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline I32 met Unsigned = U32
	assert self >= 0
	return self.Bitwise_unsigned
inline I32 met Try_unsigned = Error_range, U32
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I32 met Bitwise_unsigned = U32
extern inline I32 met Trim_i8 = I8
extern inline I32 met Trim_i16 = I16
extern inline I32 met To_i64 = I64
extern inline I32 met To_int = Int
extern inline I32 met Round_float = Float
extern inline I32 met Exact_double = Double
extern I32 met Show st:@#`Fmt_state

---- TODO Integer conversions to floats must be extended with:
-- met Try_exact_float = Error_range, Float
-- met Unsafe_exact_float = Float
-- met Bitwise_float = Float

extern inline struct I64 =
	isa `Native_sized_signed_integer
	alias This_signed = this
	alias This_unsigned = U64
inline I64 fun MIN = this
	return -0x7fffffffffffffff
inline I64 fun MAX = this
	return 0x8000000000000000
extern inline I64 met Operator_eq other:@this = Bool
extern inline I64 met Operator_ne other:@this = Bool
extern inline I64 met Operator_le other:@this = Bool
extern inline I64 met Operator_lt other:@this = Bool
extern inline I64 met Operator_gt other:@this = Bool
extern inline I64 met Operator_ge other:@this = Bool
extern inline I64 met Operator_plus other:@this = this
extern inline I64 met Operator_minus other:@this = this
extern inline I64 met Operator_divide other:@this = this
extern inline I64 met Operator_modulo other:@this = this
extern inline I64 met Operator_times other:@this = this
extern inline I64 met Operator_uminus = this
extern inline I64 met! Operator_assign_plus other:@this
extern inline I64 met! Operator_assign_minus other:@this
extern inline I64 met! Operator_assign_divide other:@this
extern inline I64 met! Operator_assign_modulo other:@this
extern inline I64 met! Operator_assign_times other:@this
extern inline I64 met Operator_bwor other:@this = this
extern inline I64 met Operator_bwxor other:@this = this
extern inline I64 met Operator_bwand other:@this = this
extern inline I64 met Operator_rshift by:Uint = this
extern inline I64 met Operator_bwnot = this
extern inline I64 met! Operator_assign_bwor other:@this
extern inline I64 met! Operator_assign_bwxor other:@this
extern inline I64 met! Operator_assign_bwand other:@this
extern inline I64 met! Operator_assign_rshift by:Uint
inline I64 met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline I64 met Unsigned = U64
	assert self >= 0
	return self.Bitwise_unsigned
inline I64 met Try_unsigned = Error_range, U64
	if Likely <- self >= 0
		return OK, self.Bitwise_unsigned
	return INVAL_RANGE, 0
extern inline I64 met Bitwise_unsigned = U64
extern inline I64 met Trim_i8 = I8
extern inline I64 met Trim_i16 = I16
extern inline I64 met Trim_i32 = I32
inline I64 met To_i64 = I64
	return self.
extern inline I64 met force_int = Int
extern inline I64 met force_intptr = Intptr
inline I64 met To_int = Int
	assert self >= Int.MIN.To_i64 and self <= Int.MAX.To_i64
	return self.force_int
inline I64 met Try_int = Error_range, Int
	if Likely <- self >= Int.MIN.To_i64 and self <= Int.MAX.To_i64
		return OK, self.force_int
	return OK, 0
extern inline I64 met Round_float = Float
extern inline I64 met Round_double = Double
extern I64 met Show st:@#`Fmt_state

extern inline struct U8 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I8
inline U8 fun MIN = this
	return 0
inline U8 fun MAX = this
	return 0xff
extern inline U8 met Operator_eq other:@this = Bool
extern inline U8 met Operator_ne other:@this = Bool
extern inline U8 met Operator_le other:@this = Bool
extern inline U8 met Operator_lt other:@this = Bool
extern inline U8 met Operator_gt other:@this = Bool
extern inline U8 met Operator_ge other:@this = Bool
extern inline U8 met Operator_plus other:@this = this
extern inline U8 met Operator_minus other:@this = this
extern inline U8 met Operator_divide other:@this = this
extern inline U8 met Operator_modulo other:@this = this
extern inline U8 met Operator_times other:@this = this
extern inline U8 met Operator_uminus = this
extern inline U8 met! Operator_assign_plus other:@this
extern inline U8 met! Operator_assign_minus other:@this
extern inline U8 met! Operator_assign_divide other:@this
extern inline U8 met! Operator_assign_modulo other:@this
extern inline U8 met! Operator_assign_times other:@this
extern inline U8 met Operator_ovplus other:@this = this
extern inline U8 met Operator_ovminus other:@this = this
extern inline U8 met Operator_ovdivide other:@this = this
extern inline U8 met Operator_ovmodulo other:@this = this
extern inline U8 met Operator_ovtimes other:@this = this
extern inline U8 met Operator_ovuminus = this
extern inline U8 met! Operator_assign_ovplus other:@this
extern inline U8 met! Operator_assign_ovminus other:@this
extern inline U8 met! Operator_assign_ovdivide other:@this
extern inline U8 met! Operator_assign_ovmodulo other:@this
extern inline U8 met! Operator_assign_ovtimes other:@this
extern inline U8 met Operator_bwor other:@this = this
extern inline U8 met Operator_bwxor other:@this = this
extern inline U8 met Operator_bwand other:@this = this
extern inline U8 met Operator_ovlshift by:Uint = this
extern inline U8 met Operator_rshift by:Uint = this
extern inline U8 met Operator_bwnot = this
extern inline U8 met! Operator_assign_bwor other:@this
extern inline U8 met! Operator_assign_bwxor other:@this
extern inline U8 met! Operator_assign_bwand other:@this
extern inline U8 met! Operator_assign_ovlshift by:Uint
extern inline U8 met! Operator_assign_rshift by:Uint
inline U8 met Signed = I8
	assert self <= I8.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U8 met Try_signed = Error_range, I8
	if Likely <- self <= I8.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U8 met Bitwise_signed = I8
extern inline U8 met To_u16 = U16
extern inline U8 met To_u32 = U32
extern inline U8 met To_u64 = U64
extern inline U8 met To_uint = Uint
extern inline U8 met Exact_float = Float
extern inline U8 met Exact_double = Double
extern U8 met Show st:@#`Fmt_state

extern inline struct U16 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I16
inline U16 fun MIN = this
	return 0
inline U16 fun MAX = this
	return 0xffff
extern inline U16 met Operator_eq other:@this = Bool
extern inline U16 met Operator_ne other:@this = Bool
extern inline U16 met Operator_le other:@this = Bool
extern inline U16 met Operator_lt other:@this = Bool
extern inline U16 met Operator_gt other:@this = Bool
extern inline U16 met Operator_ge other:@this = Bool
extern inline U16 met Operator_plus other:@this = this
extern inline U16 met Operator_minus other:@this = this
extern inline U16 met Operator_divide other:@this = this
extern inline U16 met Operator_modulo other:@this = this
extern inline U16 met Operator_times other:@this = this
extern inline U16 met Operator_uminus = this
extern inline U16 met! Operator_assign_plus other:@this
extern inline U16 met! Operator_assign_minus other:@this
extern inline U16 met! Operator_assign_divide other:@this
extern inline U16 met! Operator_assign_modulo other:@this
extern inline U16 met! Operator_assign_times other:@this
extern inline U16 met Operator_ovplus other:@this = this
extern inline U16 met Operator_ovminus other:@this = this
extern inline U16 met Operator_ovdivide other:@this = this
extern inline U16 met Operator_ovmodulo other:@this = this
extern inline U16 met Operator_ovtimes other:@this = this
extern inline U16 met Operator_ovuminus = this
extern inline U16 met! Operator_assign_ovplus other:@this
extern inline U16 met! Operator_assign_ovminus other:@this
extern inline U16 met! Operator_assign_ovdivide other:@this
extern inline U16 met! Operator_assign_ovmodulo other:@this
extern inline U16 met! Operator_assign_ovtimes other:@this
extern inline U16 met Operator_bwor other:@this = this
extern inline U16 met Operator_bwxor other:@this = this
extern inline U16 met Operator_bwand other:@this = this
extern inline U16 met Operator_ovlshift by:Uint = this
extern inline U16 met Operator_rshift by:Uint = this
extern inline U16 met Operator_bwnot = this
extern inline U16 met! Operator_assign_bwor other:@this
extern inline U16 met! Operator_assign_bwxor other:@this
extern inline U16 met! Operator_assign_bwand other:@this
extern inline U16 met! Operator_assign_ovlshift by:Uint
extern inline U16 met! Operator_assign_rshift by:Uint
inline U16 met Signed = I16
	assert self <= I16.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U16 met Try_signed = Error_range, I16
	if Likely <- self <= I16.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U16 met Bitwise_signed = I16
extern inline U16 met Trim_u8 = U8
extern inline U16 met To_u32 = U32
extern inline U16 met To_u64 = U64
extern inline U16 met To_uint = Uint
extern inline U16 met Exact_float = Float
extern inline U16 met Exact_double = Double
extern U16 met Show st:@#`Fmt_state

extern inline struct U32 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I32
inline U32 fun MIN = this
	return 0
inline U32 fun MAX = this
	return 0xffffffff
extern inline U32 met Operator_eq other:@this = Bool
extern inline U32 met Operator_ne other:@this = Bool
extern inline U32 met Operator_le other:@this = Bool
extern inline U32 met Operator_lt other:@this = Bool
extern inline U32 met Operator_gt other:@this = Bool
extern inline U32 met Operator_ge other:@this = Bool
extern inline U32 met Operator_plus other:@this = this
extern inline U32 met Operator_minus other:@this = this
extern inline U32 met Operator_divide other:@this = this
extern inline U32 met Operator_modulo other:@this = this
extern inline U32 met Operator_times other:@this = this
extern inline U32 met Operator_uminus = this
extern inline U32 met! Operator_assign_plus other:@this
extern inline U32 met! Operator_assign_minus other:@this
extern inline U32 met! Operator_assign_divide other:@this
extern inline U32 met! Operator_assign_modulo other:@this
extern inline U32 met! Operator_assign_times other:@this
extern inline U32 met Operator_ovplus other:@this = this
extern inline U32 met Operator_ovminus other:@this = this
extern inline U32 met Operator_ovdivide other:@this = this
extern inline U32 met Operator_ovmodulo other:@this = this
extern inline U32 met Operator_ovtimes other:@this = this
extern inline U32 met Operator_ovuminus = this
extern inline U32 met! Operator_assign_ovplus other:@this
extern inline U32 met! Operator_assign_ovminus other:@this
extern inline U32 met! Operator_assign_ovdivide other:@this
extern inline U32 met! Operator_assign_ovmodulo other:@this
extern inline U32 met! Operator_assign_ovtimes other:@this
extern inline U32 met Operator_bwor other:@this = this
extern inline U32 met Operator_bwxor other:@this = this
extern inline U32 met Operator_bwand other:@this = this
extern inline U32 met Operator_ovlshift by:Uint = this
extern inline U32 met Operator_rshift by:Uint = this
extern inline U32 met Operator_bwnot = this
extern inline U32 met! Operator_assign_bwor other:@this
extern inline U32 met! Operator_assign_bwxor other:@this
extern inline U32 met! Operator_assign_bwand other:@this
extern inline U32 met! Operator_assign_ovlshift by:Uint
extern inline U32 met! Operator_assign_rshift by:Uint
inline U32 met Signed = I32
	assert self <= I32.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U32 met Try_signed = Error_range, I32
	if Likely <- self <= I32.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U32 met Bitwise_signed = I32
extern inline U32 met Trim_u8 = U8
extern inline U32 met Trim_u16 = U16
extern inline U32 met To_u64 = U64
extern inline U32 met To_uint = Uint
extern inline U32 met Round_float = Float
extern inline U32 met Exact_double = Double
extern U32 met Show st:@#`Fmt_state

extern inline struct U64 =
	isa `Native_sized_unsigned_integer
	alias This_unsigned = this
	alias This_signed = I64
inline U64 fun MIN = this
	return 0
inline U64 fun MAX = this
	return 0xffffffffffffffff
extern inline U64 met Operator_eq other:@this = Bool
extern inline U64 met Operator_ne other:@this = Bool
extern inline U64 met Operator_le other:@this = Bool
extern inline U64 met Operator_lt other:@this = Bool
extern inline U64 met Operator_gt other:@this = Bool
extern inline U64 met Operator_ge other:@this = Bool
extern inline U64 met Operator_plus other:@this = this
extern inline U64 met Operator_minus other:@this = this
extern inline U64 met Operator_divide other:@this = this
extern inline U64 met Operator_modulo other:@this = this
extern inline U64 met Operator_times other:@this = this
extern inline U64 met Operator_uminus = this
extern inline U64 met! Operator_assign_plus other:@this
extern inline U64 met! Operator_assign_minus other:@this
extern inline U64 met! Operator_assign_divide other:@this
extern inline U64 met! Operator_assign_modulo other:@this
extern inline U64 met! Operator_assign_times other:@this
extern inline U64 met Operator_ovplus other:@this = this
extern inline U64 met Operator_ovminus other:@this = this
extern inline U64 met Operator_ovdivide other:@this = this
extern inline U64 met Operator_ovmodulo other:@this = this
extern inline U64 met Operator_ovtimes other:@this = this
extern inline U64 met Operator_ovuminus = this
extern inline U64 met! Operator_assign_ovplus other:@this
extern inline U64 met! Operator_assign_ovminus other:@this
extern inline U64 met! Operator_assign_ovdivide other:@this
extern inline U64 met! Operator_assign_ovmodulo other:@this
extern inline U64 met! Operator_assign_ovtimes other:@this
extern inline U64 met Operator_bwor other:@this = this
extern inline U64 met Operator_bwxor other:@this = this
extern inline U64 met Operator_bwand other:@this = this
extern inline U64 met Operator_ovlshift by:Uint = this
extern inline U64 met Operator_rshift by:Uint = this
extern inline U64 met Operator_bwnot = this
extern inline U64 met! Operator_assign_bwor other:@this
extern inline U64 met! Operator_assign_bwxor other:@this
extern inline U64 met! Operator_assign_bwand other:@this
extern inline U64 met! Operator_assign_ovlshift by:Uint
extern inline U64 met! Operator_assign_rshift by:Uint
inline U64 met Signed = I64
	assert self <= I64.MAX.Bitwise_unsigned
	return self.Bitwise_signed
inline U64 met Try_signed = Error_range, I64
	if Likely <- self <= I64.MAX.Bitwise_unsigned
		return OK, self.Bitwise_signed
	return INVAL_RANGE, 0
extern inline U64 met Bitwise_signed = I64
extern inline U64 met Trim_u8 = U8
extern inline U64 met Trim_u16 = U16
extern inline U64 met Trim_u32 = U32
inline U64 met To_u64 = U64
	return self.
extern inline U64 met force_uint = Uint
extern inline U64 met force_uintptr = Uintptr
inline U64 met To_uint = Uint
	assert self <= Uint.MAX.To_u64
	return self.force_uint
inline U64 met Try_uint = Error_range, Uint
	if Likely <- self <= Uint.MAX.To_u64
		return OK, self.force_uint
	return INVAL_RANGE, 0
extern inline U64 met Round_float = Float
extern inline U64 met Round_double = Double
extern U64 met Show st:@#`Fmt_state

extern inline struct Int =
	isa `Native_signed_integer
	alias This_signed = this
	alias This_unsigned = Uint
	alias impl = I64
inline Int fun MIN = this
	return this.impl.MIN.force_int
inline Int fun MAX = this
	return this.impl.MAX.force_int
extern inline Int met Operator_eq other:@this = Bool
extern inline Int met Operator_ne other:@this = Bool
extern inline Int met Operator_le other:@this = Bool
extern inline Int met Operator_lt other:@this = Bool
extern inline Int met Operator_gt other:@this = Bool
extern inline Int met Operator_ge other:@this = Bool
extern inline Int met Operator_plus other:@this = this
extern inline Int met Operator_minus other:@this = this
extern inline Int met Operator_divide other:@this = this
extern inline Int met Operator_modulo other:@this = this
extern inline Int met Operator_times other:@this = this
extern inline Int met Operator_uminus = this
extern inline Int met Operator_rshift by:Uint = final
extern inline Int met! Operator_assign_plus other:@this
extern inline Int met! Operator_assign_minus other:@this
extern inline Int met! Operator_assign_divide other:@this
extern inline Int met! Operator_assign_modulo other:@this
extern inline Int met! Operator_assign_times other:@this
extern inline Int met! Operator_assign_modulo other:@final
extern inline Int met! Operator_assign_rshift by:Uint
extern inline Int met Operator_bwor other:@final = final
extern inline Int met Operator_bwxor other:@final = final
extern inline Int met Operator_bwand other:@final = final
extern inline Int met Operator_bwnot = final
extern inline Int met! Operator_assign_bwor other:@final
extern inline Int met! Operator_assign_bwxor other:@final
extern inline Int met! Operator_assign_bwand other:@final
inline Int met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline Int met Unsigned = Uint
	assert self >= 0
	return self.force_unsigned
inline Int met Try_unsigned = Error_range, Uint
	if Likely <- self >= 0
		return OK, self.force_unsigned
	return INVAL_RANGE, 0
extern inline Int met force_unsigned = Uint
extern inline Int met Trim_i8 = I8
extern inline Int met Trim_i16 = I16
extern inline Int met Trim_i32 = I32
extern inline Int met To_i64 = I64
extern inline Int met Round_float = Float
extern inline Int met Round_double = Double
extern Int met Show st:@#`Fmt_state

extern inline struct Uint =
	isa `Native_unsigned_integer
	alias This_unsigned = this
	alias This_signed = Int
	alias impl = U64
inline Uint fun MIN = this
	return impl.MIN.force_uint
inline Uint fun MAX = this
	return impl.MAX.force_uint
extern inline Uint met Operator_eq other:@this = Bool
extern inline Uint met Operator_ne other:@this = Bool
extern inline Uint met Operator_le other:@this = Bool
extern inline Uint met Operator_lt other:@this = Bool
extern inline Uint met Operator_gt other:@this = Bool
extern inline Uint met Operator_ge other:@this = Bool
extern inline Uint met Operator_plus other:@this = this
extern inline Uint met Operator_minus other:@this = this
extern inline Uint met Operator_divide other:@this = this
extern inline Uint met Operator_modulo other:@this = this
extern inline Uint met Operator_times other:@this = this
extern inline Uint met Operator_uminus = this
extern inline Uint met Operator_rshift by:Uint = final
extern inline Uint met! Operator_assign_plus other:@this
extern inline Uint met! Operator_assign_minus other:@this
extern inline Uint met! Operator_assign_divide other:@this
extern inline Uint met! Operator_assign_modulo other:@this
extern inline Uint met! Operator_assign_times other:@this
extern inline Uint met! Operator_assign_rshift by:Uint
extern inline Uint met Operator_bwor other:@final = final
extern inline Uint met Operator_bwxor other:@final = final
extern inline Uint met Operator_bwand other:@final = final
extern inline Uint met Operator_bwnot = final
extern inline Uint met! Operator_assign_bwor other:@final
extern inline Uint met! Operator_assign_bwxor other:@final
extern inline Uint met! Operator_assign_bwand other:@final
inline Uint met Signed = Int
	assert self <= Int.MAX.force_unsigned
	return self.force_signed
inline Uint met Try_signed = Error_range, Int
	if Likely <- self <= Int.MAX.force_unsigned
		return OK, self.force_signed
	return INVAL_RANGE, 0
extern inline Uint met force_signed = Int
extern inline Uint met Trim_u8 = U8
extern inline Uint met Trim_u16 = U16
extern inline Uint met Trim_u32 = U32
extern inline Uint met To_u64 = U64
extern inline Uint met Round_float = Float
extern inline Uint met Round_double = Double
extern Uint met Show st:@#`Fmt_state

extern inline struct Intptr =
	isa `Native_signed_integer
	alias This_unsigned = Uintptr
	alias This_signed = this
	alias impl = I64
inline Intptr fun MIN = this
	return impl.MIN.force_intptr
inline Intptr fun MAX = this
	return impl.MAX.force_intptr
extern inline Intptr met Operator_eq other:@this = Bool
extern inline Intptr met Operator_ne other:@this = Bool
extern inline Intptr met Operator_le other:@this = Bool
extern inline Intptr met Operator_lt other:@this = Bool
extern inline Intptr met Operator_gt other:@this = Bool
extern inline Intptr met Operator_ge other:@this = Bool
extern inline Intptr met Operator_plus other:@this = this
extern inline Intptr met Operator_minus other:@this = this
extern inline Intptr met Operator_divide other:@this = this
extern inline Intptr met Operator_modulo other:@this = this
extern inline Intptr met Operator_times other:@this = this
extern inline Intptr met Operator_uminus = this
extern inline Intptr met Operator_rshift by:Uint = final
extern inline Intptr met! Operator_assign_plus other:@this
extern inline Intptr met! Operator_assign_minus other:@this
extern inline Intptr met! Operator_assign_divide other:@this
extern inline Intptr met! Operator_assign_modulo other:@this
extern inline Intptr met! Operator_assign_times other:@this
extern inline Intptr met! Operator_assign_rshift by:Uint
extern inline Intptr met Operator_bwor other:@final = final
extern inline Intptr met Operator_bwxor other:@final = final
extern inline Intptr met Operator_bwand other:@final = final
extern inline Intptr met Operator_bwnot = final
extern inline Intptr met! Operator_assign_bwor other:@final
extern inline Intptr met! Operator_assign_bwxor other:@final
extern inline Intptr met! Operator_assign_bwand other:@final
inline Intptr met Abs = this
	if self >= 0
		return self.
	else
		return -self.
inline Intptr met Unsigned = Uintptr
	assert self >= 0
	return self.force_unsigned
inline Intptr met Try_unsigned = Error_range, Uintptr
	if Likely <- self >= 0
		return OK, self.force_unsigned
	return INVAL_RANGE, 0
extern inline Intptr met force_unsigned = Uintptr
extern inline Intptr met To_i64 = I64
extern Intptr met Show st:@#`Fmt_state

extern inline struct Uintptr =
	isa `Native_unsigned_integer
	alias This_unsigned = this
	alias This_signed = Intptr
	alias impl = U64
inline Uintptr fun MIN = this
	return impl.MIN.force_uintptr
inline Uintptr fun MAX = this
	return impl.MAX.force_uintptr
extern inline Uintptr met Operator_eq other:@this = Bool
extern inline Uintptr met Operator_ne other:@this = Bool
extern inline Uintptr met Operator_le other:@this = Bool
extern inline Uintptr met Operator_lt other:@this = Bool
extern inline Uintptr met Operator_gt other:@this = Bool
extern inline Uintptr met Operator_ge other:@this = Bool
extern inline Uintptr met Operator_plus other:@this = this
extern inline Uintptr met Operator_minus other:@this = this
extern inline Uintptr met Operator_divide other:@this = this
extern inline Uintptr met Operator_modulo other:@this = this
extern inline Uintptr met Operator_times other:@this = this
extern inline Uintptr met Operator_uminus = this
extern inline Uintptr met Operator_rshift by:Uint = final
extern inline Uintptr met! Operator_assign_plus other:@this
extern inline Uintptr met! Operator_assign_minus other:@this
extern inline Uintptr met! Operator_assign_divide other:@this
extern inline Uintptr met! Operator_assign_modulo other:@this
extern inline Uintptr met! Operator_assign_times other:@this
extern inline Uintptr met! Operator_assign_rshift by:Uint
extern inline Uintptr met Operator_bwor other:@final = final
extern inline Uintptr met Operator_bwxor other:@final = final
extern inline Uintptr met Operator_bwand other:@final = final
extern inline Uintptr met Operator_bwnot = final
extern inline Uintptr met! Operator_assign_bwor other:@final
extern inline Uintptr met! Operator_assign_bwxor other:@final
extern inline Uintptr met! Operator_assign_bwand other:@final
inline Uintptr met Signed = Intptr
	assert self <= Intptr.MAX.force_unsigned
	return self.force_signed
inline Uintptr met Try_signed = Error_range, Intptr
	if Likely <- self <= Intptr.MAX.force_unsigned
		return OK, self.force_signed
	return INVAL_RANGE, 0
extern inline Uintptr met force_signed = Intptr
extern inline Uintptr met To_u64 = U64
extern Uintptr met Show st:@#`Fmt_state

extern inline struct Float =
	isa `Native_floating
extern inline Float met Operator_eq other:@this = Bool
extern inline Float met Operator_ne other:@this = Bool
extern inline Float met Operator_le other:@this = Bool
extern inline Float met Operator_lt other:@this = Bool
extern inline Float met Operator_gt other:@this = Bool
extern inline Float met Operator_ge other:@this = Bool
extern inline Float met Operator_plus other:@this = this
extern inline Float met Operator_minus other:@this = this
extern inline Float met Operator_divide other:@this = this
extern inline Float met Operator_times other:@this = this
extern inline Float met Operator_uminus = this
extern inline Float met! Operator_assign_plus other:@this
extern inline Float met! Operator_assign_minus other:@this
extern inline Float met! Operator_assign_divide other:@this
extern inline Float met! Operator_assign_times other:@this
extern inline Float met Trim_i8 = I8
extern inline Float met Trim_i16 = I16
extern inline Float met To_i32 = I32
extern inline Float met To_i64 = I64
-- Exact_double is exact except for INF.
extern inline Float met Exact_double = Double
extern inline Float met force_round_int = Int
extern inline Float met force_round_uint = Uint
inline Float met Round_int = Int
	assert self >= Int.MIN.Round_float and self <= Int.MAX.Round_float
	return self.force_round_int
inline Float met Try_round_int = Error_range, Int
	if Likely <- self >= Int.MIN.Round_float and self <= Int.MAX.Round_float
		return OK, self.force_round_int
	return INVAL_RANGE, 0
inline Float met Round_uint = Uint
	assert self >= Uint.MIN.Round_float and self <= Uint.MAX.Round_float
	return self.force_round_uint
inline Float met Try_round_uint = Error_range, Uint
	if Likely <- self >= Uint.MIN.Round_float and self <= Uint.MAX.Round_float
		return OK, self.force_round_uint
	return INVAL_RANGE, 0
extern Float met Show st:@#`Fmt_state

extern inline struct Double =
	isa `Native_floating
extern inline Double met Operator_eq other:@this = Bool
extern inline Double met Operator_ne other:@this = Bool
extern inline Double met Operator_le other:@this = Bool
extern inline Double met Operator_lt other:@this = Bool
extern inline Double met Operator_gt other:@this = Bool
extern inline Double met Operator_ge other:@this = Bool
extern inline Double met Operator_plus other:@this = this
extern inline Double met Operator_minus other:@this = this
extern inline Double met Operator_divide other:@this = this
extern inline Double met Operator_times other:@this = this
extern inline Double met Operator_uminus = this
extern inline Double met! Operator_assign_plus other:@this
extern inline Double met! Operator_assign_minus other:@this
extern inline Double met! Operator_assign_divide other:@this
extern inline Double met! Operator_assign_times other:@this
extern inline Double met Trim_i8 = I8
extern inline Double met Trim_i16 = I16
extern inline Double met Trim_i32 = I32
extern inline Double met To_i64 = I64
extern inline Double met Round_float = Float
extern inline Double met force_round_int = Int
extern inline Double met force_round_uint = Uint
inline Double met Round_int = Int
	assert self >= Int.MIN.Round_double and self <= Int.MAX.Round_double
	return self.force_round_int
inline Double met Try_round_int = Error_range, Int
	if Likely <- self >= Int.MIN.Round_double and self <= Int.MAX.Round_double
		return OK, self.force_round_int
	return INVAL_RANGE, 0
inline Double met Round_uint = Uint
	assert self >= Uint.MIN.Round_double and self <= Uint.MAX.Round_double
	return self.force_round_uint
inline Double met Try_round_uint = Error_range, Uint
	if Likely <- self >= Uint.MIN.Round_double and self <= Uint.MAX.Round_double
		return OK, self.force_round_uint
	return INVAL_RANGE, 0
extern Double met Show st:@#`Fmt_state

inline struct Bounds =
	First	:Bool
	Last	:Bool
	Begin	:Uint
	End	:Uint

inline Bounds (met t:`Any c:(`Random_container t)) Range_of v:@c = Range
	if self.First and self.Last
		return {Begin=0 End=v.Count}
	elif self.First
		return {Begin=0 End=self.End}
	elif self.Last
		return {Begin=self.Begin End=v.Count}
	else
		return {Begin=0 End=v.Count}

inline struct Range =
	isa `Trivial_copy `Trivial_equality `Trivial_ctor `Return_by_copy
	Begin	:Uint
	End	:Uint

inline Range met Count = Uint
	if self.Begin >= self.End
		return 0
	return self.End - self.Begin

example assert ({Begin=1 End=0}:Range).Count == 0

inline Range met With_offset offset:Uint = this
	return {Begin=self.Begin+offset End=self.End+offset}

inline Range met All = this
	return self.

inline Range met Operator_at p:Uint = Uint
	return p

inline Range met Operator_sub begin:Uint end:Uint = this
	assert begin >= self.Begin and end <= self.End
	return {Begin=begin End=end}

inline Range met Iter = Index_iterator
	return { r=self. p=self.Begin }

inline Range met Reverse_iter = Reverse_index_iterator
	return { it=self.Iter }

inline struct Index_iterator =
	isa (`Iterator Uint) `Trivial_copy `Trivial_ctor
	r	:Range
	p	:Uint

inline Index_iterator met Has_next = Bool
	return self.p < self.r.End

inline Index_iterator met! Next = Uint
	let nxt = self.p
	self!p += 1
	return nxt

inline struct Reverse_index_iterator =
	isa (`Iterator Uint) `Trivial_copy `Trivial_ctor
	it	:Index_iterator

inline Reverse_index_iterator met Has_next = Bool
	return self.it.Has_next

inline Reverse_index_iterator met! Next = Uint
	let nxt = self!it!Next
	return self.it.r.End - 1 - nxt + self.it.r.Begin

example
	let r = {Begin=2 End=10}:Range
	assert r.Count == 8
	let j = 7 such
		for i in r.Reverse_iter
			assert i >= r.Begin and i < r.End
			assert j == i - r.Begin
			j -= 1

example
	let r = {Begin=10 End=20}:Range
	assert r.Count == 10
	let n = 0 such
		foreach i in r
			assert i >= r.Begin and i < r.End
			assert n == i - r.Begin
			n += 1

intf `Slice_compatible t:`Any =
	fun From_slice c:[]t = final


extern inline (fun$ i:`Any j:`Any) Dyncast x:@$j = @$i


extern fun Abort

extern inline fun Likely x:Bool = Bool
extern inline fun Unlikely x:Bool = Bool

inline (fun t:`Any) Unused x:t
	noop

inline (fun t:`Numeric) Min a:t b:t = t
	if a <= b
		return a
	else
		return b

inline (fun t:`Numeric) Max a:t b:t = t
	if a >= b
		return a
	else
		return b

inline struct Error =
	isa `Generalized_boolean `Trivial_order `Show
	Why	:?@String -- FIXME Make it ?@`Show

	let OK = {}:this
	let UNKNOWN = {Why=@"Unknown error"}:this
	let INVAL = {Why=@"invalid value"}:this
	let INVAL_RANGE = {Why=@"invalid value range"}:this

Error met Operator_test = Bool
	return (self.Why)?

Error met Show st:@#`Fmt_state
	if (self.Why)?
		"Error: ".Show st
		self.Why.Show st
	else
		"Success".Show st

fun Drop err:Error
	noop

fun Fatal err:Error
	Eprn "Fatal:" err
	Abort


extern inline struct Varargint =
	isa `Trivial_copy `Trivial_ctor

extern inline Varargint met Count_left = Uint

intf `no_dyn_iterator r:`Any_any_ref =
	isa `Prevent_dyn (`Iterator r)

opaque struct Vararg r:`Any_any_ref =
	isa (`no_dyn_iterator r)
	isa `Trivial_copy -- FIXME: remove `Trivial_copy, needed by bootstrap
	ap	:Varargint

inline Vararg met Has_next = Bool
	return self.Count_left > 0

extern Vararg met! Next = r

inline Vararg met Count_left = Uint
	return self.ap.Count_left


intf `Any_environment =

-- FIXME? Instead of 'declaring', we could use 'final'.
intf `Environment declaring:`Any =
	isa `Any_environment
	-- Implementation of these methods is generated by the compiler.
	met Parent = @!declaring
	met! Install where:@!@!declaring
	met# Uninstall where:@!@!declaring

--intf `Debugenv =
--  isa (`Environment this)
--  met! _Assert cond:Bool ?expr:?@String
--  met! _pre cond:Bool ?expr:?@String
--  met! _post cond:Bool ?expr:?@String
--  met! _invariant cond:Bool ?expr:?@String
--  met! _example cond:Bool ?expr:?@String
--
--  met! Pr ?sep:?@String ...v:(vararg @`Showable)
--  met! Prn ?sep:?@String ...v:(vararg @`Showable)
--
--struct Debugenv =
--  export isa `Debugenv


--atom identity_transitivity P =
--  forall P, x
--    P x => forall y
--      y === x => P y
--atom equality_transitivity P =
--  identity_transitivity P
--  forall P, x
--    P x => forall y
--      y == x => P y
--
--atom nonnull x =
--  equality_transitivity this
--
--atom has_tag tag x =
--  x ==| tag

inline struct Codeloc =
	File	:String
	Line	:Uint
	Col	:Uint
	Expr	:String

fun Failed_at c:?@Codeloc
	if c !== null
		Epr sep=':' c.File c.Line c.Col
		Eprn ": failed '" c.Expr "'"
	Abort

inline fun Assert__ cond:Bool ?_Ncodeloc:?@Codeloc
	if Likely cond
		return
	else
		Failed_at _Ncodeloc

inline fun Unreached
	Eprn "Unreached"
	Abort

inline fun Pre__ cond:Bool ?_Ncodeloc:?@Codeloc
	if Likely cond
		return
	else
		Failed_at _Ncodeloc

inline fun Post__ cond:Bool ?_Ncodeloc:?@Codeloc
	if Likely cond
		return
	else
		Failed_at _Ncodeloc

inline fun Invariant__ cond:Bool ?_Ncodeloc:?@Codeloc
	if Likely cond
		return
	else
		Failed_at _Ncodeloc
