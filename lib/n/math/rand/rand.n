-- See LICENSE for details. Originally derived from go/src/pkg/math/rand
-- Copyright 2009 The Go Authors. All rights reserved.

-- Random numbers are generated by a Source. Top-level functions, such as
-- Float64 and Int, use a default shared Source that produces a deterministic
-- sequence of values each time a program is run. Use the Seed function to
-- initialize the default Source if different behavior is required for each run.
-- The default Source is safe for concurrent use by multiple goroutines.
--
-- For random numbers suitable for security-sensitive work, see the
-- n.crypto.cryptorand package.

from n import *
import n.math

intf `Source =
	met! Seed seed:U64
	met! Uniform_u64 = U64

globalenv Source:@#`Source

fun Install_sys within Source
	let rng = Alloc rng_source
	rng!Seed 1

	let header = Alloc_uncounted (Envheader @#`Source)
	header#Env = rng
	Globalenv_install Source header

struct Random =
	src	:@#`Source

Random fun Init = r:Random within Source
	r!src = Source

Random met! Seed seed:U64
	self!src!Seed seed

Random met! Uniform_u64 = U64
	return self!src!Uniform_u64

-- Bounded_uniform_u64 returns a non-negative pseudo-random number
-- in [0,bound).
Random met! Bounded_uniform_u64 bound:U64 = U64
	pre bound > 0
	if bound & (bound-1) == 0 -- bound is power of two, so we can mask
		return self.Uniform_u64 & (bound - 1)

	let max = (1 ov<< 63) - 1 - (1 ov<< 63) % bound
	let v = self.Uniform_u64
	while v > max
		v = self.Uniform_u64
	return v % bound

-- Uniform_double returns, as a Double, a pseudo-random number in [0.0,1.0).
Random met! Uniform_double = Double
	return (self!Bounded_uniform_u64 1 ov<< 53).Round_double
		\ / (1:U64 ov<< 53).Round_double

-- Uniform_float returns, as a Float, a pseudo-random number in [0.0,1.0).
Random met! Uniform_float = Float
	return (self!Bounded_uniform_u64 1 ov<< 24).Round_float
		\ / (1:U64 ov<< 24).Round_float

-- Permutation returns, as a slice of n ints, a pseudo-random permutation of the
-- integers [0,n).
Random met! Permutation n:Uint = m:(Buf Uint)
	m#Resize n
	foreach i over 1 .. n
		let j = (self!Bounded_uniform_u64 i.U64+1).To_uint
		m![i]! = m.[j]
		m![j]! = i
	return m

Random met! Read_full b:[!]U8 = [!]U8, Error
	var i
	while i < b.Count
		var val = self.Uniform_u64
		var j
		while j < b.Count and j < 8
			b![i+j]! = val.Trim_u8
			val >>= 8
			j += 1
		i += 8
	return b, OK
