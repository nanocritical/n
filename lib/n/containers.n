from n.builtins import *

alias `locus = {`Has_equality `Copyable_but_owned}
alias `fwd_locus = {`Has_equality `Copyable_but_owned `Ordered}
alias `bidir_locus = {`Has_equality `Copyable_but_owned `Ordered}

intf `Random_container t:`Any =
	met Count = Uint

intf `Iterator t:`Copyable =
	met Has_next = Bool
	met! Next = t

inline struct Bounds =
	f	:Bool
	l	:Bool
	b	:Uint
	e	:Uint

inline Bounds (met t:`Any c:(`Random_container t)) Range_of v:@c = Range
	if self.f and self.l
		return {b=0 e=v.Count}
	elif self.f
		return {b=0 e=self.e}
	elif self.l
		return {b=self.b e=v.Count}
	else
		return {b=0 e=v.Count}

inline struct Range =
	isa `Trivial_copy `Trivial_equality `Trivial_ctor `Return_by_copy
	b	:Uint
	e	:Uint

Range met Begin = Uint
	return self.b

Range met End = Uint
	return self.e

Range met Count = Uint
	return self.e - self.b

Range met sub begin:Uint end:Uint = this
	let r:this
	such
		if begin < self.Begin or end > self.End
			Abort
		r = {b=begin e=end}
	return r

Range met with_offset offset:Uint = this
	let r = {b=self.Begin+offset e=self.End+offset}
	return r

Range met All = this
	return self.

Range met Iter = Index_iterator
	return { r=self. }


inline struct Index_iterator =
	isa (`Iterator Uint) `Trivial_copy `Trivial_ctor
	r	:Range
	p	:Uint

Index_iterator met Has_next = Bool
	return self.p < self.r.End

Index_iterator met! Next = Uint
	let r = self.p
	self!p += 1
	return r
