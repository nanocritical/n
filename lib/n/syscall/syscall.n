from n import *
import n.cstring
import n.unsafe
import n.logging
import n.io
import n.fmt

within logging.Log

-- Platform-specific types.
alias int = I32 -- On Linux, this always works.
alias clockid_t = I32
alias pid_t = I32


extern fun Strlen cs:*U8 = Uint

extern let _EPERM:int
extern let _ENOENT:int
extern let _ESRCH:int
extern let _EINTR:int
extern let _EIO:int
extern let _ENXIO:int
extern let _E2BIG:int
extern let _ENOEXEC:int
extern let _EBADF:int
extern let _ECHILD:int
extern let _EAGAIN:int
extern let _ENOMEM:int
extern let _EACCES:int
extern let _EFAULT:int
extern let _ENOTBLK:int
extern let _EBUSY:int
extern let _EEXIST:int
extern let _EXDEV:int
extern let _ENODEV:int
extern let _ENOTDIR:int
extern let _EISDIR:int
extern let _EINVAL:int
extern let _ENFILE:int
extern let _EMFILE:int
extern let _ENOTTY:int
extern let _ETXTBSY:int
extern let _EFBIG:int
extern let _ENOSPC:int
extern let _ESPIPE:int
extern let _EROFS:int
extern let _EMLINK:int
extern let _EPIPE:int
extern let _EDOM:int
extern let _ERANGE:int
extern let _EDEADLK:int
extern let _ENAMETOOLONG:int
extern let _ENOLCK:int
extern let _ENOSYS:int
extern let _ENOTEMPTY:int
extern let _ELOOP:int
extern let _EWOULDBLOCK:int
extern let _ENOMSG:int
extern let _EIDRM:int
extern let _ECHRNG:int
extern let _EL2NSYNC:int
extern let _EL3HLT:int
extern let _EL3RST:int
extern let _ELNRNG:int
extern let _EUNATCH:int
extern let _ENOCSI:int
extern let _EL2HLT:int
extern let _EBADE:int
extern let _EBADR:int
extern let _EXFULL:int
extern let _ENOANO:int
extern let _EBADRQC:int
extern let _EBADSLT:int
extern let _EDEADLOCK:int
extern let _EBFONT:int
extern let _ENOSTR:int
extern let _ENODATA:int
extern let _ETIME:int
extern let _ENOSR:int
extern let _ENONET:int
extern let _ENOPKG:int
extern let _EREMOTE:int
extern let _ENOLINK:int
extern let _EADV:int
extern let _ESRMNT:int
extern let _ECOMM:int
extern let _EPROTO:int
extern let _EMULTIHOP:int
extern let _EDOTDOT:int
extern let _EBADMSG:int
extern let _EOVERFLOW:int
extern let _ENOTUNIQ:int
extern let _EBADFD:int
extern let _EREMCHG:int
extern let _ELIBACC:int
extern let _ELIBBAD:int
extern let _ELIBSCN:int
extern let _ELIBMAX:int
extern let _ELIBEXEC:int
extern let _EILSEQ:int
extern let _ERESTART:int
extern let _ESTRPIPE:int
extern let _EUSERS:int
extern let _ENOTSOCK:int
extern let _EDESTADDRREQ:int
extern let _EMSGSIZE:int
extern let _EPROTOTYPE:int
extern let _ENOPROTOOPT:int
extern let _EPROTONOSUPPORT:int
extern let _ESOCKTNOSUPPORT:int
extern let _EOPNOTSUPP:int
extern let _EPFNOSUPPORT:int
extern let _EAFNOSUPPORT:int
extern let _EADDRINUSE:int
extern let _EADDRNOTAVAIL:int
extern let _ENETDOWN:int
extern let _ENETUNREACH:int
extern let _ENETRESET:int
extern let _ECONNABORTED:int
extern let _ECONNRESET:int
extern let _ENOBUFS:int
extern let _EISCONN:int
extern let _ENOTCONN:int
extern let _ESHUTDOWN:int
extern let _ETOOMANYREFS:int
extern let _ETIMEDOUT:int
extern let _ECONNREFUSED:int
extern let _EHOSTDOWN:int
extern let _EHOSTUNREACH:int
extern let _EALREADY:int
extern let _EINPROGRESS:int
extern let _ESTALE:int
extern let _EUCLEAN:int
extern let _ENOTNAM:int
extern let _ENAVAIL:int
extern let _EISNAM:int
extern let _EREMOTEIO:int
extern let _EDQUOT:int
extern let _ENOMEDIUM:int
extern let _EMEDIUMTYPE:int
extern let _ECANCELED:int
extern let _ENOKEY:int
extern let _EKEYEXPIRED:int
extern let _EKEYREVOKED:int
extern let _EKEYREJECTED:int
extern let _EOWNERDEAD:int
extern let _ENOTRECOVERABLE:int
extern let _ERFKILL:int
extern let _EHWPOISON:int

let EPERM = {Why=*"EPERM: Operation not permitted"}:Error
let ENOENT = {Why=*"ENOENT: No such file or directory"}:Error
let ESRCH = {Why=*"ESRCH: No such process"}:Error
let EINTR = {Why=*"EINTR: Interrupted system call"}:Error
let EIO = {Why=*"EIO: I/O error"}:Error
let ENXIO = {Why=*"ENXIO: No such device or address"}:Error
let E2BIG = {Why=*"E2BIG: Argument list too long"}:Error
let ENOEXEC = {Why=*"ENOEXEC: Exec format error"}:Error
let EBADF = {Why=*"EBADF: Bad file number"}:Error
let ECHILD = {Why=*"ECHILD: No child processes"}:Error
let EAGAIN = {Why=*"EAGAIN: Try again"}:Error
let ENOMEM = {Why=*"ENOMEM: Out of memory"}:Error
let EACCES = {Why=*"EACCES: Permission denied"}:Error
let EFAULT = {Why=*"EFAULT: Bad address"}:Error
let ENOTBLK = {Why=*"ENOTBLK: Block device required"}:Error
let EBUSY = {Why=*"EBUSY: Device or resource busy"}:Error
let EEXIST = {Why=*"EEXIST: File exists"}:Error
let EXDEV = {Why=*"EXDEV: Cross-device link"}:Error
let ENODEV = {Why=*"ENODEV: No such device"}:Error
let ENOTDIR = {Why=*"ENOTDIR: Not a directory"}:Error
let EISDIR = {Why=*"EISDIR: Is a directory"}:Error
let EINVAL = {Why=*"EINVAL: Invalid argument"}:Error
let ENFILE = {Why=*"ENFILE: File table overflow"}:Error
let EMFILE = {Why=*"EMFILE: Too many open files"}:Error
let ENOTTY = {Why=*"ENOTTY: Not a typewriter"}:Error
let ETXTBSY = {Why=*"ETXTBSY: Text file busy"}:Error
let EFBIG = {Why=*"EFBIG: File too large"}:Error
let ENOSPC = {Why=*"ENOSPC: No space left on device"}:Error
let ESPIPE = {Why=*"ESPIPE: Illegal seek"}:Error
let EROFS = {Why=*"EROFS: Read-only file system"}:Error
let EMLINK = {Why=*"EMLINK: Too many links"}:Error
let EPIPE = {Why=*"EPIPE: Broken pipe"}:Error
let EDOM = {Why=*"EDOM: Math argument out of domain of func"}:Error
let ERANGE = {Why=*"ERANGE: Math result not representable"}:Error
let EDEADLK = {Why=*"EDEADLK: Resource deadlock would occur"}:Error
let ENAMETOOLONG = {Why=*"ENAMETOOLONG: File name too long"}:Error
let ENOLCK = {Why=*"ENOLCK: No record locks available"}:Error
let ENOSYS = {Why=*"ENOSYS: Function not implemented"}:Error
let ENOTEMPTY = {Why=*"ENOTEMPTY: Directory not empty"}:Error
let ELOOP = {Why=*"ELOOP: Too many symbolic links encountered"}:Error
let EWOULDBLOCK = {Why=*"EWOULDBLOCK: Operation would block"}:Error
let ENOMSG = {Why=*"ENOMSG: No message of desired type"}:Error
let EIDRM = {Why=*"EIDRM: Identifier removed"}:Error
let ECHRNG = {Why=*"ECHRNG: Channel number out of range"}:Error
let EL2NSYNC = {Why=*"EL2NSYNC: Level 2 not synchronized"}:Error
let EL3HLT = {Why=*"EL3HLT: Level 3 halted"}:Error
let EL3RST = {Why=*"EL3RST: Level 3 reset"}:Error
let ELNRNG = {Why=*"ELNRNG: Link number out of range"}:Error
let EUNATCH = {Why=*"EUNATCH: Protocol driver not attached"}:Error
let ENOCSI = {Why=*"ENOCSI: No CSI structure available"}:Error
let EL2HLT = {Why=*"EL2HLT: Level 2 halted"}:Error
let EBADE = {Why=*"EBADE: Invalid exchange"}:Error
let EBADR = {Why=*"EBADR: Invalid request descriptor"}:Error
let EXFULL = {Why=*"EXFULL: Exchange full"}:Error
let ENOANO = {Why=*"ENOANO: No anode"}:Error
let EBADRQC = {Why=*"EBADRQC: Invalid request code"}:Error
let EBADSLT = {Why=*"EBADSLT: Invalid slot"}:Error
let EDEADLOCK = {Why=*"EDEADLOCK: Resource deadlock would occur"}:Error
let EBFONT = {Why=*"EBFONT: Bad font file format"}:Error
let ENOSTR = {Why=*"ENOSTR: Device not a stream"}:Error
let ENODATA = {Why=*"ENODATA: No data available"}:Error
let ETIME = {Why=*"ETIME: Timer expired"}:Error
let ENOSR = {Why=*"ENOSR: Out of streams resources"}:Error
let ENONET = {Why=*"ENONET: Machine is not on the network"}:Error
let ENOPKG = {Why=*"ENOPKG: Package not installed"}:Error
let EREMOTE = {Why=*"EREMOTE: Object is remote"}:Error
let ENOLINK = {Why=*"ENOLINK: Link has been severed"}:Error
let EADV = {Why=*"EADV: Advertise error"}:Error
let ESRMNT = {Why=*"ESRMNT: Srmount error"}:Error
let ECOMM = {Why=*"ECOMM: Communication error on send"}:Error
let EPROTO = {Why=*"EPROTO: Protocol error"}:Error
let EMULTIHOP = {Why=*"EMULTIHOP: Multihop attempted"}:Error
let EDOTDOT = {Why=*"EDOTDOT: RFS specific error"}:Error
let EBADMSG = {Why=*"EBADMSG: Not a data message"}:Error
let EOVERFLOW = {Why=*"EOVERFLOW: Value too large for defined data type"}:Error
let ENOTUNIQ = {Why=*"ENOTUNIQ: Name not unique on network"}:Error
let EBADFD = {Why=*"EBADFD: File descriptor in bad state"}:Error
let EREMCHG = {Why=*"EREMCHG: Remote address changed"}:Error
let ELIBACC = {Why=*"ELIBACC: Can not access a needed shared library"}:Error
let ELIBBAD = {Why=*"ELIBBAD: Accessing a corrupted shared library"}:Error
let ELIBSCN = {Why=*"ELIBSCN: .lib section in a.out corrupted"}:Error
let ELIBMAX = {Why=*"ELIBMAX: Attempting to link in too many shared libraries"}:Error
let ELIBEXEC = {Why=*"ELIBEXEC: Cannot exec a shared library directly"}:Error
let EILSEQ = {Why=*"EILSEQ: Illegal byte sequence"}:Error
let ERESTART = {Why=*"ERESTART: Interrupted system call should be restarted"}:Error
let ESTRPIPE = {Why=*"ESTRPIPE: Streams pipe error"}:Error
let EUSERS = {Why=*"EUSERS: Too many users"}:Error
let ENOTSOCK = {Why=*"ENOTSOCK: Socket operation on non-socket"}:Error
let EDESTADDRREQ = {Why=*"EDESTADDRREQ: Destination address required"}:Error
let EMSGSIZE = {Why=*"EMSGSIZE: Message too long"}:Error
let EPROTOTYPE = {Why=*"EPROTOTYPE: Protocol wrong type for socket"}:Error
let ENOPROTOOPT = {Why=*"ENOPROTOOPT: Protocol not available"}:Error
let EPROTONOSUPPORT = {Why=*"EPROTONOSUPPORT: Protocol not supported"}:Error
let ESOCKTNOSUPPORT = {Why=*"ESOCKTNOSUPPORT: Socket type not supported"}:Error
let EOPNOTSUPP = {Why=*"EOPNOTSUPP: Operation not supported on transport endpoint"}:Error
let EPFNOSUPPORT = {Why=*"EPFNOSUPPORT: Protocol family not supported"}:Error
let EAFNOSUPPORT = {Why=*"EAFNOSUPPORT: Address family not supported by protocol"}:Error
let EADDRINUSE = {Why=*"EADDRINUSE: Address already in use"}:Error
let EADDRNOTAVAIL = {Why=*"EADDRNOTAVAIL: Cannot assign requested address"}:Error
let ENETDOWN = {Why=*"ENETDOWN: Network is down"}:Error
let ENETUNREACH = {Why=*"ENETUNREACH: Network is unreachable"}:Error
let ENETRESET = {Why=*"ENETRESET: Network dropped connection because of reset"}:Error
let ECONNABORTED = {Why=*"ECONNABORTED: Software caused connection abort"}:Error
let ECONNRESET = {Why=*"ECONNRESET: Connection reset by peer"}:Error
let ENOBUFS = {Why=*"ENOBUFS: No buffer space available"}:Error
let EISCONN = {Why=*"EISCONN: Transport endpoint is already connected"}:Error
let ENOTCONN = {Why=*"ENOTCONN: Transport endpoint is not connected"}:Error
let ESHUTDOWN = {Why=*"ESHUTDOWN: Cannot send after transport endpoint shutdown"}:Error
let ETOOMANYREFS = {Why=*"ETOOMANYREFS: Too many references: cannot splice"}:Error
let ETIMEDOUT = {Why=*"ETIMEDOUT: Connection timed out"}:Error
let ECONNREFUSED = {Why=*"ECONNREFUSED: Connection refused"}:Error
let EHOSTDOWN = {Why=*"EHOSTDOWN: Host is down"}:Error
let EHOSTUNREACH = {Why=*"EHOSTUNREACH: No route to host"}:Error
let EALREADY = {Why=*"EALREADY: Operation already in progress"}:Error
let EINPROGRESS = {Why=*"EINPROGRESS: Operation now in progress"}:Error
let ESTALE = {Why=*"ESTALE: Stale file handle"}:Error
let EUCLEAN = {Why=*"EUCLEAN: Structure needs cleaning"}:Error
let ENOTNAM = {Why=*"ENOTNAM: Not a XENIX named type file"}:Error
let ENAVAIL = {Why=*"ENAVAIL: No XENIX semaphores available"}:Error
let EISNAM = {Why=*"EISNAM: Is a named type file"}:Error
let EREMOTEIO = {Why=*"EREMOTEIO: Remote I/O error"}:Error
let EDQUOT = {Why=*"EDQUOT: Quota exceeded"}:Error
let ENOMEDIUM = {Why=*"ENOMEDIUM: No medium found"}:Error
let EMEDIUMTYPE = {Why=*"EMEDIUMTYPE: Wrong medium type"}:Error
let ECANCELED = {Why=*"ECANCELED: Operation Canceled"}:Error
let ENOKEY = {Why=*"ENOKEY: Required key not available"}:Error
let EKEYEXPIRED = {Why=*"EKEYEXPIRED: Key has expired"}:Error
let EKEYREVOKED = {Why=*"EKEYREVOKED: Key has been revoked"}:Error
let EKEYREJECTED = {Why=*"EKEYREJECTED: Key was rejected by service"}:Error
let EOWNERDEAD = {Why=*"EOWNERDEAD: Owner died"}:Error
let ENOTRECOVERABLE = {Why=*"ENOTRECOVERABLE: State not recoverable"}:Error
let ERFKILL = {Why=*"ERFKILL: Operation not possible due to RF-kill"}:Error
let EHWPOISON = {Why=*"EHWPOISON: Memory page has hardware error"}:Error

fun convert_error code:int = Error
	match code
	| 0 -> return OK
	| _EPERM -> return EPERM
	| _ENOENT -> return ENOENT
	| _ESRCH -> return ESRCH
	| _EINTR -> return EINTR
	| _EIO -> return EIO
	| _ENXIO -> return ENXIO
	| _E2BIG -> return E2BIG
	| _ENOEXEC -> return ENOEXEC
	| _EBADF -> return EBADF
	| _ECHILD -> return ECHILD
	| _EAGAIN -> return io.WOULD_BLOCK
	| _ENOMEM -> return ENOMEM
	| _EACCES -> return EACCES
	| _EFAULT -> return EFAULT
	| _ENOTBLK -> return ENOTBLK
	| _EBUSY -> return EBUSY
	| _EEXIST -> return EEXIST
	| _EXDEV -> return EXDEV
	| _ENODEV -> return ENODEV
	| _ENOTDIR -> return ENOTDIR
	| _EISDIR -> return EISDIR
	| _EINVAL -> return EINVAL
	| _ENFILE -> return ENFILE
	| _EMFILE -> return EMFILE
	| _ENOTTY -> return ENOTTY
	| _ETXTBSY -> return ETXTBSY
	| _EFBIG -> return EFBIG
	| _ENOSPC -> return ENOSPC
	| _ESPIPE -> return ESPIPE
	| _EROFS -> return EROFS
	| _EMLINK -> return EMLINK
	| _EPIPE -> return EPIPE
	| _EDOM -> return EDOM
	| _ERANGE -> return ERANGE
	| _EDEADLK -> return EDEADLK
	| _ENAMETOOLONG -> return ENAMETOOLONG
	| _ENOLCK -> return ENOLCK
	| _ENOSYS -> return ENOSYS
	| _ENOTEMPTY -> return ENOTEMPTY
	| _ELOOP -> return ELOOP
	| _EWOULDBLOCK -> return io.WOULD_BLOCK
	| _ENOMSG -> return ENOMSG
	| _EIDRM -> return EIDRM
	| _ECHRNG -> return ECHRNG
	| _EL2NSYNC -> return EL2NSYNC
	| _EL3HLT -> return EL3HLT
	| _EL3RST -> return EL3RST
	| _ELNRNG -> return ELNRNG
	| _EUNATCH -> return EUNATCH
	| _ENOCSI -> return ENOCSI
	| _EL2HLT -> return EL2HLT
	| _EBADE -> return EBADE
	| _EBADR -> return EBADR
	| _EXFULL -> return EXFULL
	| _ENOANO -> return ENOANO
	| _EBADRQC -> return EBADRQC
	| _EBADSLT -> return EBADSLT
	| _EDEADLOCK -> return EDEADLOCK
	| _EBFONT -> return EBFONT
	| _ENOSTR -> return ENOSTR
	| _ENODATA -> return ENODATA
	| _ETIME -> return ETIME
	| _ENOSR -> return ENOSR
	| _ENONET -> return ENONET
	| _ENOPKG -> return ENOPKG
	| _EREMOTE -> return EREMOTE
	| _ENOLINK -> return ENOLINK
	| _EADV -> return EADV
	| _ESRMNT -> return ESRMNT
	| _ECOMM -> return ECOMM
	| _EPROTO -> return EPROTO
	| _EMULTIHOP -> return EMULTIHOP
	| _EDOTDOT -> return EDOTDOT
	| _EBADMSG -> return EBADMSG
	| _EOVERFLOW -> return EOVERFLOW
	| _ENOTUNIQ -> return ENOTUNIQ
	| _EBADFD -> return EBADFD
	| _EREMCHG -> return EREMCHG
	| _ELIBACC -> return ELIBACC
	| _ELIBBAD -> return ELIBBAD
	| _ELIBSCN -> return ELIBSCN
	| _ELIBMAX -> return ELIBMAX
	| _ELIBEXEC -> return ELIBEXEC
	| _EILSEQ -> return EILSEQ
	| _ERESTART -> return ERESTART
	| _ESTRPIPE -> return ESTRPIPE
	| _EUSERS -> return EUSERS
	| _ENOTSOCK -> return ENOTSOCK
	| _EDESTADDRREQ -> return EDESTADDRREQ
	| _EMSGSIZE -> return EMSGSIZE
	| _EPROTOTYPE -> return EPROTOTYPE
	| _ENOPROTOOPT -> return ENOPROTOOPT
	| _EPROTONOSUPPORT -> return EPROTONOSUPPORT
	| _ESOCKTNOSUPPORT -> return ESOCKTNOSUPPORT
	| _EOPNOTSUPP -> return EOPNOTSUPP
	| _EPFNOSUPPORT -> return EPFNOSUPPORT
	| _EAFNOSUPPORT -> return EAFNOSUPPORT
	| _EADDRINUSE -> return EADDRINUSE
	| _EADDRNOTAVAIL -> return EADDRNOTAVAIL
	| _ENETDOWN -> return ENETDOWN
	| _ENETUNREACH -> return ENETUNREACH
	| _ENETRESET -> return ENETRESET
	| _ECONNABORTED -> return ECONNABORTED
	| _ECONNRESET -> return ECONNRESET
	| _ENOBUFS -> return ENOBUFS
	| _EISCONN -> return EISCONN
	| _ENOTCONN -> return ENOTCONN
	| _ESHUTDOWN -> return ESHUTDOWN
	| _ETOOMANYREFS -> return ETOOMANYREFS
	| _ETIMEDOUT -> return ETIMEDOUT
	| _ECONNREFUSED -> return ECONNREFUSED
	| _EHOSTDOWN -> return EHOSTDOWN
	| _EHOSTUNREACH -> return EHOSTUNREACH
	| _EALREADY -> return EALREADY
	| _EINPROGRESS -> return EINPROGRESS
	| _ESTALE -> return ESTALE
	| _EUCLEAN -> return EUCLEAN
	| _ENOTNAM -> return ENOTNAM
	| _ENAVAIL -> return ENAVAIL
	| _EISNAM -> return EISNAM
	| _EREMOTEIO -> return EREMOTEIO
	| _EDQUOT -> return EDQUOT
	| _ENOMEDIUM -> return ENOMEDIUM
	| _EMEDIUMTYPE -> return EMEDIUMTYPE
	| _ECANCELED -> return ECANCELED
	| _ENOKEY -> return ENOKEY
	| _EKEYEXPIRED -> return EKEYEXPIRED
	| _EKEYREVOKED -> return EKEYREVOKED
	| _EKEYREJECTED -> return EKEYREJECTED
	| _EOWNERDEAD -> return EOWNERDEAD
	| _ENOTRECOVERABLE -> return ENOTRECOVERABLE
	| _ERFKILL -> return ERFKILL
	| _EHWPOISON -> return EHWPOISON
	| _ -> return UNKNOWN

alias Open_flags = I32
extern let O_RDONLY:Open_flags
extern let O_WRONLY:Open_flags
extern let O_RDWR:Open_flags
extern let O_APPEND:Open_flags
extern let O_ASYNC:Open_flags
extern let O_CLOEXEC:Open_flags
extern let O_CREAT:Open_flags
extern let O_DIRECT:Open_flags
extern let O_DIRECTORY:Open_flags
extern let O_DSYNC:Open_flags
extern let O_EXCL:Open_flags
extern let O_LARGEFILE:Open_flags
extern let O_NOATIME:Open_flags
extern let O_NOCTTY:Open_flags
extern let O_NOFOLLOW:Open_flags
extern let O_NONBLOCK:Open_flags
extern let O_NDELAY:Open_flags
extern let O_PATH:Open_flags
extern let O_SYNC:Open_flags
extern let O_TMPFILE:Open_flags
extern let O_TRUNC:Open_flags

alias Mode = U32
let S_IFMT = 0170000:Mode
let S_IFSOCK = 0140000:Mode
let S_IFLNK = 0120000:Mode
let S_IFREG = 0100000:Mode
let S_IFBLK = 0060000:Mode
let S_IFDIR = 0040000:Mode
let S_IFCHR = 0020000:Mode
let S_IFIFO = 0010000:Mode
let S_ISUID = 04000:Mode
let S_ISGID = 02000:Mode
let S_ISVTX = 01000:Mode
let S_IRWXU = 00700:Mode
let S_IRUSR = 00400:Mode
let S_IWUSR = 00200:Mode
let S_IXUSR = 00100:Mode
let S_IRWXG = 00070:Mode
let S_IRGRP = 00040:Mode
let S_IWGRP = 00020:Mode
let S_IXGRP = 00010:Mode
let S_IRWXO = 00007:Mode
let S_IROTH = 00004:Mode
let S_IWOTH = 00002:Mode
let S_IXOTH = 00001:Mode

extern let AT_FDCWD:I32
extern let AT_SYMLINK_FOLLOW:I32
extern let AT_SYMLINK_NOFOLLOW:I32
extern let AT_EMPTY_PATH:I32
extern let AT_REMOVEDIR:I32

-- Requires Linux >= 3.15
extern let RENAME_NOREPLACE:U32
extern let RENAME_EXCHANGE:U32

extern let SEEK_SET:I32
extern let SEEK_CUR:I32
extern let SEEK_END:I32
extern let SEEK_DATA:I32
extern let SEEK_HOLE:I32

extern let XATTR_CREATE:I32
extern let XATTR_REPLACE:I32

extern let CLOCK_REALTIME:I32
extern let CLOCK_REALTIME_COARSE:I32
extern let CLOCK_MONOTONIC:I32
extern let CLOCK_MONOTONIC_COARSE:I32
extern let CLOCK_MONOTONIC_RAW:I32
extern let CLOCK_BOOTTIME:I32
extern let CLOCK_PROCESS_CPUTIME_ID:I32
extern let CLOCK_THREAD_CPUTIME_ID:I32

inline struct Stat_t =
	Size		:Uint
	Mtime_sec	:Int
	Mtime_nsec	:U32
	Mode		:U32
	Owner		:U32
	Group		:U32

alias Mmap_prot = I32
extern let PROT_EXEC:Mmap_prot
extern let PROT_READ:Mmap_prot
extern let PROT_WRITE:Mmap_prot
extern let PROT_NONE:Mmap_prot

alias Mmap_flags = I32
extern let MAP_SHARED:Mmap_flags
extern let MAP_PRIVATE:Mmap_flags
extern let MAP_ANONYMOUS:Mmap_flags

extern let MAP_FAILED:?*U8

extern fun errno = int
extern fun unlink pathname:*U8 = int
extern fun close fd:int = int
extern fun open pathname:*U8 flags:Open_flags mode:Mode = int
extern fun openat dirfd:int pathname:*U8 flags:Open_flags mode:Mode = int
extern fun mkfifoat dirfd:int pathname:*U8 mode:Mode = int
extern fun linkat olddirfd:int oldpath:*U8 newdirfd:int newpath:*U8 flags:int = int
extern fun unlinkat dirfd:int pathname:*U8 flags:int = int
extern fun mkdirat dirfd:int pathname:*U8 mode:Mode = int
extern fun fchdir fd:int = int
extern fun symlinkat target:*U8 newdirfd:int linkpath:*U8 = int
extern fun readlinkat dirfd:int pathname:*U8 buf:!U8 bufsiz:Uint = Int
extern fun renameat olddirfd:int oldpath:*U8 newdirfd:int newpath:*U8 flags:U32 = int
extern fun write fd:int buf:*U8 count:Uint = Int
extern fun pwrite fd:int buf:*U8 count:Uint off:Uint = Int
extern fun read fd:int buf:!U8 count:Uint = Int
extern fun pread fd:int buf:!U8 count:Uint off:Uint = Int
extern fun lseek fd:int off:Int whence:int = Int
extern fun sysconf name:Int = Int
extern fun fstatat dirfd:int pathname:*U8 buf:!Stat_t flags:int = int
extern fun fdatasync fd:int = int
extern fun fsync fd:int = int
extern fun ftruncate fd:int size:Uint = int
extern fun fchown fd:int uid:Int gid:Int = int
extern fun fsetxattr fd:int name:*U8 value:*U8 size:Uint flags:int = int
extern fun fgetxattr fd:int name:*U8 value:!U8 size:Uint = Int
extern fun flistxattr fd:int list:!U8 size:Uint = Int
extern fun clock_getres clk_id:clockid_t s:!Int ns:!Int = int
extern fun clock_gettime clk_id:clockid_t s:!Int ns:!Int = int
extern fun getenv name:*U8 = ?*U8
extern fun setenv name:*U8 value:*U8 overwrite:int = int
extern fun mmap addr:Uintptr length:Uint prot:Mmap_prot flags:Mmap_flags fd:int offset:Uint = ?#U8
extern fun munmap addr:#U8 length:Uint = int
extern fun dup oldfd:int = int
extern fun dup3 oldfd:int newfd:int flags:int = int

fun sys_close fd:I32 = Error
	let ret = close fd
	if ret == 0
		return OK
	else
		return convert_error errno

fun Unlink pathname:String = Error
	let ret = unlink (cstring.Mk pathname).Rawdata
	if ret >= 0
		return OK
	return convert_error errno

fun Open pathname:String flags:Open_flags mode:Mode = Error, Fd
	let fd = open (cstring.Mk pathname).Rawdata flags mode
	if fd >= 0
		return OK, Fd.Mk fd
	return convert_error errno, {}

fun Openat dirfd:Fd pathname:String flags:Open_flags mode:Mode = Error, Fd
	let fd = openat dirfd.Sys_number (cstring.Mk pathname).Rawdata flags mode
	if fd >= 0
		return OK, Fd.Mk fd
	return convert_error errno, {}

extern let F_DUPFD:I32
extern let F_GETFD:I32
extern let F_SETFD:I32
extern let F_GETFL:I32
extern let F_SETFL:I32

extern fun fcntl_void fd:int cmd:int = int
extern fun fcntl_i32 fd:int cmd:int arg:int = int
extern fun fcntl_ref fd:int cmd:int arg:#U8 = int

fun Fcntl_void fd:Fd cmd:I32 = Error, I32
	let ret = fcntl_void fd.Sys_number cmd
	if ret >= 0
		return OK, ret
	return convert_error errno, 0

fun Fcntl_i32 fd:Fd cmd:I32 arg:int = Error, I32
	let ret = fcntl_i32 fd.Sys_number cmd arg
	if ret >= 0
		return OK, ret
	return convert_error errno, 0

fun Fcntl_ref fd:Fd cmd:I32 arg:#U8 = Error, I32
	let ret = fcntl_ref fd.Sys_number cmd arg
	if ret >= 0
		return OK, ret
	return convert_error errno, 0

fun Mkfifoat dirfd:Fd pathname:String mode:Mode = Error, Fd
	let fd = mkfifoat dirfd.Sys_number (cstring.Mk pathname).Rawdata mode
	if fd >= 0
		return OK, Fd.Mk fd
	return convert_error errno, {}

fun Linkat olddirfd:Fd oldpath:String newdirfd:Fd newpath:String flags:I32 = Error
	let ret = linkat olddirfd.Sys_number (cstring.Mk oldpath).Rawdata
		\ newdirfd.Sys_number (cstring.Mk newpath).Rawdata flags
	if ret >= 0
		return OK
	return convert_error errno

fun Unlinkat dirfd:Fd pathname:String flags:I32 = Error
	let ret = unlinkat dirfd.Sys_number (cstring.Mk pathname).Rawdata flags
	if ret >= 0
		return OK
	return convert_error errno

fun Fchdir fd:Fd = Error
	let ret = fchdir fd.Sys_number
	if ret >= 0
		return OK
	return convert_error errno

fun Mkdirat dirfd:Fd pathname:String mode:Mode = Error
	let ret = mkdirat dirfd.Sys_number (cstring.Mk pathname).Rawdata mode
	if ret >= 0
		return OK
	return convert_error errno

fun Symlinkat target:String newdirfd:Fd linkpath:String = Error
	let ret = symlinkat (cstring.Mk target).Rawdata
		\ newdirfd.Sys_number (cstring.Mk linkpath).Rawdata
	if ret >= 0
		return OK
	return convert_error errno

fun Readlinkat dirfd:Fd pathname:String buf:[!]U8 = Error, []U8
	let dst = buf!Available_elements
	let ret = readlinkat dirfd.Sys_number (cstring.Mk pathname).Rawdata
		\ dst!Unsafe_rawdata dst.Count
	if ret >= 0
		return OK, buf.[.. ret.Unsigned]
	return convert_error errno, {}

fun Renameat olddirfd:Fd oldpath:String newdirfd:Fd newpath:String flags:U32 = Error
	if flags != 0
		-- renameat2(2) isn't yet part of our minimum kernel version requirement.
		return ENOSYS
	let ret = renameat olddirfd.Sys_number (cstring.Mk oldpath).Rawdata
		\ newdirfd.Sys_number (cstring.Mk newpath).Rawdata flags
	if ret >= 0
		return OK
	return convert_error errno

fun Write fd:Fd b:[]U8 = []U8, Error
	let cnt = write fd.Sys_number b.Unsafe_rawdata b.Count
	if cnt >= 0
		let rb = b.[cnt.Unsigned ..]
		if rb.Count > 0
			-- Short write.
			let err = convert_error errno such
				-- See syscall.n.c: we clear errno before
				-- the syscall to make this comparison
				-- sound.
				if err == OK
					err = io.SHORT_WRITE
			return rb, err
		return rb, OK
	return b, convert_error errno

fun Pwrite fd:Fd b:[]U8 off:Uint = []U8, Error
	let cnt = pwrite fd.Sys_number b.Unsafe_rawdata b.Count off
	if cnt >= 0
		let rb = b.[cnt.Unsigned ..]
		if rb.Count > 0
			-- Short write.
			let err = convert_error errno such
				-- See syscall.n.c: we clear errno before
				-- the syscall to make this comparison
				-- sound.
				if err == OK
					err = io.SHORT_WRITE
			return rb, err
		return rb, OK
	return b, convert_error errno

fun Read fd:Fd b:[!]U8 = r:[!]U8, Error
	let dst = b!Available_elements
	let cnt = read fd.Sys_number dst!Unsafe_rawdata dst.Count
	if cnt >= 0
		r = b![.. b.Count+cnt.Unsigned]
		if cnt == 0 and dst.Count != 0
			return r, io.EOF
		return r, OK
	return b, convert_error errno

fun Pread fd:Fd b:[!]U8 off:Uint = r:[!]U8, Error
	let dst = b!Available_elements
	let cnt = pread fd.Sys_number dst!Unsafe_rawdata dst.Count off
	if cnt >= 0
		r = b![.. b.Count+cnt.Unsigned]
		if cnt == 0 and dst.Count != 0
			return r, io.EOF
		return r, OK
	return b, convert_error errno

fun Lseek fd:Fd off:Int whence:I32 = Error, Uint
	let r = lseek fd.Sys_number off whence
	if r >= 0
		return OK, r.Unsigned
	return convert_error errno, 0

fun Sysconf name:Int = Error, Int
	let r = sysconf name
	return convert_error errno, r

fun Fstatat dirfd:Fd pathname:String buf:!Stat_t flags:I32 = Error
	let r = fstatat dirfd.Sys_number (cstring.Mk pathname).Rawdata buf flags
	if r >= 0
		return OK
	return convert_error errno

fun Fdatasync fd:Fd = Error
	let r = fdatasync fd.Sys_number
	if r >= 0
		return OK
	return convert_error errno

fun Fsync fd:Fd = Error
	let r = fsync fd.Sys_number
	if r >= 0
		return OK
	return convert_error errno

fun Ftruncate fd:Fd size:Uint = Error
	let r = ftruncate fd.Sys_number size
	if r >= 0
		return OK
	return convert_error errno

fun Fchown fd:Fd uid:Int gid:Int = Error
	let r = fchown fd.Sys_number uid gid
	if r >= 0
		return OK
	return convert_error errno

fun Fsetxattr fd:Fd name:String value:String flags:I32 = Error
	let r = fsetxattr fd.Sys_number (cstring.Mk name).Rawdata (cstring.Mk value).Rawdata value.Count flags
	if r >= 0
		return OK
	return convert_error errno

fun Fgetxattr fd:Fd name:String value:[!]U8 flags:I32 = Error, [!]U8
	let dst = value!Available_elements
	let r = fgetxattr fd.Sys_number (cstring.Mk name).Rawdata dst!Unsafe_rawdata dst.Count
	if r >= 0
		return OK, value![.. value.Count + r.Unsigned]
	return convert_error errno, value

fun Flistxattr fd:Fd list:[!]U8 = Error, [!]U8
	let dst = list!Available_elements
	let r = flistxattr fd.Sys_number dst!Unsafe_rawdata dst.Count
	if r >= 0
		return OK, list![.. list.Count + r.Unsigned]
	return convert_error errno, list

example
	let fn = ".test_syscall"
	let e, fd = Open fn (O_CREAT | O_RDWR) 0666
	assert e == OK
	assert fd.Sys_number >= 0

	let e5 = Unlink fn
	assert e5 == OK

	let s = "test"
	let left, e2 = Write fd s.Bytes
	assert e2 == OK
	assert left.Count == 0

	let e3, roff = Lseek fd 0 SEEK_SET
	assert e3 == OK
	assert roff == 0

	let buf = {0 0 0 0 0}:[!]U8 such
		buf = buf![.. 0]
		let rd, e3 = Read fd buf
		assert e3 == OK
		assert rd.Count == 4

		let srd = String.From_bytes rd
		assert srd == s

	let e4 = Close fd
	assert fd.Sys_number < 0
	assert not fd.Is_valid
	assert e4 == OK

fun Clock_getres clk_id:I32 = Error, Int, Int
	let s, ns such
		let r = clock_getres clk_id !s !ns
		if r >= 0
			return OK, s, ns
	return convert_error errno, 0, 0

fun Clock_gettime clk_id:I32 = Error, Int, Int
	let s, ns such
		let r = clock_gettime clk_id !s !ns
		if r >= 0
			return OK, s, ns
	return convert_error errno, 0, 0

fun Getenv name:String = Error, r:Stringbuf
	let ret = getenv (cstring.Mk name).Rawdata
	if ret?
		r#Cat (cstring.Wrap_raw_cstring ret).String
		return OK, r
	return INVAL, r

fun Setenv name:String value:String = Error
	let ret = setenv (cstring.Mk name).Rawdata (cstring.Mk value).Rawdata 1
	if ret >= 0
		return OK
	return convert_error errno

fun Mmap addr:Uintptr length:Uint prot:Mmap_prot flags:Mmap_flags fd:Fd offset:Uint = Error, #U8
	let ret = mmap addr length prot flags fd.Sys_number offset
	if ret === MAP_FAILED
		return convert_error errno, nil
	return OK, ret

fun Munmap addr:#U8 length:Uint = Error
	let ret = munmap addr length
	if ret >= 0
		return OK
	return convert_error errno

fun Dup oldfd:Fd = Error, Fd
	let ret = dup oldfd.Sys_number
	if ret >= 0
		return OK, Fd.Mk ret
	return convert_error errno, {}

fun Dup3 oldfd:Fd newfd:Fd flags:I32 = Error, Fd
	let ret = dup3 oldfd.Sys_number newfd.Sys_number flags
	if ret >= 0
		return OK, Fd.Mk ret
	return convert_error errno, {}


let EAI_ADDRFAMILY = {Why=*"EAI_ADDRFAMILY: The specified network host does not have any network addresses in the requested address family."}:Error
let EAI_AGAIN = {Why=*"EAI_AGAIN: The name server returned a temporary failure indication. Try again later."}:Error
let EAI_BADFLAGS = {Why=*"EAI_BADFLAGS: hints.ai_flags contains invalid flags; or, hints.ai_flags included AI_CANONNAME and name was NULL."}:Error
let EAI_FAIL = {Why=*"EAI_FAIL: The name server returned a permanent failure indication."}:Error
let EAI_FAMILY = {Why=*"EAI_FAMILY: The requested address family is not supported."}:Error
let EAI_MEMORY = {Why=*"EAI_MEMORY: Out of memory."}:Error
let EAI_NODATA = {Why=*"EAI_NODATA: The specified network host exists, but does not have any network addresses defined."}:Error
let EAI_NONAME = {Why=*"EAI_NONAME: The node or service is not known; or both node and service are NULL; or AI_NUMERICSERV was specified in hints.ai_flags and service was not a numeric port-number string."}:Error
let EAI_SERVICE = {Why=*"EAI_SERVICE: The requested service is not available for the requested socket type. "}:Error
let EAI_SOCKTYPE = {Why=*"EAI_SOCKTYPE: The requested socket type is not supported."}:Error

extern let _EAI_ADDRFAMILY:int
extern let _EAI_AGAIN:int
extern let _EAI_BADFLAGS:int
extern let _EAI_FAIL:int
extern let _EAI_FAMILY:int
extern let _EAI_MEMORY:int
extern let _EAI_NODATA:int
extern let _EAI_NONAME:int
extern let _EAI_SERVICE:int
extern let _EAI_SOCKTYPE:int

extern let AF_INET:I32
extern let AF_INET6:I32
extern let AF_UNSPEC:I32
extern let AI_V4MAPPED:I32
extern let AI_ADDRCONFIG:I32
extern let AI_ALL:I32
extern let AI_CANONNAME:I32
extern let AI_NUMERICHOST:I32
extern let AI_PASSIVE:I32
extern let SOCK_STREAM:I32
extern let SOCK_DGRAM:I32
extern let SOCK_NONBLOCK:I32
extern let SOCK_CLOEXEC:I32
extern let IPPROTO_TCP:I32
extern let IPPROTO_UDP:I32

-- All integer values are in host byte order.
extern fun Sockaddr_ip_bytes family:I32 raw_addr:*U8 raw_addrlen:Uint = []U8
extern fun Sockaddr_ip_port family:I32 raw_addr:*U8 raw_addrlen:Uint = Uint
extern fun Sockaddr_ip_sizeof family:I32 = Uint
extern fun Sockaddr_ip buf:#[]U8 family:I32 ip6:[]U8 port:Uint

inline struct Addrinfo =
	Flags		:I32
	Family		:I32
	Socktype	:I32
	Protocol	:I32
	Raw_addrlen	:Int
	Raw_addr	:?*U8
	Canonname	:String
	Raw_next	:?*U8

extern Addrinfo fun From_raw raw:*U8 = this
Addrinfo met Ip_bytes = []U8
	return Sockaddr_ip_bytes self.Family self.Raw_addr self.Raw_addrlen.Unsigned
Addrinfo met Ip_port = Uint
	return Sockaddr_ip_port self.Family self.Raw_addr self.Raw_addrlen.Unsigned

Addrinfo met# Advance_next = has_next:Bool
	if self.Raw_next?
		self# = this.From_raw self.Raw_next
		return true
	return false

extern fun getaddrinfo node:*U8 service:?*U8 hints:*Addrinfo res:##U8 = int
extern fun freeaddrinfo res:?#U8

fun Getaddrinfo node:String service:?*String hints:*Addrinfo = Error, res:?#U8
	let _service:?*U8 such
		if service?
			_service = (cstring.Mk service).Rawdata
	res = nil
	let ret = getaddrinfo (cstring.Mk node).Rawdata _service hints #res
	if ret == 0
		return OK, res
	elif ret == _EAI_ADDRFAMILY
		return EAI_ADDRFAMILY, nil
	elif ret == _EAI_AGAIN
		return EAI_AGAIN, nil
	elif ret == _EAI_BADFLAGS
		return EAI_BADFLAGS, nil
	elif ret == _EAI_FAIL
		return EAI_FAIL, nil
	elif ret == _EAI_FAMILY
		return EAI_FAMILY, nil
	elif ret == _EAI_MEMORY
		return EAI_MEMORY, nil
	elif ret == _EAI_NODATA
		return EAI_NODATA, nil
	elif ret == _EAI_NONAME
		return EAI_NONAME, nil
	elif ret == _EAI_SERVICE
		return EAI_SERVICE, nil
	elif ret == _EAI_SOCKTYPE
		return EAI_SOCKTYPE, nil
	else
		return (convert_error errno), nil

fun Freeaddrinfo res:?#U8
	freeaddrinfo res


extern inline fun Htonl hostlong:U32 = U32
extern inline fun Htons hostshort:U16 = U16
extern inline fun Ntohl netlong:U32 = U32
extern inline fun Ntohs netshort:U16 = U16


extern fun socket domain:int type:int protocol:int = int
extern fun bind sockfd:int raw_addr:*U8 raw_addrlen:Uint = int
extern fun listen sockfd:int backlog:Int = int
extern fun accept4 sockfd:int raw_addr:#U8 raw_addrlen:#Uint flags:int = int
extern fun connect sockfd:int raw_addr:#U8 raw_addrlen:Uint = int
extern fun getsockopt sockfd:int level:int optname:int optval:#U8 optlen:#Uint = int
extern fun setsockopt sockfd:int level:int optname:int optval:*U8 optlen:Uint = int
extern fun getsockname sockfd:int raw_addr:#U8 raw_addrlen:#Uint = int

fun Socket domain:I32 type:I32 protocol:I32 = Error, Fd
	let sockfd = socket domain type protocol
	if sockfd >= 0
		return OK, Fd.Mk sockfd
	return (convert_error errno), {}

fun Bind sockfd:Fd sys_addr:[]U8 = Error
	let ret = bind sockfd.Sys_number sys_addr.Unsafe_rawdata sys_addr.Bytecount
	if ret == 0
		return OK
	return convert_error errno

fun Listen sockfd:Fd backlog:Uint = Error
	let ret = listen sockfd.Sys_number backlog.Signed
	if ret == 0
		return OK
	return convert_error errno

fun Accept4 sockfd:Fd sys_addr:#[!]U8 flags:I32 = Error, Fd
	var raw_addrlen = sys_addr.Bytecap
	let fd = accept4 sockfd.Sys_number sys_addr#Unsafe_rawdata #raw_addrlen flags
	if fd >= 0
		if raw_addrlen > sys_addr.Bytecap
			Log#Critical "truncated remote address (wrong address family?), need %s bytes" raw_addrlen
			-- Don't expose partial garbage.
			raw_addrlen = 0

		sys_addr# = sys_addr![.. raw_addrlen]
		return OK, Fd.Mk fd
	return convert_error errno, {}

fun Connect sockfd:Fd sys_addr:[!]U8 = Error
	var raw_addrlen = sys_addr.Bytecap
	let ret = connect sockfd.Sys_number sys_addr#Unsafe_rawdata raw_addrlen
	if ret == 0
		return OK
	return convert_error errno

fun Getsockname sockfd:Fd sys_addr:#[!]U8 = Error
	var raw_addrlen = sys_addr.Bytecap
	let ret = getsockname sockfd.Sys_number sys_addr#Unsafe_rawdata #raw_addrlen
	if ret == 0
		if raw_addrlen > sys_addr.Bytecap
			Log#Critical "truncated remote address (wrong address family?), need %s bytes" raw_addrlen
			-- Don't expose partial garbage.
			raw_addrlen = 0

		sys_addr# = sys_addr![.. raw_addrlen]
		return OK
	return convert_error errno

extern let SOL_SOCKET:I32
extern let SO_REUSEADDR:I32
extern let SO_ERROR:I32

fun Getsockopt_i32 sockfd:Fd level:I32 opt:I32 = Error, value:I32
	var raw:[!]U8
	raw#Unsafe_wrap ((unsafe.Cast #I32 #U8) #value) (sizeof value) (sizeof value)
	var cnt = raw.Bytecount
	let ret = getsockopt sockfd.Sys_number level opt raw#Unsafe_rawdata #cnt
	if cnt != raw.Bytecount
		return INVAL, 0
	if ret == 0
		return OK, value
	return convert_error errno, 0

fun Getsockopt_error sockfd:Fd level:I32 = Error
	let except, val = Getsockopt_i32 sockfd level SO_ERROR
	return convert_error val

fun Setsockopt_i32 sockfd:Fd level:I32 opt:I32 value:I32 = Error
	let raw:[]U8 such
		raw#Unsafe_wrap ((unsafe.Cast *I32 *U8) *value) (sizeof value) (sizeof value)
	let ret = setsockopt sockfd.Sys_number level opt raw.Unsafe_rawdata raw.Bytecount
	if ret == 0
		return OK
	return convert_error errno

extern let SHUT_RD:I32
extern let SHUT_WR:I32
extern let SHUT_RDWR:I32

extern fun shutdown sockfd:int how:int = int

fun Shutdown sockfd:Fd how:I32 = Error
	let ret = shutdown sockfd.Sys_number how
	if ret == 0
		return OK
	return convert_error errno


extern inline struct Epoll_event =
	isa `Trivial_copy `Trivial_dtor `Trivial_ctor
extern inline Epoll_event fun Mk events:U32 rawdata:?#U8 = this
extern inline Epoll_event met Events = U32
extern inline Epoll_event met Rawdata = ?#U8

extern let EPOLL_CLOEXEC:I32

extern let EPOLL_CTL_ADD:I32
extern let EPOLL_CTL_MOD:I32
extern let EPOLL_CTL_DEL:I32

extern let EPOLLIN:U32
extern let EPOLLOUT:U32
extern let EPOLLRDHUP:U32
extern let EPOLLPRI:U32
extern let EPOLLERR:U32
extern let EPOLLHUP:U32
extern let EPOLLET:U32
extern let EPOLLONESHOT:U32
extern let EPOLLWAKEUP:U32

extern fun epoll_create1 flags:int = int
extern fun epoll_ctl epfd:int op:int fd:int raw_event:*U8 = int
extern fun epoll_pwait epfd:int raw_events:#U8 maxevents:Uint timeout:Int raw_sigmask:?*U8 = int

fun Epoll_create1 flags:I32 = Error, Fd
	let ret = epoll_create1 flags
	if ret >= 0
		return OK, Fd.Mk ret
	return convert_error errno, {}

fun Epoll_ctl epfd:Fd op:I32 fd:Fd event:*Epoll_event = Error
	let ret = epoll_ctl epfd.Sys_number op fd.Sys_number ((unsafe.Cast *Epoll_event *U8) event)
	if ret == 0
		return OK
	return convert_error errno

-- Append to the events slice in the available space.
fun Epoll_pwait epfd:Fd events:[!]Epoll_event timeout:Int raw_sigmask:?*U8 = Error, [!]Epoll_event
	let dst = events!Available_elements
	let ret = epoll_pwait epfd.Sys_number dst#Unsafe_rawdata dst.Count timeout raw_sigmask
	if ret >= 0
		return OK, events![events.Count .. events.Count + (Min ret.Unsigned.Uint dst.Count)]
	return convert_error errno, events


extern let SIGHUP:I32
extern let SIGINT:I32
extern let SIGQUIT:I32
extern let SIGILL:I32
extern let SIGABRT:I32
extern let SIGFPE:I32
extern let SIGKILL:I32
extern let SIGSEGV:I32
extern let SIGPIPE:I32
extern let SIGALRM:I32
extern let SIGTERM:I32

extern let SIGUSR1:I32
extern let SIGUSR2:I32
extern let SIGCHLD:I32
extern let SIGCONT:I32
extern let SIGSTOP:I32
extern let SIGTSTP:I32
extern let SIGTTIN:I32
extern let SIGTTOU:I32

extern let SIGTRAP:I32


extern inline struct Sigset =
	isa `Trivial_copy
Sigset met# Unsafe_raw = #U8
	return (unsafe.Cast #this #U8) self

extern fun sigemptyset raw_set:#U8
extern fun sigaddset raw_set:#U8 signum:int = int

Sigset fun Mk ...signums:(Vararg *I32) = Error, r:this
	let raw = r#Unsafe_raw
	sigemptyset raw
	for signum in signums
		let ret = sigaddset raw signum
		if ret < 0
			return convert_error errno, {}
	return OK, r


extern let SIG_BLOCK:I32
extern let SIG_UNBLOCK:I32
extern let SIG_SETMASK:I32
extern fun sigprocmask how:int raw_set:*U8 raw_oldset:?#U8 = int

fun Sigprocmask how:I32 set:*Sigset oldset:?#Sigset = Error
	let old = nil such
		if oldset?
			old = oldset!Unsafe_raw
	let set_cpy = set*
	let ret = sigprocmask how set_cpy#Unsafe_raw old
	if ret >= 0
		return OK
	return convert_error errno


extern inline struct Signalfd_siginfo =
	isa `Trivial_copy
extern inline Signalfd_siginfo met Signo = U32
extern inline Signalfd_siginfo met Errno = I32
extern inline Signalfd_siginfo met Code = I32
extern inline Signalfd_siginfo met Pid = U32
extern inline Signalfd_siginfo met Uid = U32
extern inline Signalfd_siginfo met Fd = I32
extern inline Signalfd_siginfo met Tid = U32
extern inline Signalfd_siginfo met Band = U32
extern inline Signalfd_siginfo met Overrun = U32
extern inline Signalfd_siginfo met Trapno = U32
extern inline Signalfd_siginfo met Status = I32
extern inline Signalfd_siginfo met Int = I32
extern inline Signalfd_siginfo met Ptr = U64
extern inline Signalfd_siginfo met Utime = U64
extern inline Signalfd_siginfo met Stime = U64
extern inline Signalfd_siginfo met Addr = U64

Signalfd_siginfo met# Raw = ret:[!]U8
	let r = (unsafe.Cast #this #U8) self
	ret#Unsafe_wrap r 0 (sizeof this)


extern let SFD_CLOEXEC:I32
extern let SFD_NONBLOCK:I32

extern fun signalfd fd:int raw_mask:*U8 flags:int = int

fun Signalfd fd:Fd mask:*Sigset flags:I32 = Error, Fd
	var mask_cpy = mask*
	let ret = signalfd fd.Sys_number mask_cpy#Unsafe_raw flags
	if ret >= 0
		return OK, Fd.Mk ret
	return convert_error errno, {}


extern fun SIGACTION_DFL = act:?*U8
extern fun SIGACTION_IGN = act:?*U8
extern fun sigaction signum:int raw_act:?*U8 raw_oldact:?#U8 = int

fun Signal signum:I32 raw_act:?*U8 raw_oldact:?#U8 = Error
	let ret = sigaction signum raw_act raw_oldact
	if ret >= 0
		return OK
	return convert_error errno

extern fun execve filename:*U8 argv:**U8 envp:**U8 = int

fun Execve filename:String argv:[]String envp:[]String = Error
	let cfilename = cstring.Mk filename

	let cargv:(Buf cstring.Cstring) such
		foreach a in argv
			cargv#Push# = cstring.Mk a
	let pcargv:(Buf ?*U8) such
		foreach a in cargv
			pcargv#Push# = a.Rawdata
		if pcargv.Count == 0
			pcargv#Push# = nil

	let cenvp:(Buf cstring.Cstring) such
		foreach a in envp
			cenvp#Push# = cstring.Mk a
	let pcenvp:(Buf ?*U8) such
		foreach a in cenvp
			pcenvp#Push# = a.Rawdata
		if pcenvp.Count == 0
			pcenvp#Push# = nil

	let ret = execve cfilename.Rawdata pcargv.Slice.Unsafe_data pcenvp.Slice.Unsafe_data
	if ret >= 0
		return OK
	return convert_error errno

extern fun pipe2 pipefd:*int flags:int = int

fun Pipe2 flags:I32 = Error, rd:Fd, wr:Fd
	var pipefd = {-1 -1}:[!]int
	let ret = pipe2 pipefd.Unsafe_data flags
	if ret == 0
		return OK, Fd.Mk pipefd.[0], Fd.Mk pipefd.[1]
	return convert_error errno, {}, {}

extern fun fork = pid_t

fun Fork = Error, pid:Uint
	let ret = fork
	if ret >= 0
		return OK, ret.Unsigned.Uint
	return convert_error errno, -1

extern fun _exit status:int

fun Exit status:I32
	_exit status

extern let WNOHANG:I32
extern let WUNTRACED:I32
extern let WCONTINUED:I32

extern fun waitpid pid:pid_t status:#int options:int = pid_t

fun Waitpid for_pid:Int options:I32 = Error, pid:Int, status:I32
	var st:int
	let ret = waitpid for_pid.Trim_i32 #st options
	if ret >= 0
		return OK, ret.Int, st
	return convert_error errno, 0, 0


inline struct Tm =
	Sec	:I32
	Min	:I32
	Hour	:I32
	Mday	:I32
	Mon	:I32
	Year	:I32
	Wday	:I32
	Yday	:I32
	Isdst	:I32

extern fun Gmtime_r timep:*I64 result:#Tm = ?*Tm
extern fun Localtime_r timep:*I64 result:#Tm = ?*Tm

extern fun strftime s:*U8 max:Uint format:*U8 tm:*Tm = Uint

-- If b.Count == r.Count, there may have been an error.
fun Strftime b:[!]U8 format:String tm:*Tm = r:[!]U8
	let dst = b!Available_elements
	let ret = strftime dst#Unsafe_rawdata dst.Count (cstring.Mk format).Rawdata tm
	return b![.. b.Count + ret]
