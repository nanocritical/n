from n import *
import n.syscall
import n.time
import n.unsafe
import n.fmt
import n.io
import n.logging

within logging.Log

enum Events =
	| READ
	| WRITE
	-- Always (try to) read first before processing any error or hang-up.
	| ERROR
	-- Hang up happened on the associated file descriptor. There may be
	-- more data to read.
	| HUP
	-- Stream socket peer closed connection, or shut down writing half
	-- of connection. There may be more data to read.
	| RDHUP
	| CLOSE
	| MANUAL

intf `Handler =
	met# On ev:Event = Error

inline struct Event =
	isa `Show `Has_equality
	Fd	:syscall.Fd
	-- If HUP is in Ask, the Fd will be placed on a closing list, and
	-- closed after all polled events are done processing. In the meantime
	-- further events on the Fd will be ignored.
	Ask	:(Enumset Events)
	Got	:(Enumset Events)
	Handler	:?#`Handler

	let NONE = {}:this

Event met Operator_eq other:*this = Bool
	return self.Fd == other.Fd
		\ and self.Ask == other.Ask
		\ and self.Got == other.Got
		\ and self.Handler === other.Handler

Event met Operator_ne other:*this = Bool
	return not self == other

Event met Show st:#fmt.`State
	fmt.F st "%s on %s" self.Got self.Fd


inline struct Poll =
	fds		:(Map syscall.Fd ?#Event)
	manuals		:(Buf ?#`Handler)
	closes		:(Set syscall.Fd)
	epfd		:syscall.Fd
	buf		:(Buf syscall.Epoll_event)
	pending		:[!]syscall.Epoll_event
	sleeping	:Bool
	Current_handler	:?#`Handler

Poll met# Init = Error
	assert self.buf.Count == 0

	except, self!epfd = syscall.Epoll_create1 0
	self!buf#Reserve 128

Poll met Has_waiters = Bool
	return self.fds.Count != 0 or self.pending.Count != 0

-- If non-zero, Wait will return an event immediately and will not block.
Poll met Pending_events_count = Uint
	return self.pending.Count

fun events_to_sys_events r:Events = U32
	match r
	| READ -> return syscall.EPOLLIN
	| WRITE -> return syscall.EPOLLOUT
	| ERROR -> return syscall.EPOLLERR
	| HUP -> return syscall.EPOLLHUP
	| RDHUP -> return syscall.EPOLLRDHUP
	| CLOSE -> return 0

fun sys_events_to_events events:U32 = r:(Enumset Events)
	if syscall.EPOLLIN & events != 0
		r |= {READ}
	if syscall.EPOLLOUT & events != 0
		r |= {WRITE}
	if syscall.EPOLLERR & events != 0
		r |= {ERROR}
	if syscall.EPOLLHUP & events != 0
		r |= {HUP}
	if syscall.EPOLLRDHUP & events != 0
		r |= {RDHUP}

Poll met! Register e:Event = Error
	if e.Ask.Count == 0
		return OK

	if MANUAL in e.Ask
		self!manuals#Push# = e.Handler

	if CLOSE in e.Ask
		assert self.fds.[e.Fd]?
		_ = self!closes#Add e.Fd

	let just_pseudo = e.Ask <= {MANUAL CLOSE}
	if just_pseudo
		return OK

	let added, perm_e = self!fds#Try_store e.Fd
	and op = syscall.EPOLL_CTL_MOD such
		if added
			perm_e# = Alloc Event
			op = syscall.EPOLL_CTL_ADD

	let pe = perm_e#
	pe!Fd = e.Fd
	_ = pe#Ask#Add_all e.Ask

	assert not pe.Handler? or pe.Handler === e.Handler -- FIXME(e): only one Handler supported.
	pe#Handler = e.Handler

	let sys_events_defaults = syscall.EPOLLERR | syscall.EPOLLHUP | syscall.EPOLLET
	let events = sys_events_defaults such
		for f over pe.Ask.Iter
			events |= events_to_sys_events f

	let rawdata = (unsafe.Cast ?#Event ?#U8) pe

	let sys_event = syscall.Epoll_event.Mk events rawdata

	except = syscall.Epoll_ctl self.epfd op e.Fd sys_event

Poll met! Unregister_all e:Event = Error
	let perm_e = self!fds![e.Fd]
	if not perm_e?
		return INVAL

	Free perm_e*
	_ = self!fds#Delete e.Fd

	-- Old Linux does not accept a nil event.
	let sys_event = syscall.Epoll_event.Mk 0 nil
	never = syscall.Epoll_ctl self.epfd syscall.EPOLL_CTL_DEL e.Fd sys_event

Poll met! Schedule_manually h:#`Handler = Error
	assert not self.sleeping -- FIXME(e): multithread or multi loop: use an eventfd in the pool
	let err = self!Register {Ask={MANUAL} Handler=h}
	return err

Poll met! process_manuals = Error
	-- Processing manual handlers may add more to manuals, so we steal it:
	let manuals = self!manuals#Move
	var keep:(Buf ?#`Handler)
	foreach ph over manuals
		let h = ph*
		if not h?
			continue
		self#Current_handler = h
		let err = h#On {Got={MANUAL} Handler=h}
		self#Current_handler = nil
		if err == io.WOULD_BLOCK
			keep#Push# = h
			continue
		if err != OK
			Log#Warning "Handler error on CLOSE: %s" err

	self!manuals#Append keep.Slice

Poll met! process_closes = closed_some:Bool
	-- Processing close handlers may add more to closes, so we steal it:
	let closes = self!closes#Move
	for fd over closes.Iter
		let pe = self.fds.[fd]
		if not pe?
			Log#Warning "spurious fd on close list: %s" fd
			continue

		let e = pe*
		if e.Handler?
			let e_close = {Fd=e.Fd Got={CLOSE} Handler=e.Handler}:Event
			drop = self!Unregister_all e
			-- Do not use e, it was just freed.

			self#Current_handler = e_close.Handler
			let err = e_close.Handler#On e_close
			self#Current_handler = nil

			if err == io.WOULD_BLOCK
				continue
			if err != OK
				Log#Warning "Handler error on CLOSE: %s" err

			if e_close.Fd.Is_valid
				-- Handler did not close it, so we do it.
				drop = syscall.Close #e_close#Fd
		else
			drop = self!Unregister_all e
			drop = syscall.Close fd

		closed_some = true

-- In a few places, we introduce a pseudo io.WOULD_BLOCK that does not come
-- from a syscall. In general that's a terrible idea, but here it let's us
-- communicate the right idea to Loop or other similar code.
fun pseudo_would_block = Error
	return io.WOULD_BLOCK

Poll met! sys_wait timeout:?time.Duration = Error
	Log#Debug ""

	assert self.pending.Count == 0
	self#sleeping = true
	let err, res = syscall.Epoll_pwait self.epfd self!buf![..]
		\ (timeout?.Millisec else -1) nil
	self#sleeping = false
	if err == syscall.EINTR
		return pseudo_would_block

	self!pending = res

	Log#Debug "%s %s" res.Count

Poll met! Wait ?timeout:?time.Duration = Error, e:Event
	if self.pending.Count == 0
		var closed_some
		while self.manuals.Count + self.closes.Count != 0
			closed_some = self!process_closes or closed_some

			except = self!process_manuals

		if closed_some and not self.Has_waiters and self.Pending_events_count == 0
			-- Give the caller a chance to notice that there are no
			-- waiters anymore. If we're called again, then we'll block
			-- on the syscall.
			-- This is a "spurious" wakeup, we don't return OK.
			return pseudo_would_block, NONE

		let err = self!sys_wait timeout
		if err == io.WOULD_BLOCK
			return err, NONE
		except = err

	-- We tried to get more events. Let's see if we did:
	if self.pending.Count == 0
		return OK, NONE

	let sys_e = self.pending.[0]
	self!pending = self.pending.[1 ..]

	let perm_e = (unsafe.Cast ?#U8 ?#Event) sys_e.Rawdata
	e = perm_e*
	e!Got = sys_events_to_events sys_e.Events


fun Loop poll:#Poll ?continue_despite_handler_error:?Bool = Error
	while poll.Has_waiters
		let wait_err, e = poll!Wait
		if wait_err == io.WOULD_BLOCK
			continue
		except = wait_err

		poll#Current_handler = e.Handler
		let err = e.Handler#On e
		poll#Current_handler = nil
		if err == io.WOULD_BLOCK
			continue

		if err != OK
			if continue_despite_handler_error else false
				Log#Error "%s" err
				continue
			return err
