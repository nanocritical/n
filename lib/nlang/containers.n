from nlang.builtins import *

export intf `locus =
  isa `has_equality `copyable_but_owned
export intf `fwd_locus =
  isa `locus `ordered
export intf `bidir_locus =
  isa `locus `ordered

export intf `iterator =
  method@ get = size
  method@ is_valid = bool
  method@ has_next = bool
  method@! next = void

export inline struct index_range =
  export isa `trivial_copy `trivial_equality `return_by_copy
  _b:size
  _e:size

export index_range method@! init beg:size end:size = void
  let e = end
  such
    if end < beg
      e = beg
  self!_b = beg
  self!_e = e

export index_range method@ begin = size
  return self._b

export index_range method@ end = size
  return self._e

export index_range method@ count = size
  return self._e - self._b

export index_range method@ sub begin:size end:size = this
  let r:this
  such
    if begin < self.begin or end > self.end
      abort
    r!init begin end
  return r

export index_range method@ with_offset offset:size = this
  let r:this
  such
    r!init self.begin+offset self.end+offset
  return r

export index_range method@ iter = index_iterator
  return { r=self. }


export inline struct index_iterator =
  export isa `iterator
  r:index_range
  p:size

export index_iterator method@ get = size
  return self.p

export index_iterator method@ is_valid = bool
  return self.p < self.r.end

export index_iterator method@ has_next = bool
  return self.p + 1 < self.r.end

export index_iterator method@! next = void
  self!p += 1

export fun range beg:size end:size = r:index_range
  r!init beg end
