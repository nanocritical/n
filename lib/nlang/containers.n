from nlang.builtins import *

export intf `locus =
  isa `has_equality `copyable_but_owned
export intf `fwd_locus =
  isa `locus `ordered
export intf `bidir_locus =
  isa `locus `ordered

export intf `iterator t:`copyable =
  method@ has_next = bool
  method@! next = t

export opaque struct index_range =
  export isa `trivial_copy `trivial_equality `return_by_copy
  b:size
  e:size

export index_range method@! init beg:size end:size = void
  let e = end
  such
    if end < beg
      e = beg
  self!b = beg
  self!e = e

export index_range method@ begin = size
  return self.b

export index_range method@ end = size
  return self.e

export index_range method@ count = size
  return self.e - self.b

export index_range method@ sub begin:size end:size = this
  let r:this
  such
    if begin < self.begin or end > self.end
      abort
    r!init begin end
  return r

export index_range method@ with_offset offset:size = this
  let r:this
  such
    r!init self.begin+offset self.end+offset
  return r

export index_range method@ iter = index_iterator
  return { r=self. }


export inline struct index_iterator =
  export isa (`iterator size) `trivial_copy
  r:index_range
  p:size

export index_iterator method@ `iterator.has_next = bool
  return self.p < self.r.end

export index_iterator method@! `iterator.next = size
  let r = self.p
  self!p += 1
  return r

export fun range beg:size end:size = r:index_range
  r!init beg end
