from nlang.builtins import *

alias `locus = {`has_equality `copyable_but_owned}
alias `fwd_locus = {`has_equality `copyable_but_owned `ordered}
alias `bidir_locus = {`has_equality `copyable_but_owned `ordered}

export intf `random_container t:`any =
  method count = size

export intf `iterator t:`copyable =
  method has_next = bool
  method! next = t

export inline struct index_bounds =
  f	:bool
  l	:bool
  b	:size
  e	:size

export inline index_bounds (method t:`any c:(`random_container t)) range_of v:@c = index_range
  if self.f and self.l
    return {b=0 e=v.count}
  elif self.f
    return {b=0 e=self.e}
  elif self.l
    return {b=self.b e=v.count}
  else
    return {b=0 e=v.count}

export inline struct index_range =
  export isa `trivial_copy `trivial_equality `trivial_ctor `return_by_copy
  b	:size
  e	:size

export index_range method begin = size
  return self.b

export index_range method end = size
  return self.e

export index_range method count = size
  return self.e - self.b

export index_range method sub begin:size end:size = this
  let r:this
  such
    if begin < self.begin or end > self.end
      abort
    r = {b=begin e=end}
  return r

export index_range method with_offset offset:size = this
  let r = {b=self.begin+offset e=self.end+offset}
  return r

export index_range method iter = index_iterator
  return { r=self. }


export opaque struct index_iterator =
  export isa (`iterator size) `trivial_copy `trivial_ctor
  r:index_range
  p:size

export index_iterator method `iterator.has_next = bool
  return self.p < self.r.end

export index_iterator method! `iterator.next = size
  let r = self.p
  self!p += 1
  return r

export fun range beg:size end:size = index_range
  return {b=beg e=end}
