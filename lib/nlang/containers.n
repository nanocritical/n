from nlang.literals import *
from nlang.builtins import *

export intf i_locus = i_has_equality i_copyable_but_owned
export intf i_fwd_locus = i_locus i_ordered
export intf i_bidir_locus = i_locus i_ordered

export intf i_iterator =
  method get = size
  method is_valid = bool
  method has_next = bool
  method! next = void

export inline type index_range = \
    export i_trivial_copy \
    export i_trivial_equality \
    export i_return_by_copy
  _b:size
  _e:size

export inline type index_iterator = export i_iterator
  r:index_range
  p:size


export index_range method! init beg:size end:size = void
  let e = end
    if end < beg
      e = beg
  self!_b = beg
  self!_e = e

export index_range method begin = size
  return self._b

export index_range method end = size
  return self._e

export index_range method count = size
  return self._e - self._b

export index_range method sub begin:size end:size = this
  let r:this
    if begin < self.begin or end > self.end
      abort
    r!init begin end
  return r

export index_range method with_offset offset:size = this
  let r:this
    r!init self.begin+offset self.end+offset
  return r

export index_range method iter = index_iterator
  return { r=self. }


export index_iterator method get = size
  return self.p

export index_iterator method is_valid = bool
  return self.p < self.r.end

export index_iterator method has_next = bool
  return self.p + 1 < self.r.end

export index_iterator method! next = void
  self!p += 1

export fun range beg:size end:size = r:index_range
  r!init beg end
