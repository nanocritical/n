from nlang.builtins import *
from nlang.containers import *
from nlang.memory import *
import nlang.unsafe

export inline struct char =
  export isa `static_string_compatible `show
  code:u32

export inline char fun from_static_string s:static_string = this
  assert <- s.count == 1
  return { code=(s.get_char 0).code }

export inline char fun from_ascii c:u8 = char
  return { code=c.to_u32 }

example <- char.from_ascii 49 == '1':char

export inline char method `show.show buf:@#`string_buffer = void
  buf#push self.

export intf `static_string_compatible =
  fun from_static_string s:static_string = final

export intf `const_string =
  isa `static_string_compatible
-- export `random_container
  method count = size
  method all = index_range
  method get_char n:size = char
  method bytes_utf8 = []u8

export intf `string =
  isa `const_string
  method! set_char n:size c:char = void
  method! fill c:char r:index_range = void

export intf `string_buffer =
  isa `string
  method# reserve count:size = void
  method# clear = void
  method# push c:char = void
  method# pop = char
  method# append other:@`const_string = void
  method# copy at:size other:@`const_string off:size count:size = void

export opaque struct static_string =
  export isa `trivial_copy `return_by_copy `ordered_by_compare `show
      \ `static_string_compatible `const_string `trivial_ctor
  bytes	:[]u8

export inline static_string method# unsafe_wrap bytes:@u8 count:size = void
  let raw = (nlang.unsafe.cast @u8 @#u8) bytes
  self.bytes#unsafe_wrap raw count

export inline static_string fun mk bytes:@u8 count:size = r:this
  r#unsafe_wrap bytes count
  return r

export inline static_string fun from_static_string s:static_string = this
  return { bytes=s.bytes }

export inline static_string method `const_string.count = size
  return self.bytes.count

export inline static_string method `const_string.all = index_range
  return self.bytes.all

export inline static_string method `const_string.get_char n:size = char
  return char.from_ascii self.bytes.[n].

export inline static_string method `const_string.bytes_utf8 = []u8
  return self.bytes

export extern static_string method operator_compare other:@this = i32

export static_string method `show.show buf:@#`string_buffer = void
  buf#reserve buf.count + self.count
  for i in self.all.iter
    buf#push (self.get_char i)

example <- '1234'.count == 4
example <- '1234'.all == range 0 4
example <- '1234'.get_char 3 == '4'.get_char 0
example <- '1234'.get_char 1 == '2':char
example <- '1234' == '1234'
example <- '1234'.bytes_utf8.count == 4
example <- '1234'.bytes_utf8.[0]. == 49


export intf `show =
  method show buf:@#`string_buffer = void
