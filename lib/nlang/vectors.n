from nlang import *
import nlang.unsafe
from nlang.sysheap import heap sysheap

export opaque struct vector t:`copyable =
  export isa `trivial_ctor (`array_ctor t) `copyable
  p:(slice t)
  c:size

export inline vector method@# `array_ctor.ctorv c:@(static_array t) = void
  self#reserve c.count
  for i in c.all.iter
    self#push (c.at i).

export inline vector method@ count = size
  return self.c

export inline vector method@$ at n:size = @$t
  assert <- n < self.c
  return self$p$at n

export inline vector method@$ first = @$t
  return self$at 0

export inline vector method@$ last = @$t
  return self$at self.c-1

export inline vector method@ is_empty = bool
  return self.c == 0

export inline vector method@ capacity = size
  return self.p.count

export inline vector method@# reserve n:size = void
  if n > self.capacity
    (heap.slice_realloc t) @!sysheap @#self#p n

export inline vector method@# resize n:size = void
  (heap.slice_realloc t) @!sysheap @#self#p n
  self!c = n

export inline vector method@# push x:t = void
  self#reserve self.c+1
  let n = self.c
  self!c += 1
  let d = self!at n
  d! = x

export inline vector method@# pop = t
  assert <- self.c != 0
  let d = self.last
  self!c -= 1
  return d.

export inline vector method@# clear = void
  (heap.slice_free t) @!sysheap @#self#p

export inline vector method@ all = index_range
  return range 0 self.count

export inline vector method@# `copyable.copy_ctor other:@this = void
  (heap.slice_realloc t) @!sysheap @#self#p other.p.count
  self.p#copy 0 other.p 0 other.p.count
  self!c = other.c

export inline vector method@# append_slice other:@(slice t) = void
  (heap.slice_realloc t) @!sysheap @#self#p other.count
  self.p#copy 0 other 0 other.count
  self!c = other.count

export inline vector method@$ storage = @$(slice t) -- ::unique
  return self.p$sub self.all
