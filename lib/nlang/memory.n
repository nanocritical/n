from nlang.builtins import *
from nlang.containers import *
from nlang.sysheap import sysheap heap
import nlang.unsafe

--export extern struct array_impl t:`any N:size =
--  export isa `trivial_ctor `trivial_dtor `trivial_copy_but_owned
--
--export array_impl fun count = size
--  return N
--
--export array_impl fun bytecount = size
--  return N * (sizeof t)
--
--export array_impl fun all = index_range
--  return range 0 N
--
--export array_impl met$ unsafe_rawdata = @$u8
--  return (unsafe.cast @$this @$u8) self
--
--export array_impl met$ unsafe_data = @$t
--  return (unsafe.cast @$this @$t) self
--
--export array_impl met$ operator_at n:size = @$t
--  assert <- n < N
--  return (unsafe.cast @$u8 @$t) (slice_at_byte self$unsafe_rawdata n)
--
--export array_impl met# copy other:[]t = void
--  assert <- N == other.count
--  let dst = self#unsafe_rawdata
--  and src = other.unsafe_rawdata
--  and bytecnt = N * (sizeof t)
--  slice_memcpy dst src bytecnt
--
--export array_impl shallow met$ operator_sub r:index_range = []$t
--  assert <- r.begin < self.count
--  assert <- r.end <= self.count
--  let raw0 = self$unsafe_rawdata
--  let raw = slice_at_byte raw0 r.begin
--  return {dat=raw cnt=r.count}
