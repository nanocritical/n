/* Generated by re2c 0.13.5 on Fri Jan 25 10:56:13 2013 */
#line 1 "lexer.re"
#include "common.h"
#include "lexer.h"

#include <stdint.h>
#include <stdlib.h>
#include <string.h>

static const char *first_eol_back(const char *start, const char *cur) {
  while (cur >= start) {
    if (cur[0] == '\n') {
      return cur;
    }
    cur -= 1;
  }
  return start;
}

static error block_down(struct parser *parser, bool oneline) {
  parser->block_style[parser->block_depth] = oneline;
  parser->block_depth += 1;
  if (parser->block_depth >= ARRAY_SIZE(parser->block_style)) {
    return EINVAL;
  }
  return 0;
}

static void block_up(struct parser *parser, bool oneline) {
  assert(parser->block_depth > 0);
  assert(parser->block_style[parser->block_depth - 1] == oneline);

  // Don't erase value, lexer_back() needs it.
  parser->block_depth -= 1;
}

static bool block_style(struct parser *parser) {
  return parser->block_style[parser->block_depth - 1];
}

error lexer_scan(struct token *tok, struct parser *parser) {
  typedef char YYCTYPE;
  const char *YYCURSOR = parser->data + parser->pos;
  const char *YYLIMIT = parser->data + parser->len;
  const char *YYMARKER = NULL;
  const char *start;
  char opening;

  size_t spaces = 0;

#define ERROR(e, fmt, ...) do { \
  tok->value = start; \
  snprintf(parser->error_message, sizeof(parser->error_message), fmt, ##__VA_ARGS__); \
  return e; \
} while (0)

#define YYFILL(n) do { \
  if (YYCURSOR >= YYLIMIT + 1) { \
    ERROR(EINVAL, "unexpected end-of-file while reading token"); \
  } \
} while (0)

#define R(type) do { \
  parser->pos = YYCURSOR - parser->data; \
  tok->t = type; \
  tok->value = start; \
  tok->len = YYCURSOR - start; \
  return 0; \
} while (0)

  if (parser->inject_eol_after_eob) {
    parser->inject_eol_after_eob = FALSE;
    parser->tok_was_injected = TRUE;
    tok->t = TEOL;
    tok->value = first_eol_back(parser->data, YYCURSOR);
    tok->len = 1;
    return 0;
  }

  parser->tok_was_injected = FALSE;

normal:
  start = YYCURSOR;


#line 87 "lexer.c"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		240, 240, 240, 240, 240, 240, 240, 240, 
		176, 176,   0,   0,   0,   0,   0,   0, 
		  0, 144, 144, 144, 144, 144, 144,  16, 
		 16,  16,  16,  16,  16,  16,  16,  16, 
		 16,  16,  16,  16,  16,  16,  16,  16, 
		 16,  16,  16,   0,   0,   0,   0,  16, 
		  0, 144, 144, 144, 144, 144, 144,  16, 
		 16,  16,  16,  16,  16,  16,  16,  16, 
		 16,  16,  16,  16,  16,  16,  16,  16, 
		 16,  16,  16,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};

	if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
	yych = *YYCURSOR;
	switch (yych) {
	case '\t':
	case '\r':
	case ' ':	goto yy4;
	case '\n':	goto yy72;
	case '!':	goto yy48;
	case '"':
	case '\'':	goto yy10;
	case '#':	goto yy62;
	case '%':	goto yy38;
	case '&':	goto yy40;
	case '(':	goto yy68;
	case ')':	goto yy70;
	case '*':	goto yy34;
	case '+':	goto yy32;
	case ',':	goto yy54;
	case '-':	goto yy2;
	case '.':	goto yy58;
	case '/':	goto yy36;
	case '0':	goto yy6;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy8;
	case ':':	goto yy52;
	case ';':	goto yy56;
	case '<':	goto yy30;
	case '=':	goto yy46;
	case '>':	goto yy28;
	case '@':	goto yy60;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'g':
	case 'h':
	case 'j':
	case 'k':
	case 'q':
	case 's':
	case 'u':
	case 'v':
	case 'x':
	case 'y':
	case 'z':	goto yy76;
	case '[':	goto yy64;
	case '\\':	goto yy74;
	case '^':	goto yy44;
	case 'a':	goto yy24;
	case 'b':	goto yy22;
	case 'c':	goto yy21;
	case 'd':	goto yy18;
	case 'e':	goto yy14;
	case 'f':	goto yy15;
	case 'i':	goto yy17;
	case 'l':	goto yy19;
	case 'm':	goto yy16;
	case 'n':	goto yy26;
	case 'o':	goto yy25;
	case 'p':	goto yy27;
	case 'r':	goto yy23;
	case 't':	goto yy12;
	case 'w':	goto yy20;
	case '{':	goto yy66;
	case '|':	goto yy42;
	case '}':	goto yy67;
	case '~':	goto yy50;
	default:	goto yy77;
	}
yy2:
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '<') {
		if (yych == '-') goto yy305;
	} else {
		if (yych <= '=') goto yy301;
		if (yych <= '>') goto yy303;
	}
#line 163 "lexer.re"
	{ R(TMINUS); }
#line 235 "lexer.c"
yy4:
	++YYCURSOR;
#line 87 "lexer.re"
	{ goto normal; }
#line 240 "lexer.c"
yy6:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 64) {
		goto yy294;
	}
	if (yych == 'x') goto yy297;
yy7:
#line 89 "lexer.re"
	{ R(TNUMBER); }
#line 251 "lexer.c"
yy8:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy293;
yy9:
#line 90 "lexer.re"
	{ R(TNUMBER); }
#line 259 "lexer.c"
yy10:
	++YYCURSOR;
#line 94 "lexer.re"
	{ opening = *(YYCURSOR-1); goto string; }
#line 264 "lexer.c"
yy12:
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= 'q') {
		if (yych == 'h') goto yy280;
		goto yy79;
	} else {
		if (yych <= 'r') goto yy281;
		if (yych == 'y') goto yy282;
		goto yy79;
	}
yy13:
#line 210 "lexer.re"
	{ R(TIDENT); }
#line 278 "lexer.c"
yy14:
	yych = *++YYCURSOR;
	if (yych == 'l') goto yy251;
	if (yych == 'x') goto yy252;
	goto yy79;
yy15:
	yych = *++YYCURSOR;
	if (yych <= 'q') {
		if (yych == 'o') goto yy241;
		goto yy79;
	} else {
		if (yych <= 'r') goto yy242;
		if (yych == 'u') goto yy243;
		goto yy79;
	}
yy16:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy230;
	if (yych == 'e') goto yy231;
	goto yy79;
yy17:
	yych = *++YYCURSOR;
	if (yych <= 'm') {
		if (yych == 'f') goto yy201;
		if (yych <= 'l') goto yy79;
		goto yy203;
	} else {
		if (yych <= 'n') goto yy204;
		if (yych == 's') goto yy206;
		goto yy79;
	}
yy18:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy184;
	if (yych == 'y') goto yy185;
	goto yy79;
yy19:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy181;
	goto yy79;
yy20:
	yych = *++YYCURSOR;
	if (yych == 'h') goto yy176;
	goto yy79;
yy21:
	yych = *++YYCURSOR;
	if (yych == 'a') goto yy163;
	if (yych == 'o') goto yy164;
	goto yy79;
yy22:
	yych = *++YYCURSOR;
	if (yych == 'l') goto yy153;
	if (yych == 'r') goto yy154;
	goto yy79;
yy23:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy147;
	goto yy79;
yy24:
	yych = *++YYCURSOR;
	if (yych == 'n') goto yy144;
	goto yy79;
yy25:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy142;
	goto yy79;
yy26:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy135;
	if (yych == 'u') goto yy136;
	goto yy79;
yy27:
	yych = *++YYCURSOR;
	if (yych <= 'n') {
		if (yych == 'a') goto yy124;
		goto yy79;
	} else {
		if (yych <= 'o') goto yy125;
		if (yych == 'r') goto yy126;
		goto yy79;
	}
yy28:
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '<') goto yy29;
	if (yych <= '=') goto yy118;
	if (yych <= '>') goto yy120;
yy29:
#line 160 "lexer.re"
	{ R(TGT); }
#line 368 "lexer.c"
yy30:
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= ';') goto yy31;
	if (yych <= '<') goto yy114;
	if (yych <= '=') goto yy112;
yy31:
#line 158 "lexer.re"
	{ R(TLT); }
#line 377 "lexer.c"
yy32:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy110;
#line 162 "lexer.re"
	{ R(TPLUS); }
#line 383 "lexer.c"
yy34:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy108;
#line 164 "lexer.re"
	{ R(TTIMES); }
#line 389 "lexer.c"
yy36:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy106;
#line 165 "lexer.re"
	{ R(TDIVIDE); }
#line 395 "lexer.c"
yy38:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy104;
#line 166 "lexer.re"
	{ R(TMODULO); }
#line 401 "lexer.c"
yy40:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy102;
#line 167 "lexer.re"
	{ R(TBWAND); }
#line 407 "lexer.c"
yy42:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy100;
#line 168 "lexer.re"
	{ R(TBWOR); }
#line 413 "lexer.c"
yy44:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy98;
#line 169 "lexer.re"
	{ R(TBWXOR); }
#line 419 "lexer.c"
yy46:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy96;
#line 161 "lexer.re"
	{ R(TASSIGN); }
#line 425 "lexer.c"
yy48:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy94;
#line 181 "lexer.re"
	{ R(TBANG); }
#line 431 "lexer.c"
yy50:
	++YYCURSOR;
#line 170 "lexer.re"
	{ R(TUBWNOT); }
#line 436 "lexer.c"
yy52:
	++YYCURSOR;
#line 171 "lexer.re"
	{ R(TCOLON); }
#line 441 "lexer.c"
yy54:
	++YYCURSOR;
#line 172 "lexer.re"
	{ R(TCOMMA); }
#line 446 "lexer.c"
yy56:
	++YYCURSOR;
#line 173 "lexer.re"
	{
    if (block_style(parser)) {
      R(TEOL);
    } else {
      ERROR(EINVAL, "lexer: unexpected semicolon in multi-line block");
    }
  }
#line 457 "lexer.c"
yy58:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych == '.') goto yy90;
yy59:
#line 180 "lexer.re"
	{ R(TDOT); }
#line 465 "lexer.c"
yy60:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '!') goto yy88;
	if (yych == '#') goto yy86;
#line 184 "lexer.re"
	{ R(TREFDOT); }
#line 472 "lexer.c"
yy62:
	++YYCURSOR;
#line 185 "lexer.re"
	{ R(TSHARP); }
#line 477 "lexer.c"
yy64:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == ']') goto yy84;
yy65:
#line 212 "lexer.re"
	{ ERROR(EINVAL, "lexer: illegal char '\\0%hho'", *(YYCURSOR - 1)); }
#line 484 "lexer.c"
yy66:
	yych = *++YYCURSOR;
	if (yych == '{') goto yy82;
	goto yy65;
yy67:
	yych = *++YYCURSOR;
	if (yych == '}') goto yy80;
	goto yy65;
yy68:
	++YYCURSOR;
#line 190 "lexer.re"
	{ R(TLPAR); }
#line 497 "lexer.c"
yy70:
	++YYCURSOR;
#line 191 "lexer.re"
	{ R(TRPAR); }
#line 502 "lexer.c"
yy72:
	++YYCURSOR;
#line 193 "lexer.re"
	{ 
    spaces = 0;
    goto eol;
  }
#line 510 "lexer.c"
yy74:
	++YYCURSOR;
#line 198 "lexer.re"
	{
    if (YYCURSOR >= YYLIMIT) {
      ERROR(EINVAL, "non-terminated string");
    }
    if (*YYCURSOR == '\n') {
      YYCURSOR += 1;
      goto normal;
    } else {
      ERROR(EINVAL, "invalid character following '\\'");
    }
  }
#line 525 "lexer.c"
yy76:
	yych = *++YYCURSOR;
	goto yy79;
yy77:
	yych = *++YYCURSOR;
	goto yy65;
yy78:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy79:
	if (yybm[0+yych] & 16) {
		goto yy78;
	}
	goto yy13;
yy80:
	++YYCURSOR;
#line 189 "lexer.re"
	{ R(TRINIT); }
#line 545 "lexer.c"
yy82:
	++YYCURSOR;
#line 188 "lexer.re"
	{ R(TLINIT); }
#line 550 "lexer.c"
yy84:
	++YYCURSOR;
#line 187 "lexer.re"
	{ R(TSLICEBRAKETS); }
#line 555 "lexer.c"
yy86:
	++YYCURSOR;
#line 183 "lexer.re"
	{ R(TREFSHARP); }
#line 560 "lexer.c"
yy88:
	++YYCURSOR;
#line 182 "lexer.re"
	{ R(TREFBANG); }
#line 565 "lexer.c"
yy90:
	yych = *++YYCURSOR;
	if (yych == '.') goto yy92;
yy91:
	YYCURSOR = YYMARKER;
	if (yyaccept <= 0) {
		goto yy7;
	} else {
		goto yy59;
	}
yy92:
	++YYCURSOR;
#line 186 "lexer.re"
	{ R(TDOTDOTDOT); }
#line 580 "lexer.c"
yy94:
	++YYCURSOR;
#line 156 "lexer.re"
	{ R(TNE); }
#line 585 "lexer.c"
yy96:
	++YYCURSOR;
#line 155 "lexer.re"
	{ R(TEQ); }
#line 590 "lexer.c"
yy98:
	++YYCURSOR;
#line 154 "lexer.re"
	{ R(TBWXOR_ASSIGN); }
#line 595 "lexer.c"
yy100:
	++YYCURSOR;
#line 153 "lexer.re"
	{ R(TBWOR_ASSIGN); }
#line 600 "lexer.c"
yy102:
	++YYCURSOR;
#line 152 "lexer.re"
	{ R(TBWAND_ASSIGN); }
#line 605 "lexer.c"
yy104:
	++YYCURSOR;
#line 151 "lexer.re"
	{ R(TMODULO_ASSIGN); }
#line 610 "lexer.c"
yy106:
	++YYCURSOR;
#line 150 "lexer.re"
	{ R(TDIVIDE_ASSIGN); }
#line 615 "lexer.c"
yy108:
	++YYCURSOR;
#line 149 "lexer.re"
	{ R(TTIMES_ASSIGN); }
#line 620 "lexer.c"
yy110:
	++YYCURSOR;
#line 147 "lexer.re"
	{ R(TPLUS_ASSIGN); }
#line 625 "lexer.c"
yy112:
	++YYCURSOR;
#line 157 "lexer.re"
	{ R(TLE); }
#line 630 "lexer.c"
yy114:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy116;
#line 146 "lexer.re"
	{ R(TLSHIFT); }
#line 636 "lexer.c"
yy116:
	++YYCURSOR;
#line 144 "lexer.re"
	{ R(TLSHIFT_ASSIGN); }
#line 641 "lexer.c"
yy118:
	++YYCURSOR;
#line 159 "lexer.re"
	{ R(TGE); }
#line 646 "lexer.c"
yy120:
	++YYCURSOR;
	if ((yych = *YYCURSOR) == '=') goto yy122;
#line 145 "lexer.re"
	{ R(TRSHIFT); }
#line 652 "lexer.c"
yy122:
	++YYCURSOR;
#line 143 "lexer.re"
	{ R(TRSHIFT_ASSIGN); }
#line 657 "lexer.c"
yy124:
	yych = *++YYCURSOR;
	if (yych == 's') goto yy132;
	goto yy79;
yy125:
	yych = *++YYCURSOR;
	if (yych == 's') goto yy129;
	goto yy79;
yy126:
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 130 "lexer.re"
	{ R(Tpre); }
#line 675 "lexer.c"
yy129:
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 131 "lexer.re"
	{ R(Tpost); }
#line 685 "lexer.c"
yy132:
	yych = *++YYCURSOR;
	if (yych != 's') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 129 "lexer.re"
	{ R(Tpass); }
#line 695 "lexer.c"
yy135:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy140;
	goto yy79;
yy136:
	yych = *++YYCURSOR;
	if (yych != 'l') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'l') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 128 "lexer.re"
	{ R(Tnull); }
#line 711 "lexer.c"
yy140:
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 126 "lexer.re"
	{ R(Tnot); }
#line 719 "lexer.c"
yy142:
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 125 "lexer.re"
	{ R(Tor); }
#line 727 "lexer.c"
yy144:
	yych = *++YYCURSOR;
	if (yych != 'd') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 124 "lexer.re"
	{ R(Tand); }
#line 737 "lexer.c"
yy147:
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'u') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'r') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 113 "lexer.re"
	{ R(Treturn); }
#line 753 "lexer.c"
yy153:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy159;
	goto yy79;
yy154:
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'a') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'k') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 111 "lexer.re"
	{ R(Tbreak); }
#line 771 "lexer.c"
yy159:
	yych = *++YYCURSOR;
	if (yych != 'c') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'k') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 118 "lexer.re"
	{ R(Tblock); }
#line 783 "lexer.c"
yy163:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy172;
	goto yy79;
yy164:
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'i') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'u') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 110 "lexer.re"
	{ R(Tcontinue); }
#line 807 "lexer.c"
yy172:
	yych = *++YYCURSOR;
	if (yych != 'c') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'h') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 115 "lexer.re"
	{ R(Tcatch); }
#line 819 "lexer.c"
yy176:
	yych = *++YYCURSOR;
	if (yych != 'i') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'l') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 109 "lexer.re"
	{ R(Twhile); }
#line 833 "lexer.c"
yy181:
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 103 "lexer.re"
	{ R(Tlet); }
#line 843 "lexer.c"
yy184:
	yych = *++YYCURSOR;
	if (yych == 'c') goto yy189;
	if (yych == 'l') goto yy188;
	goto yy79;
yy185:
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 102 "lexer.re"
	{ R(Tdyn); }
#line 858 "lexer.c"
yy188:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy195;
	goto yy79;
yy189:
	yych = *++YYCURSOR;
	if (yych != 'l') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'a') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'r') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 123 "lexer.re"
	{ R(Tdeclare); }
#line 878 "lexer.c"
yy195:
	yych = *++YYCURSOR;
	if (yych != 'g') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'a') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 122 "lexer.re"
	{ R(Tdelegate); }
#line 894 "lexer.c"
yy201:
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 104 "lexer.re"
	{ R(Tif); }
#line 902 "lexer.c"
yy203:
	yych = *++YYCURSOR;
	if (yych == 'p') goto yy225;
	goto yy79;
yy204:
	++YYCURSOR;
	if ((yych = *YYCURSOR) <= '`') {
		if (yych <= '@') {
			if (yych <= '/') goto yy205;
			if (yych <= '9') goto yy78;
		} else {
			if (yych <= 'Z') goto yy78;
			if (yych == '_') goto yy78;
		}
	} else {
		if (yych <= 't') {
			if (yych == 'l') goto yy210;
			if (yych <= 's') goto yy78;
			goto yy209;
		} else {
			if (yych == 'v') goto yy211;
			if (yych <= 'z') goto yy78;
		}
	}
yy205:
#line 108 "lexer.re"
	{ R(Tin); }
#line 930 "lexer.c"
yy206:
	yych = *++YYCURSOR;
	if (yych != 'a') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 127 "lexer.re"
	{ R(Tisa); }
#line 940 "lexer.c"
yy209:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy223;
	goto yy79;
yy210:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy219;
	goto yy79;
yy211:
	yych = *++YYCURSOR;
	if (yych != 'a') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'r') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'i') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'a') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 132 "lexer.re"
	{ R(Tinvariant); }
#line 968 "lexer.c"
yy219:
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 101 "lexer.re"
	{ R(Tinline); }
#line 980 "lexer.c"
yy223:
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 100 "lexer.re"
	{ R(Tintf); }
#line 988 "lexer.c"
yy225:
	yych = *++YYCURSOR;
	if (yych != 'o') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'r') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 119 "lexer.re"
	{ R(Timport); }
#line 1002 "lexer.c"
yy230:
	yych = *++YYCURSOR;
	if (yych == 't') goto yy237;
	goto yy79;
yy231:
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'h') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'o') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'd') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 99 "lexer.re"
	{ R(Tmethod); }
#line 1022 "lexer.c"
yy237:
	yych = *++YYCURSOR;
	if (yych != 'c') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'h') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 112 "lexer.re"
	{ R(Tmatch); }
#line 1034 "lexer.c"
yy241:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy249;
	goto yy79;
yy242:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy246;
	goto yy79;
yy243:
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 98 "lexer.re"
	{ R(Tfun); }
#line 1052 "lexer.c"
yy246:
	yych = *++YYCURSOR;
	if (yych != 'm') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 121 "lexer.re"
	{ R(Tfrom); }
#line 1062 "lexer.c"
yy249:
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 107 "lexer.re"
	{ R(Tfor); }
#line 1070 "lexer.c"
yy251:
	yych = *++YYCURSOR;
	if (yych == 'i') goto yy274;
	if (yych == 's') goto yy275;
	goto yy79;
yy252:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'a':	goto yy256;
	case 'c':	goto yy254;
	case 'p':	goto yy255;
	case 't':	goto yy253;
	default:	goto yy79;
	}
yy253:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy270;
	goto yy79;
yy254:
	yych = *++YYCURSOR;
	if (yych == 'e') goto yy266;
	goto yy79;
yy255:
	yych = *++YYCURSOR;
	if (yych == 'o') goto yy262;
	goto yy79;
yy256:
	yych = *++YYCURSOR;
	if (yych != 'm') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'p') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'l') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 133 "lexer.re"
	{ R(Texample); }
#line 1112 "lexer.c"
yy262:
	yych = *++YYCURSOR;
	if (yych != 'r') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 120 "lexer.re"
	{ R(Texport); }
#line 1124 "lexer.c"
yy266:
	yych = *++YYCURSOR;
	if (yych != 'p') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 't') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 116 "lexer.re"
	{ R(Texcept); }
#line 1136 "lexer.c"
yy270:
	yych = *++YYCURSOR;
	if (yych != 'r') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'n') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 97 "lexer.re"
	{ R(Textern); }
#line 1148 "lexer.c"
yy274:
	yych = *++YYCURSOR;
	if (yych == 'f') goto yy278;
	goto yy79;
yy275:
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 106 "lexer.re"
	{ R(Telse); }
#line 1162 "lexer.c"
yy278:
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 105 "lexer.re"
	{ R(Telif); }
#line 1170 "lexer.c"
yy280:
	yych = *++YYCURSOR;
	if (yych == 'r') goto yy288;
	goto yy79;
yy281:
	yych = *++YYCURSOR;
	if (yych == 'y') goto yy286;
	goto yy79;
yy282:
	yych = *++YYCURSOR;
	if (yych != 'p') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 96 "lexer.re"
	{ R(Ttype); }
#line 1190 "lexer.c"
yy286:
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 114 "lexer.re"
	{ R(Ttry); }
#line 1198 "lexer.c"
yy288:
	yych = *++YYCURSOR;
	if (yych != 'o') goto yy79;
	yych = *++YYCURSOR;
	if (yych != 'w') goto yy79;
	++YYCURSOR;
	if (yybm[0+(yych = *YYCURSOR)] & 16) {
		goto yy78;
	}
#line 117 "lexer.re"
	{ R(Tthrow); }
#line 1210 "lexer.c"
yy292:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy293:
	if (yybm[0+yych] & 32) {
		goto yy292;
	}
	goto yy9;
yy294:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 64) {
		goto yy294;
	}
#line 92 "lexer.re"
	{ R(TNUMBER); }
#line 1229 "lexer.c"
yy297:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy298;
	}
	goto yy91;
yy298:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy298;
	}
#line 91 "lexer.re"
	{ R(TNUMBER); }
#line 1245 "lexer.c"
yy301:
	++YYCURSOR;
#line 148 "lexer.re"
	{ R(TMINUS_ASSIGN); }
#line 1250 "lexer.c"
yy303:
	++YYCURSOR;
#line 134 "lexer.re"
	{
    error e = block_down(parser, TRUE);
    if (e) {
      ERROR(e, "lexer: too many block levels");
    }

    parser->indent += 2;
    R(TSOB);
  }
#line 1263 "lexer.c"
yy305:
	++YYCURSOR;
#line 86 "lexer.re"
	{ goto comment; }
#line 1268 "lexer.c"
}
#line 213 "lexer.re"


eol:

#line 1275 "lexer.c"
{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '\r') {
		if (yych <= '\t') {
			if (yych <= 0x08) goto yy319;
			goto yy311;
		} else {
			if (yych <= '\n') goto yy315;
			if (yych <= '\f') goto yy319;
			goto yy313;
		}
	} else {
		if (yych <= ' ') {
			if (yych <= 0x1F) goto yy319;
		} else {
			if (yych == '-') goto yy317;
			goto yy319;
		}
	}
	++YYCURSOR;
#line 217 "lexer.re"
	{ spaces += 1; goto eol; }
#line 1300 "lexer.c"
yy311:
	++YYCURSOR;
#line 218 "lexer.re"
	{ spaces += 8; goto eol; }
#line 1305 "lexer.c"
yy313:
	++YYCURSOR;
#line 219 "lexer.re"
	{ goto eol; }
#line 1310 "lexer.c"
yy315:
	++YYCURSOR;
#line 220 "lexer.re"
	{ spaces = 0; goto eol; }
#line 1315 "lexer.c"
yy317:
	++YYCURSOR;
#line 221 "lexer.re"
	{
    YYFILL(1);
    if (YYCURSOR[1] == '-') {
      YYCURSOR += 1;
      goto comment_while_eol;
    } else {
      goto eol_any;
    }
  }
#line 1328 "lexer.c"
yy319:
	++YYCURSOR;
#line 230 "lexer.re"
	{ goto eol_any; }
#line 1333 "lexer.c"
}
#line 231 "lexer.re"


eol_any:
  YYCURSOR -= 1;
  if (spaces == parser->indent) {
    if (block_style(parser)) {
      parser->inject_eol_after_eob = TRUE;
      block_up(parser, TRUE);
      R(TEOB);
    } else {
      R(TEOL);
    }
  } else if (spaces == parser->indent + 2) {
    parser->indent = spaces;

    error e = block_down(parser, FALSE);
    if (e) {
      ERROR(e, "lexer: too many block levels");
    }

    R(TSOB);
  } else if (spaces < parser->indent) {
    if (spaces % 2 != 0) {
      ERROR(EINVAL, "lexer: indentation must be a multiple of 2 spaces"
              " (one tab counts for 8 spaces), not %zu", spaces);
    }

    parser->indent -= 2;

    if (spaces != parser->indent) {
      // Closing several blocks at once, return token for the others.
      YYCURSOR = start;
      parser->tok_was_injected = TRUE;
    }

    // EOB must be followed by an EOL.
    parser->inject_eol_after_eob = TRUE;

    block_up(parser, block_style(parser));
    R(TEOB);
  } else {
    ERROR(EINVAL, "indentation must be a multiple of 2 spaces"
            " (one tab counts for 8 spaces), not %zu", spaces);
  }

string:

#line 1383 "lexer.c"
{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '"') {
		if (yych == '\n') goto yy325;
		if (yych <= '!') goto yy329;
		goto yy327;
	} else {
		if (yych <= '\'') {
			if (yych <= '&') goto yy329;
			goto yy327;
		} else {
			if (yych != '\\') goto yy329;
		}
	}
	++YYCURSOR;
#line 278 "lexer.re"
	{
    if (YYCURSOR >= YYLIMIT) {
      ERROR(EINVAL, "non-terminated string");
    }
    if (*YYCURSOR == opening) {
      YYCURSOR += 1; goto string;
    } else {
      goto string;
    }
  }
#line 1412 "lexer.c"
yy325:
	++YYCURSOR;
#line 288 "lexer.re"
	{
    ERROR(EINVAL, "string literal contains a newline");
  }
#line 1419 "lexer.c"
yy327:
	++YYCURSOR;
#line 291 "lexer.re"
	{
    if (*(YYCURSOR - 1) != opening) {
      goto string;
    } else {
      R(TSTRING);
    }
  }
#line 1430 "lexer.c"
yy329:
	++YYCURSOR;
#line 298 "lexer.re"
	{ goto string; }
#line 1435 "lexer.c"
}
#line 299 "lexer.re"


comment:

#line 1442 "lexer.c"
{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych != '\n') goto yy335;
	++YYCURSOR;
#line 303 "lexer.re"
	{ YYCURSOR -= 1; goto normal; }
#line 1451 "lexer.c"
yy335:
	++YYCURSOR;
#line 304 "lexer.re"
	{ goto comment; }
#line 1456 "lexer.c"
}
#line 305 "lexer.re"


comment_while_eol:

#line 1463 "lexer.c"
{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych != '\n') goto yy341;
	++YYCURSOR;
#line 309 "lexer.re"
	{ YYCURSOR -= 1; goto eol; }
#line 1472 "lexer.c"
yy341:
	++YYCURSOR;
#line 310 "lexer.re"
	{ goto comment; }
#line 1477 "lexer.c"
}
#line 311 "lexer.re"

}

void lexer_back(struct parser *parser, const struct token *tok) {
  parser->inject_eol_after_eob = FALSE;

  if (tok->t == TSOB) {
    parser->indent -= 2;
    parser->block_depth -= 1;
  } else if (tok->t == TEOB) {
    parser->block_depth += 1;
    parser->indent += 2;
  }

  if (parser->tok_was_injected) {
    return;
  }

  assert(tok->len < parser->pos);
  parser->pos -= tok->len;
}
