from nlang import *
from nlang.strings import *
export fun main = _nretval:i32 
  block
    noop
    x = 1
  noop
  _Ngensym0 = 2
  y = _Ngensym0 + x
  _Ngensym1 = 0
  _Ngensym2 = _Ngensym1 + y
  return _Ngensym2

export fun main2 = _nretval:i32 
  _Ngensym3 = 0
  return _Ngensym3

export inline fun foo = _nretval:string 
  _Ngensym4 = nlang.strings.string.from_static_string 'test'
  return _Ngensym4

inline fun other4 x:i32 = _nretval:i32 

extern fun other5 x:i32 = _nretval:i32 


type test = `ia <root>.nlang.builtins.`trivial_ctor
  final = t00.syntax.test
  this = t00.syntax.test
  t:i32
  test method foo x:i32 = _nretval:i32 
  block
    noop
    y = x
  return y

  test method <root>.nlang.builtins.`trivial_ctor.ctor = _nretval:void 

  fun <root>.nlang.builtins.`trivial_ctor.mk = r:final 

  fun <root>.nlang.builtins.`trivial_ctor.new = _nretval:@#final 


fun foobar x:i32 = _nretval:i32 
  block
    _Ngensym8 = { }
    block
      _Ngensym5 = 0
      _Ngensym6 = x != _Ngensym5
      noop
      _Ngensym8 = __pre__ _Ngensym6
    noop
    pre _Ngensym8
  _Ngensymd = { }
  block
    _Ngensyma = 0
    _Ngensymb = x != _Ngensyma
    noop
    _Ngensymd = __post__ _Ngensymb
  post _Ngensymd
  _Ngensyme = 0
  return _Ngensyme

fun foobar2 = _nretval:void 
  return

type enu = <root>.nlang.builtins.`trivial_copy <root>.nlang.builtins.`trivial_dtor <root>.nlang.builtins.`enum
  tag_type = nlang.builtins.u32
  final = t00.syntax.enu
  this = t00.syntax.enu
  | V1 = 0
  | V2 = 0 + 1
  | V3 = 0 + 1 + 1
  enu method <root>.nlang.builtins.`copyable.copy_ctor other:@final = _nretval:void 

  enu method <root>.nlang.builtins.`has_equality.operator_eq other:@final = _nretval:bool 

  enu method <root>.nlang.builtins.`has_equality.operator_ne other:@final = _nretval:bool 

