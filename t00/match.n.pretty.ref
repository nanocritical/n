from nlang import *
type enu = `trivial_ctor <root>.nlang.builtins.`trivial_copy <root>.nlang.builtins.`trivial_dtor
  and this = t00.match.enu
  and final = t00.match.enu
  | A = 0
  | B = 0 + 1
  enu method <root>.nlang.builtins.`copyable.copy_ctor other:@final = void


fun foo n:enu = i32
  match n
  | A
    return 0
  | B
    return 1

fun bar n:enu = i32
  match n
  | A
    return 0
  | _
    return 1

type t = <root>.nlang.builtins.`trivial_ctor
  and this = t00.match.t
  and final = t00.match.t
  x:enu
  t method <root>.nlang.builtins.`trivial_ctor.ctor = void

  fun <root>.nlang.builtins.`trivial_ctor.mk = r:final

  fun <root>.nlang.builtins.`trivial_ctor.new = @#final


fun bor xt:@t = bool
  return xt.x == A

export fun main = i32
  and xt = { x=A }
  if not bor @xt
    return 1
  and n = enu.A
  if n != xt.x
    return 1
  and _ = foo n
  and _ = bar A
  match n
  | enu.A
    return 0
  | enu.B
    return 1
