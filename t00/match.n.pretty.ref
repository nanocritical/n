from nlang import *
type enu = i_trivial_ctor <root>.nlang.builtins.i_trivial_copy <root>.nlang.builtins.i_trivial_dtor
  and this = t00.match.enu
  and final = t00.match.enu
  | A = 0
  | B = 0 + 1

enu method <root>.nlang.builtins.i_copyable.copy_ctor other:@final = void

fun foo n:enu = i32
  match n
  | A
    return 0
  | B
    return 1

fun bar n:enu = i32
  match n
  | A
    return 0
  | _
    return 1

type t = <root>.nlang.builtins.i_trivial_ctor
  and this = t00.match.t
  and final = t00.match.t
  x:enu

fun <root>.nlang.builtins.i_trivial_ctor.new = @#final

fun <root>.nlang.builtins.i_trivial_ctor.mk = r:final

t method <root>.nlang.builtins.i_trivial_ctor.ctor = void

fun bor xt:@t = bool
  return xt.x == A

export fun main = i32
  and xt = { x=A }
  if not bor @xt
    return 1
  and n = enu.A
  if n != xt.x
    return 1
  and _ = foo n
  and _ = bar A
  match n
  | enu.A
    return 0
  | enu.B
    return 1
