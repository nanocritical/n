from nlang import *
fun foo = i32
  return block 
  0;;

fun deref p:@u32 = u32
  return .p

export fun main = i32
  if true
    noop
  else
    noop
  block
    assert true
  and x  such
    block
      block
        x = 1
  assert (x == 1)
  assert (foo == 0)
  and x1 = block 
  0;; + 1
  assert (x1 == x)
  and x2 = block 
  1;; + block 
  2;;
  assert (x2 == 3)
  and y1
  and z1  such
    block
      if x > 0
        y1 = 'test'
      else
        y1 = 'error'
    block
      and _Ngensym1:nlang.chars.static_string      such
        if nlang.chars.static_string.operator_eq @y1 block 
  _Ngensym1 = 'test'
  @_Ngensym1;;
          z1 = 0
        else
          z1 = 1
  assert (z1 == 0)
  and y2
  and z2  such
    block
      if x > 0
        y2 = 'test'
      else
        y2 = 'error'
    block
      block
        and tmp = 0        such
          and _Ngensym3:nlang.containers.index_range          such
            for i in nlang.containers.index_range.iter block 
  _Ngensym3 = range 0 100
  @_Ngensym3;;
              and _Ngensym2:nlang.builtins.u32              such
                tmp += nlang.builtins.u32.reinterpret_signed block 
  _Ngensym2 = nlang.builtins.size.trim_u32 @i
  @_Ngensym2;;
        z2 = tmp
  and _Ngensym4:nlang.chars.static_string  such
    assert (nlang.chars.static_string.operator_eq @y2 block 
  _Ngensym4 = 'test'
  @_Ngensym4;;)
  assert (z2 == 50 * 99)
  and _Ngensym5:nlang.builtins.u32  such
    assert (deref block 
  block
    _Ngensym5 = 1
  @_Ngensym5;; == 1)
  return 0
