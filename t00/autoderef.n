from nlang import *
from nlang.vectors import *

struct A =
  isa `trivial_ctor
  dummy	:i32

A (method@ t:`any) foo p:@t = t
  return p.

struct B =
  isa `trivial_ctor
  dummy	:i32

B (method@ t:`any r:`any_ref) foo p:(r t) = t
  return p.

export fun main = i32
  block
    let a = {}:A
    assert <- @1 !== a.foo @@1:i32
    assert <- 1 == a.foo @1:i32
    assert <- 1 == a.foo 1:i32

    let b = {}:B
    assert <- 1 == b.foo @1:i32
    -- assert <- 1 == b.foo 1:i32 -- invalid
    assert <- @1 !== b.foo @@1:i32

    assert <- 1 != (B.foo i32 ref) b @1:i32
    -- assert <- 1 == (B.foo i32 @i32) b 1:i32 -- invalid
    -- assert <- @1 !== (B.foo @i32 @@i32) b @1:i32 -- invalid
    assert <- @1 !== (B.foo @i32 ref) b @@1:i32

  let a = 'test'
  and b = 'test'

  let x = a == b
  assert x
  assert <- @a == b
  assert <- a == @b
  assert <- @a == @b

  let n = @1
  let m = @2
  assert <- n + m == 3:i32
  assert <- @1 + @2  == 3:i32
  assert <- @1 + @2  == @3:i32
  assert <- 1 + @2  == @3:i32
  assert <- 1 + @2  == 3:i32

  -- FIXME: Not yet supported
  --let v = {1 2}:(vector i32)
  --let i = v.all.iter
  --for x in @!i
  --  say @x

  --let e = @en.A
  --match e
  --| A -> noop
  --| B -> noop

  --match e
  --| @A -> noop -- invalid
  --| B -> noop

  return 0
