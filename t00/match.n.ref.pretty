from nlang import *
type enu = `trivial_ctor <root>.nlang.builtins.`trivial_copy <root>.nlang.builtins.`trivial_dtor <root>.nlang.builtins.`enum
  tag_type = nlang.builtins.u32
  final = t00.match.enu
  this = t00.match.enu
  | A = 0
  | B = 0 + 1
  enu method <root>.nlang.builtins.`copyable.copy_ctor other:@final = _nretval:void 

  enu method <root>.nlang.builtins.`has_equality.operator_eq other:@final = _nretval:bool 

  enu method <root>.nlang.builtins.`has_equality.operator_ne other:@final = _nretval:bool 


fun foo n:enu = _nretval:i32 
  match block 
  n;;
  | A
    _Ngensym0 = 0
    return _Ngensym0
  | B
    _Ngensym1 = 1
    return _Ngensym1

fun bar n:enu = _nretval:i32 
  match block 
  n;;
  | A
    _Ngensym2 = 0
    return _Ngensym2
  | _
    _Ngensym3 = 1
    return _Ngensym3

type t = <root>.nlang.builtins.`trivial_ctor
  final = t00.match.t
  this = t00.match.t
  x:enu
  t method <root>.nlang.builtins.`trivial_ctor.ctor = _nretval:void 

  fun <root>.nlang.builtins.`trivial_ctor.mk = r:final 

  fun <root>.nlang.builtins.`trivial_ctor.new = _nretval:@#final 


fun bor xt:@t = _nretval:bool 
  noop
  _Ngensym5 = xt.x == A
  return _Ngensym5

export fun main = _nretval:i32 
  block
    noop
    xt = { x=A }
  if block 
  _Ngensym14 = @xt
  _Ngensym6 = bor _Ngensym14
  _Ngensym7 = not _Ngensym6
  _Ngensym7;;
    _Ngensym8 = 1
    return _Ngensym8
  else
    noop
  noop
  n = enu.A
  if block 
  noop
  _Ngensyma = n != xt.x
  _Ngensyma;;
    _Ngensymb = 1
    return _Ngensymb
  else
    noop
  noop
  _ = foo n
  noop
  _ = bar A
  match block 
  n;;
  | enu.A
    _Ngensymc = 0
    return _Ngensymc
  | enu.B
    _Ngensymd = 1
    return _Ngensymd
